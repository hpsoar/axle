!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
AXLE_CG_CAMERA_H	.\camera.h	2;"	d
AXLE_CG_CG_GL_H	.\model_gl.h	2;"	d
AXLE_CG_CG_OBJECT_H	.\gl_object.h	2;"	d
AXLE_CG_COLOR_H	.\color.h	2;"	d
AXLE_CG_CUBEIMAGE_H	.\cube_image.h	2;"	d
AXLE_CG_CUBE_TEXTURE_GL_H	.\cube_texture_gl.h	2;"	d
AXLE_CG_FPS_COUNTER_H	.\fps_counter.h	2;"	d
AXLE_CG_FRAMEBUFFER_OBJECT_H	.\framebuffer_object.h	2;"	d
AXLE_CG_FWD_H	.\cg_fwd.h	2;"	d
AXLE_CG_GLMATERIAL_H	.\glmaterial.h	2;"	d
AXLE_CG_GLOBJECT_H	.\globject.h	2;"	d
AXLE_CG_GLSLMATERIAL_H	.\glslmaterial.h	2;"	d
AXLE_CG_GL_BUFFER_H	.\gl_buffer.h	2;"	d
AXLE_CG_GROUP_H	.\group.h	2;"	d
AXLE_CG_IMAGE_H	.\image.h	2;"	d
AXLE_CG_IMAGE_TEXTURE_GL_H	.\image_texture_gl.h	2;"	d
AXLE_CG_MATERIAL_FACTORY_H	.\material-factory.h	2;"	d
AXLE_CG_MATERIAL_H	.\material.h	2;"	d
AXLE_CG_OBJECT_FACTORY_H	.\object-factory.h	2;"	d
AXLE_CG_OBJMESH_H	.\glmesh.h	2;"	d
AXLE_CG_PARSER_H	.\parser.h	2;"	d
AXLE_CG_PROGRAM_GLSL_H	.\program_glsl.h	2;"	d
AXLE_CG_RENDERBUFFER_H	.\render_buffer.h	2;"	d
AXLE_CG_RENDER_DEVICE_H	.\render_device_fbo.h	2;"	d
AXLE_CG_SCENE_H	.\scene.h	2;"	d
AXLE_CG_SHADEROBJECT_H	.\shader_object.h	2;"	d
AXLE_CG_TEXTURE_GL_H	.\texture_gl.h	2;"	d
AXLE_CG_UTILS_H	.\utils.h	2;"	d
AX_CG_PARAMS_H	.\params.h	2;"	d
Activate	.\render_device_fbo.h	/^  void Activate() { fbo_.Bind(); }$/;"	f	class:ax::RenderDeviceFBO	access:public	signature:()
Add	.\cg_fwd.h	/^  void Add(int opt) { this->opts_ |= opt; }$/;"	f	class:ax::Options	access:public	signature:(int opt)
Add	.\glmesh.h	/^  void Add(GLGroupPtr g) { objs_.push_back(g); }$/;"	f	class:ax::GLMesh	access:public	signature:(GLGroupPtr g)
Add	.\group.h	/^  void Add(ObjectPtr obj) { if (obj != NULL) objs_.push_back(obj); }$/;"	f	class:ax::Group	access:public	signature:(ObjectPtr obj)
Add	.\scene.h	/^  void Add(const std::string &name, MaterialPtr matl) {$/;"	f	class:ax::Scene	access:private	signature:(const std::string &name, MaterialPtr matl)
Add	.\scene.h	/^  void Add(const std::string &name, ObjectPtr obj) {$/;"	f	class:ax::Scene	access:private	signature:(const std::string &name, ObjectPtr obj)
Add	.\scene.h	/^  void Add(const std::string &name, Texture2DPtr tex) {$/;"	f	class:ax::Scene	access:private	signature:(const std::string &name, Texture2DPtr tex)
AdjustViewport	.\gl_buffer.cc	/^void MultiResolutionBuffer::AdjustViewport(int mipmap_level) {$/;"	f	class:ax::MultiResolutionBuffer	signature:(int mipmap_level)
AdjustViewport	.\gl_buffer.h	/^  void AdjustViewport(int mipmap_level);$/;"	p	class:ax::MultiResolutionBuffer	access:private	signature:(int mipmap_level)
AdjustViewport	.\render_device_fbo.h	/^  void AdjustViewport(const T &target) {$/;"	f	class:ax::RenderDeviceFBO	access:public	signature:(const T &target)
AdjustViewport	.\render_device_fbo.h	/^  void AdjustViewport(int w, int h) { glViewport(0, 0, w, h); }$/;"	f	class:ax::RenderDeviceFBO	access:public	signature:(int w, int h)
ApplyTransform	.\glmesh.cc	/^void GLMesh::ApplyTransform(const ax::Matrix4x4 &m) {$/;"	f	class:ax::GLMesh	signature:(const ax::Matrix4x4 &m)
ApplyTransform	.\glmesh.h	/^  virtual void ApplyTransform(const ax::Matrix4x4 &m) { }$/;"	f	class:ax::GLGroup	access:private	signature:(const ax::Matrix4x4 &m)
ApplyTransform	.\glmesh.h	/^  virtual void ApplyTransform(const ax::Matrix4x4 &m);$/;"	p	class:ax::GLMesh	access:public	signature:(const ax::Matrix4x4 &m)
ApplyTransform	.\globject.h	/^  virtual void ApplyTransform(const ax::Matrix4x4 &m) = 0;$/;"	p	class:ax::Object	access:protected	signature:(const ax::Matrix4x4 &m)
ApplyTransform	.\group.cc	/^void Group::ApplyTransform(const ax::Matrix4x4 &m) {  $/;"	f	class:ax::Group	signature:(const ax::Matrix4x4 &m)
ApplyTransform	.\group.h	/^  virtual void ApplyTransform(const ax::Matrix4x4 &m);$/;"	p	class:ax::Group	access:protected	signature:(const ax::Matrix4x4 &m)
ArrayBufferGL	.\gl_buffer.h	/^  ArrayBufferGL(int target = GL_ARRAY_BUFFER) : target_(target), capacity_(0), id_(0), gpu_ptr_(0), size_(0) { }$/;"	f	class:ax::ArrayBufferGL	access:public	signature:(int target = GL_ARRAY_BUFFER)
ArrayBufferGL	.\gl_buffer.h	/^class ArrayBufferGL {$/;"	c	namespace:ax
ArrayBufferGLPtr	.\cg_fwd.h	/^typedef std::tr1::shared_ptr<ArrayBufferGL> ArrayBufferGLPtr;$/;"	t	namespace:ax
AttachFragShader	.\program_glsl.h	/^  bool AttachFragShader(const char *file) { $/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *file)
AttachGeomShader	.\program_glsl.h	/^  bool AttachGeomShader(const char *file) {$/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *file)
AttachRenderBuffer	.\framebuffer_object.cc	/^void FramebufferObject::AttachRenderBuffer(GLuint buffer_id, $/;"	f	class:ax::FramebufferObject	signature:(GLuint buffer_id, GLenum attachment)
AttachRenderBuffer	.\framebuffer_object.h	/^  void AttachRenderBuffer(GLuint buffId,$/;"	p	class:ax::FramebufferObject	access:public	signature:(GLuint buffId, GLenum attachment = GL_COLOR_ATTACHMENT0_EXT)
AttachRenderBuffers	.\framebuffer_object.cc	/^void FramebufferObject::AttachRenderBuffers($/;"	f	class:ax::FramebufferObject	signature:( int buffer_count, GLuint buffer_id[], GLenum attachment[])
AttachRenderBuffers	.\framebuffer_object.h	/^  void AttachRenderBuffers(int buffer_count, GLuint buffer_id[],$/;"	p	class:ax::FramebufferObject	access:public	signature:(int buffer_count, GLuint buffer_id[], GLenum attachment[] = NULL)
AttachShader	.\program_glsl.cc	/^bool ProgramGLSL::AttachShader(const ShaderPtr shader) const {$/;"	f	class:ax::ProgramGLSL	signature:(const ShaderPtr shader) const
AttachShader	.\program_glsl.cc	/^bool ProgramGLSL::AttachShader(int type, const char *file, const MacroList &macros) {$/;"	f	class:ax::ProgramGLSL	signature:(int type, const char *file, const MacroList &macros)
AttachShader	.\program_glsl.h	/^  bool AttachShader(const ShaderPtr shader) const;$/;"	p	class:ax::ProgramGLSL	access:public	signature:(const ShaderPtr shader) const
AttachShader	.\program_glsl.h	/^  bool AttachShader(int type, const char *file, const MacroList &macros = MacroList());$/;"	p	class:ax::ProgramGLSL	access:public	signature:(int type, const char *file, const MacroList &macros = MacroList())
AttachTexture	.\framebuffer_object.cc	/^void FramebufferObject::AttachTexture(GLenum tex_target, GLuint tex_id, $/;"	f	class:ax::FramebufferObject	signature:(GLenum tex_target, GLuint tex_id, GLenum attachment, int mip_level, int zslice)
AttachTexture	.\framebuffer_object.h	/^  void AttachTexture(GLenum tex_target, GLuint tex_id,$/;"	p	class:ax::FramebufferObject	access:public	signature:(GLenum tex_target, GLuint tex_id, GLenum attachment = GL_COLOR_ATTACHMENT0_EXT, int mip_level = 0, int zslice = 0)
AttachTextures	.\framebuffer_object.cc	/^void FramebufferObject::AttachTextures(int tex_count, GLenum tex_target[], $/;"	f	class:ax::FramebufferObject	signature:(int tex_count, GLenum tex_target[], GLuint tex_id[], GLenum attachment[], int mip_level[], int zslice[])
AttachTextures	.\framebuffer_object.h	/^  void AttachTextures(int tex_count, GLenum tex_target[], $/;"	p	class:ax::FramebufferObject	access:public	signature:(int tex_count, GLenum tex_target[], GLuint tex_id[], GLenum attachment[] = NULL, int mip_level[] = NULL, int zslice[] = NULL)
AttachVertShader	.\program_glsl.h	/^  bool AttachVertShader(const char *file) {$/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *file)
AverageType	.\fps_counter.h	/^  enum AverageType { kOverFrames, kOverTime };$/;"	g	class:ax::FpsCounter	access:public
Begin	.\program_glsl.h	/^  void Begin() { glUseProgram(id_); }$/;"	f	class:ax::ProgramGLSL	access:public	signature:()
Begin	.\utils.h	/^  void Begin() {$/;"	f	class:ax::GPUTimer	access:public	signature:()
BeginDraw	.\glmesh.cc	/^bool GLMesh::BeginDraw(Options opts) const {$/;"	f	class:ax::GLMesh	signature:(Options opts) const
BeginDraw	.\glmesh.h	/^  bool BeginDraw(Options opts) const;$/;"	p	class:ax::GLMesh	access:private	signature:(Options opts) const
BeginInitialize	.\cube_texture_gl.h	/^  bool BeginInitialize(void);$/;"	p	class:ax::CubeTextureGL	access:private	signature:(void)
BeginInitialize	.\image_texture_gl.h	/^  bool BeginInitialize();$/;"	p	class:ax::ImageTextureGL	access:private	signature:()
Bind	.\cube_texture_gl.h	/^  void Bind(void) const;$/;"	p	class:ax::CubeTextureGL	access:public	signature:(void) const
Bind	.\framebuffer_object.cc	/^void FramebufferObject::Bind() const {$/;"	f	class:ax::FramebufferObject	signature:() const
Bind	.\framebuffer_object.h	/^  void Bind() const;$/;"	p	class:ax::FramebufferObject	access:public	signature:() const
Bind	.\gl_buffer.h	/^  void Bind() const { glBindBuffer(this->target_, this->id_); }$/;"	f	class:ax::ArrayBufferGL	access:public	signature:() const
Bind	.\glslmaterial.h	/^  void Bind(const N &names, const V &vals, F f) {$/;"	f	class:ax::GLSLMaterial	access:private	signature:(const N &names, const V &vals, F f)
Bind	.\image_texture_gl.h	/^  void Bind() const;$/;"	p	class:ax::ImageTextureGL	access:public	signature:() const
Bind	.\texture_gl.h	/^  void Bind() const { glBindTexture(this->target(), this->id()); }$/;"	f	class:ax::TextureGL	access:public	signature:() const
BindAsRenderTarget	.\gl_buffer.h	/^  void BindAsRenderTarget() { $/;"	f	class:ax::FrameBuffer	access:public	signature:()
BindConst	.\glslmaterial.h	/^  void BindConst(const char *name, float val) {$/;"	f	class:ax::GLSLMaterial	access:private	signature:(const char *name, float val)
BindConstVec3	.\glslmaterial.h	/^  void BindConstVec3(const char *name, const ax::Vector3 &val) {$/;"	f	class:ax::GLSLMaterial	access:private	signature:(const char *name, const ax::Vector3 &val)
BindConstVec4	.\glslmaterial.h	/^  void BindConstVec4(const char *name, const ax::Vector4 &val) {$/;"	f	class:ax::GLSLMaterial	access:private	signature:(const char *name, const ax::Vector4 &val)
BindFragSubroutine	.\glslmaterial.h	/^  void BindFragSubroutine(const char *name) {$/;"	f	class:ax::GLSLMaterial	access:private	signature:(const char *name)
BindGPUPtr	.\gl_buffer.cc	/^GLuint64 ArrayBufferGL::BindGPUPtr(uint32 access) {$/;"	f	class:ax::ArrayBufferGL	signature:(uint32 access)
BindGPUPtr	.\gl_buffer.h	/^  GLuint64 BindGPUPtr(uint32 access = GL_READ_ONLY);  $/;"	p	class:ax::ArrayBufferGL	access:public	signature:(uint32 access = GL_READ_ONLY)
BindImageTexture	.\texture_gl.h	/^  void BindImageTexture(int32 level, bool layered, int32 layer, uint32 access, uint32 format) {$/;"	f	class:ax::TextureGL	access:public	signature:(int32 level, bool layered, int32 layer, uint32 access, uint32 format)
BindImageTexture	.\texture_gl.h	/^  void BindImageTexture(uint32 unit, int32 level, $/;"	f	class:ax::TextureGL	access:public	signature:(uint32 unit, int32 level, bool layered, int32 layer, uint32 access, uint32 format)
BindTexture	.\glslmaterial.h	/^  void BindTexture(const char *name, const Texture2DPtr &tex) {$/;"	f	class:ax::GLSLMaterial	access:private	signature:(const char *name, const Texture2DPtr &tex)
BindVertSubroutine	.\glslmaterial.h	/^  void BindVertSubroutine(const char *name) {$/;"	f	class:ax::GLSLMaterial	access:private	signature:(const char *name)
CGParamKeyType	.\params.h	/^typedef std::string CGParamKeyType;$/;"	t	namespace:ax
CameraPan	.\camera.h	/^  CameraPan(C *camera) : camera_(camera) { }$/;"	f	class:ax::CameraPan	access:public	signature:(C *camera)
CameraPan	.\camera.h	/^class CameraPan : public TrackableI {$/;"	c	namespace:ax	inherits:TrackableI
CameraRot	.\camera.h	/^  CameraRot(C *camera) : camera_(camera) { }$/;"	f	class:ax::CameraRot	access:public	signature:(C *camera)
CameraRot	.\camera.h	/^class CameraRot : public TrackableI {$/;"	c	namespace:ax	inherits:TrackableI
Capture	.\camera.h	/^  void Capture(int x, int y) {$/;"	f	class:ax::TrackableI	access:public	signature:(int x, int y)
Check	.\render_device_fbo.h	/^  void Check() { fbo_.IsValid(); }$/;"	f	class:ax::RenderDeviceFBO	access:public	signature:()
CheckBufferStatus	.\framebuffer_object.cc	/^bool FramebufferObject::CheckBufferStatus() {$/;"	f	class:ax::FramebufferObject	signature:()
CheckBufferStatus	.\framebuffer_object.h	/^  bool CheckBufferStatus();$/;"	p	class:ax::FramebufferObject	access:public	signature:()
CheckCompileLog	.\shader_object.cc	/^bool ShaderObject::CheckCompileLog() {$/;"	f	class:ax::ShaderObject	signature:()
CheckCompileLog	.\shader_object.h	/^  bool CheckCompileLog();$/;"	p	class:ax::ShaderObject	access:private	signature:()
CheckErrorsGL	.\gl_utils.cc	/^bool CheckErrorsGL(const char* location) {	$/;"	f	namespace:ax	signature:(const char* location)
CheckErrorsGL	.\utils.h	/^bool CheckErrorsGL(const char *location);$/;"	p	namespace:ax	signature:(const char *location)
CheckGLInfo	.\gl_utils.cc	/^bool CheckGLInfo() {$/;"	f	namespace:ax	signature:()
CheckGLInfo	.\utils.h	/^bool CheckGLInfo();$/;"	p	namespace:ax	signature:()
CheckLinkResult	.\program_glsl.cc	/^bool ProgramGLSL::CheckLinkResult() {$/;"	f	class:ax::ProgramGLSL	signature:()
CheckLinkResult	.\program_glsl.h	/^  bool CheckLinkResult();$/;"	p	class:ax::ProgramGLSL	access:private	signature:()
CheckRedundancy	.\framebuffer_object.cc	/^bool FramebufferObject::CheckRedundancy(GLenum attachment, GLuint tex_id,$/;"	f	class:ax::FramebufferObject	signature:(GLenum attachment, GLuint tex_id, int mip_level, int z_slice)
CheckRedundancy	.\framebuffer_object.h	/^  bool CheckRedundancy(GLenum attachment, GLuint tex_id, $/;"	p	class:ax::FramebufferObject	access:protected	signature:(GLenum attachment, GLuint tex_id, int mip_level, int z_slice)
CheckResult	.\gl_object.cc	/^bool GLObject::CheckResult(const std::string &method) const {$/;"	f	class:ax::GLObject	signature:(const std::string &method) const
CheckResult	.\gl_object.h	/^  bool CheckResult(const std::string &method) const;$/;"	p	class:ax::GLObject	access:protected	signature:(const std::string &method) const
Clear	.\cg_fwd.h	/^  void Clear(int opt) { opts_ &= ~opt; }$/;"	f	class:ax::Options	access:public	signature:(int opt)
ClearBuffers	.\gl_buffer.h	/^  void ClearBuffers() { glClear(included_buffers_); }$/;"	f	class:ax::FrameBuffer	access:public	signature:()
ClearColorBuffer	.\gl_buffer.cc	/^void MultiResolutionBuffer::ClearColorBuffer(ax::ProgramGLSLPtr shader) {$/;"	f	class:ax::MultiResolutionBuffer	signature:(ax::ProgramGLSLPtr shader)
ClearColorBuffer	.\gl_buffer.h	/^  void ClearColorBuffer(ax::ProgramGLSLPtr shader); $/;"	p	class:ax::MultiResolutionBuffer	access:public	signature:(ax::ProgramGLSLPtr shader)
Color	.\color.h	/^   Color() : r(0), g(0), b(0), a(0) { }$/;"	f	class:ax::Color	access:public	signature:()
Color	.\color.h	/^   Color(T r, T g, T b) : r(r), g(g), b(b), a(0) { }$/;"	f	class:ax::Color	access:public	signature:(T r, T g, T b)
Color	.\color.h	/^   Color(T r, T g, T b, T a) : r(r), g(g), b(b), a(a) { }$/;"	f	class:ax::Color	access:public	signature:(T r, T g, T b, T a)
Color	.\color.h	/^   Color(const V &v) : r(v.r), g(v.g), b(v.b), a(v.a) { }$/;"	f	class:ax::Color	access:public	signature:(const V &v)
Color	.\color.h	/^class Color {$/;"	c	namespace:ax
ColorBuffer	.\gl_buffer.h	/^  ax::Texture2DPtr ColorBuffer(int i) const { return this->color_buffers_[i]; }$/;"	f	class:ax::FrameBuffer	access:public	signature:(int i) const
Colord	.\color.h	/^typedef Color<double> Colord;$/;"	t	namespace:ax
Colorf	.\color.h	/^typedef Color<float> Colorf;$/;"	t	namespace:ax
ComputeBound	.\glmesh.cc	/^ax::AABB GLMesh::ComputeBound(const ax::Matrix4x4 &m) const {$/;"	f	class:ax::GLMesh	signature:(const ax::Matrix4x4 &m) const
ComputeBound	.\glmesh.h	/^  virtual ax::AABB ComputeBound(const ax::Matrix4x4 &m) const { $/;"	f	class:ax::GLGroup	access:private	signature:(const ax::Matrix4x4 &m) const
ComputeBound	.\glmesh.h	/^  virtual ax::AABB ComputeBound(const ax::Matrix4x4 &m) const;$/;"	p	class:ax::GLMesh	access:public	signature:(const ax::Matrix4x4 &m) const
ComputeBound	.\globject.h	/^  virtual ax::AABB ComputeBound(const ax::Matrix4x4 &m) const = 0;  $/;"	p	class:ax::Object	access:public	signature:(const ax::Matrix4x4 &m) const
ComputeBound	.\group.cc	/^ax::AABB Group::ComputeBound(const ax::Matrix4x4 &m) const {$/;"	f	class:ax::Group	signature:(const ax::Matrix4x4 &m) const
ComputeBound	.\group.h	/^  virtual ax::AABB ComputeBound(const ax::Matrix4x4 &m) const;$/;"	p	class:ax::Group	access:public	signature:(const ax::Matrix4x4 &m) const
ComputeMipmapViewports	.\gl_buffer.cc	/^void MultiResolutionBuffer::ComputeMipmapViewports() {$/;"	f	class:ax::MultiResolutionBuffer	signature:()
ComputeMipmapViewports	.\gl_buffer.h	/^  void ComputeMipmapViewports();$/;"	p	class:ax::MultiResolutionBuffer	access:private	signature:()
Contain	.\cg_fwd.h	/^  bool Contain(int opt) const { return (opts_ &opt) != 0; }$/;"	f	class:ax::Options	access:public	signature:(int opt) const
Copy	.\gl_utils.cc	/^void TextureCopier::Copy(ax::Texture2DPtr texture) {$/;"	f	class:ax::TextureCopier	signature:(ax::Texture2DPtr texture)
Copy	.\gl_utils.cc	/^void TextureCopier::Copy(ax::Texture2DPtr texture, int width, int height) {$/;"	f	class:ax::TextureCopier	signature:(ax::Texture2DPtr texture, int width, int height)
Copy	.\utils.h	/^  static void Copy(ax::Texture2DPtr texture);$/;"	p	class:ax::TextureCopier	access:public	signature:(ax::Texture2DPtr texture)
Copy	.\utils.h	/^  static void Copy(ax::Texture2DPtr, int width, int height);$/;"	p	class:ax::TextureCopier	access:public	signature:(ax::Texture2DPtr, int width, int height)
CopyTexture2D	.\gl_utils.cc	/^void TextureCopier::CopyTexture2D(ax::Texture2DPtr texture) {$/;"	f	class:ax::TextureCopier	signature:(ax::Texture2DPtr texture)
CopyTexture2D	.\utils.h	/^  static void CopyTexture2D(ax::Texture2DPtr texture);$/;"	p	class:ax::TextureCopier	access:private	signature:(ax::Texture2DPtr texture)
CopyTextureRect	.\gl_utils.cc	/^void TextureCopier::CopyTextureRect(ax::Texture2DPtr texture) {$/;"	f	class:ax::TextureCopier	signature:(ax::Texture2DPtr texture)
CopyTextureRect	.\utils.h	/^  static void CopyTextureRect(ax::Texture2DPtr texture);$/;"	p	class:ax::TextureCopier	access:private	signature:(ax::Texture2DPtr texture)
CountExpandedVerts	.\glmesh-loader.cc	/^size_t CountExpandedVerts(const VertAttribsVec &attribs) {$/;"	f	namespace:ax	signature:(const VertAttribsVec &attribs)
CountExpandedVerts	.\glmesh-loader.cc	/^size_t CountExpandedVerts(const VertAttribsVec &attribs1, $/;"	f	namespace:ax	signature:(const VertAttribsVec &attribs1, const VertAttribsVec &attribs2)
Create	.\gl_buffer.h	/^  static ax::ArrayBufferGLPtr Create(uint32 size, uint32 access) {$/;"	f	class:ax::ArrayBufferGL	access:public	signature:(uint32 size, uint32 access)
Create	.\gl_buffer.h	/^  static ax::ArrayBufferGLPtr Create(uint32 target, uint32 size, uint32 access,$/;"	f	class:ax::ArrayBufferGL	access:public	signature:(uint32 target, uint32 size, uint32 access, const void *data)
Create	.\glmesh.h	/^  static GLGroupPtr Create(int tri_start, int n_tris) {$/;"	f	class:ax::GLGroup	access:public	signature:(int tri_start, int n_tris)
Create	.\glmesh.h	/^  static GLMeshPtr Create(ax::TriMeshPtr mesh, bool as_whole = false) {$/;"	f	class:ax::GLMesh	access:public	signature:(ax::TriMeshPtr mesh, bool as_whole = false)
Create	.\image.h	/^  static ImagePtr Create(int w, int h, int format, int type, char *data) {$/;"	f	class:ax::Image	access:public	signature:(int w, int h, int format, int type, char *data)
Create	.\model_gl.h	/^  static ScreenQuadPtr Create() {$/;"	f	class:ax::ScreenQuad	access:public	signature:()
Create	.\program_glsl.cc	/^ProgramGLSLPtr ProgramGLSL::Create(const char *vertex_shader, $/;"	f	class:ax::ProgramGLSL	signature:(const char *vertex_shader, const char *fragment_shader, const std::string &name, const MacroList &macros)
Create	.\program_glsl.h	/^  static ProgramGLSLPtr Create(const char *vertex_shader, $/;"	p	class:ax::ProgramGLSL	access:public	signature:(const char *vertex_shader, const char *fragment_shader, const std::string &name = Ó, const MacroList &macros = MacroList())
Create	.\render_device_fbo.h	/^  static FBODevicePtr Create() {$/;"	f	class:ax::RenderDeviceFBO	access:public	signature:()
Create	.\scene.cc	/^ScenePtr Scene::Create(const std::string &file, Options opts) {$/;"	f	class:ax::Scene	signature:(const std::string &file, Options opts)
Create	.\scene.h	/^  static ScenePtr Create(const std::string &file, Options opts);$/;"	p	class:ax::Scene	access:public	signature:(const std::string &file, Options opts)
Create	.\shader_object.h	/^  static ShaderPtr Create(int type, const char *file, const MacroList &macros = MacroList()) {$/;"	f	class:ax::ShaderObject	access:public	signature:(int type, const char *file, const MacroList &macros = MacroList())
Create	.\texture_gl.h	/^  static Texture2DPtr Create(int target, const std::string &name = "") {$/;"	f	class:ax::Texture2D	access:public	signature:(int target, const std::string &name = Ó)
Create	.\texture_gl.h	/^  static Texture3DPtr Create(int target, const std::string &name = "") {$/;"	f	class:ax::Texture3D	access:public	signature:(int target, const std::string &name = Ó)
Create	.\trimesh_glmmodel.h	/^  static TriMeshPtr Create(GLMmodelPtr model, ax::Options opts) {$/;"	f	class:ax::TriMeshGLM	access:public	signature:(GLMmodelPtr model, ax::Options opts)
Create	.\utils.h	/^  static ax::GPUTimerPtr Create(const std::string &name) {$/;"	f	class:ax::GPUTimer	access:public	signature:(const std::string &name)
Create	.\utils.h	/^  static ax::RenderAppPtr Create($/;"	f	class:ax::RenderAppI	access:public	signature:( RenderAppI *app, const ax::ParamSet2 &params = ax::ParamSet2())
Create2D	.\texture_gl.h	/^  static Texture2DPtr Create2D(const std::string &name = "") {$/;"	f	class:ax::Texture2D	access:public	signature:(const std::string &name = Ó)
CreateCustomMipmap	.\gl_utils.cc	/^int TextureUtil::CreateCustomMipmap(ax::ProgramGLSLPtr shader, ax::Texture2DPtr texture, int min_res) {$/;"	f	class:ax::TextureUtil	signature:(ax::ProgramGLSLPtr shader, ax::Texture2DPtr texture, int min_res)
CreateCustomMipmap	.\utils.h	/^  static int CreateCustomMipmap(ax::ProgramGLSLPtr shader, ax::Texture2DPtr texture, int min_res = 2);$/;"	p	class:ax::TextureUtil	access:public	signature:(ax::ProgramGLSLPtr shader, ax::Texture2DPtr texture, int min_res = 2)
CreateFromCode	.\program_glsl.cc	/^ProgramGLSLPtr ProgramGLSL::CreateFromCode(const char *vert_src, const char *frag_src, const char *name) {$/;"	f	class:ax::ProgramGLSL	signature:(const char *vert_src, const char *frag_src, const char *name)
CreateFromCode	.\program_glsl.h	/^  static ProgramGLSLPtr CreateFromCode(const char *vert_src, const char *frag_src, const char *name = "");$/;"	p	class:ax::ProgramGLSL	access:public	signature:(const char *vert_src, const char *frag_src, const char *name = Ó)
CreateFromCode	.\shader_object.h	/^  static ShaderPtr CreateFromCode(int type, const char *code, const char *name = "") {$/;"	f	class:ax::ShaderObject	access:public	signature:(int type, const char *code, const char *name = Ó)
CreateGLMaterial	.\material-factory.cc	/^GLMaterialPtr MaterialFactory::CreateGLMaterial() {$/;"	f	class:ax::MaterialFactory	signature:()
CreateGLMaterial	.\material-factory.cc	/^MaterialPtr MaterialFactory::CreateGLMaterial($/;"	f	class:ax::MaterialFactory	signature:( const char *name, FILE *fp)
CreateGLMaterial	.\material-factory.h	/^  static GLMaterialPtr CreateGLMaterial();$/;"	p	class:ax::MaterialFactory	access:public	signature:()
CreateGLMaterial	.\material-factory.h	/^  static MaterialPtr CreateGLMaterial(const char *name, FILE *fp);$/;"	p	class:ax::MaterialFactory	access:public	signature:(const char *name, FILE *fp)
CreateGLSLMaterial	.\material-factory.cc	/^GLSLMaterialPtr MaterialFactory::CreateGLSLMaterial() {$/;"	f	class:ax::MaterialFactory	signature:()
CreateGLSLMaterial	.\material-factory.cc	/^MaterialPtr MaterialFactory::CreateGLSLMaterial(const char *name, FILE *fp, $/;"	f	class:ax::MaterialFactory	signature:(const char *name, FILE *fp, Scene *s)
CreateGLSLMaterial	.\material-factory.h	/^  static GLSLMaterialPtr CreateGLSLMaterial();$/;"	p	class:ax::MaterialFactory	access:public	signature:()
CreateGLSLMaterial	.\material-factory.h	/^  static MaterialPtr CreateGLSLMaterial(const char *name, FILE *fp, Scene *s);$/;"	p	class:ax::MaterialFactory	access:public	signature:(const char *name, FILE *fp, Scene *s)
CreateGroup	.\object-factory.cc	/^GroupPtr ObjectFactory::CreateGroup() { return GroupPtr(new Group()); }$/;"	f	class:ax::ObjectFactory	signature:()
CreateGroup	.\object-factory.cc	/^ObjectPtr ObjectFactory::CreateGroup(FILE *fp, Scene *s) {  $/;"	f	class:ax::ObjectFactory	signature:(FILE *fp, Scene *s)
CreateGroup	.\object-factory.h	/^  static GroupPtr CreateGroup();$/;"	p	class:ax::ObjectFactory	access:public	signature:()
CreateGroup	.\object-factory.h	/^  static ObjectPtr CreateGroup(FILE *fp, Scene *s);$/;"	p	class:ax::ObjectFactory	access:public	signature:(FILE *fp, Scene *s)
CreateIndexArray	.\glmesh-loader.cc	/^uint32 *CreateIndexArray(const GLMmodel *model) {$/;"	f	namespace:ax	signature:(const GLMmodel *model)
CreateMaxDepthDerivativeTexture	.\gl_utils.cc	/^void TextureUtil::CreateMaxDepthDerivativeTexture($/;"	f	class:ax::TextureUtil	signature:( ax::Texture2DPtr position_tex, ax::Texture2DPtr texture)
CreateMaxDepthDerivativeTexture	.\utils.h	/^  void CreateMaxDepthDerivativeTexture(ax::Texture2DPtr position_tex,$/;"	p	class:ax::TextureUtil	access:public	signature:(ax::Texture2DPtr position_tex, ax::Texture2DPtr texture)
CreateMinMaxNormalTexture	.\gl_utils.cc	/^void TextureUtil::CreateMinMaxNormalTexture($/;"	f	class:ax::TextureUtil	signature:( ax::Texture2DPtr normal_tex, ax::Texture2DPtr texture)
CreateMinMaxNormalTexture	.\utils.h	/^  void CreateMinMaxNormalTexture(ax::Texture2DPtr normal_tex,$/;"	p	class:ax::TextureUtil	access:public	signature:(ax::Texture2DPtr normal_tex, ax::Texture2DPtr texture)
CreateNormalArray	.\glmesh-loader.cc	/^Normal *CreateNormalArray(const GLMmodel *model) {$/;"	f	namespace:ax	signature:(const GLMmodel *model)
CreateQuad2D	.\model_gl.h	/^  void CreateQuad2D(const float x1, const float y1, $/;"	f	class:ax::Quad2DGL	access:private	signature:(const float x1, const float y1, const float x2, const float y2)
CreateRect	.\texture_gl.h	/^  static Texture2DPtr CreateRect(const std::string &name = "") {$/;"	f	class:ax::Texture2D	access:public	signature:(const std::string &name = Ó)
CreateTexCoordArray	.\glmesh-loader.cc	/^float *CreateTexCoordArray(const GLMmodel *model) {$/;"	f	namespace:ax	signature:(const GLMmodel *model)
CreateVBO	.\model_gl.cc	/^void Quad2DGL::CreateVBO() {$/;"	f	class:ax::Quad2DGL	signature:()
CreateVBO	.\model_gl.h	/^  void CreateVBO();$/;"	p	class:ax::Quad2DGL	access:private	signature:()
CreateVertexArray	.\glmesh-loader.cc	/^Point *CreateVertexArray(const GLMmodel *model) {$/;"	f	namespace:ax	signature:(const GLMmodel *model)
CubeImage	.\cube_image.h	/^  CubeImage() : width_(0), height_(0), format_(0), type_(0) {$/;"	f	class:ax::CubeImage	access:public	signature:()
CubeImage	.\cube_image.h	/^class CubeImage {$/;"	c	namespace:ax
CubeTexture	.\texture_gl.h	/^  CubeTexture(const std::string &name = "") : $/;"	f	class:ax::CubeTexture	access:public	signature:(const std::string &name = Ó)
CubeTexture	.\texture_gl.h	/^class CubeTexture : public TextureGL {$/;"	c	namespace:ax	inherits:TextureGL
CubeTextureGL	.\cube_texture_gl.h	/^  CubeTextureGL(void) : tex_id_(0) { }$/;"	f	class:ax::CubeTextureGL	access:public	signature:(void)
CubeTextureGL	.\cube_texture_gl.h	/^class CubeTextureGL {$/;"	c	namespace:ax
CudaArrayBufferGL	.\gl_buffer.h	/^  CudaArrayBufferGL() : registered_(false), mapped_(false) { }$/;"	f	class:ax::CudaArrayBufferGL	access:public	signature:()
CudaArrayBufferGL	.\gl_buffer.h	/^class CudaArrayBufferGL : public ax::ArrayBufferGL {$/;"	c	namespace:ax	inherits:ax::ArrayBufferGL
DEPRECATED	.\gl_buffer.h	/^  struct DEPRECATED(ParamNames) {$/;"	f	class:ax::FrameBuffer	access:public	signature:(ParamNames)
DEPRECATED	.\model_gl.h	/^class DEPRECATED(MyScreenQuad) {$/;"	f	namespace:ax	signature:(MyScreenQuad)
DEPRECATED	.\utils.h	/^class DEPRECATED(GPUTimerManager) {$/;"	f	namespace:ax	signature:(GPUTimerManager)
DISABLE_COPY_AND_ASSIGN	.\cube_image.h	/^  DISABLE_COPY_AND_ASSIGN(CubeImage);$/;"	p	class:ax::CubeImage	access:private	signature:(CubeImage)
DISABLE_COPY_AND_ASSIGN	.\cube_texture_gl.h	/^  DISABLE_COPY_AND_ASSIGN(CubeTextureGL);$/;"	p	class:ax::CubeTextureGL	access:private	signature:(CubeTextureGL)
DISABLE_COPY_AND_ASSIGN	.\gl_object.h	/^  DISABLE_COPY_AND_ASSIGN(GLObject);$/;"	p	class:ax::GLObject	access:protected	signature:(GLObject)
DISABLE_COPY_AND_ASSIGN	.\globject.h	/^  DISABLE_COPY_AND_ASSIGN(Object);$/;"	p	class:ax::Object	access:protected	signature:(Object)
DISABLE_COPY_AND_ASSIGN	.\image.h	/^  DISABLE_COPY_AND_ASSIGN(Image);$/;"	p	class:ax::Image	access:private	signature:(Image)
DISABLE_COPY_AND_ASSIGN	.\material.h	/^  DISABLE_COPY_AND_ASSIGN(Material);$/;"	p	class:ax::Material	access:private	signature:(Material)
DISABLE_COPY_AND_ASSIGN	.\scene.h	/^  DISABLE_COPY_AND_ASSIGN(Scene);$/;"	p	class:ax::Scene	access:private	signature:(Scene)
DISABLE_COPY_AND_ASSIGN	.\texture_gl.h	/^  DISABLE_COPY_AND_ASSIGN(TextureGL);$/;"	p	class:ax::TextureGL	access:private	signature:(TextureGL)
DISABLE_COPY_AND_ASSIGN	.\utils.h	/^  DISABLE_COPY_AND_ASSIGN(RenderAppI);$/;"	p	class:ax::RenderAppI	access:private	signature:(RenderAppI)
DISABLE_COPY_AND_ASSIGN	.\utils.h	/^  DISABLE_COPY_AND_ASSIGN(TextureUtil);$/;"	p	class:ax::TextureUtil	access:private	signature:(TextureUtil)
Deactivate	.\render_device_fbo.h	/^  void Deactivate() { FramebufferObject::Disable(); }$/;"	f	class:ax::RenderDeviceFBO	access:public	signature:()
DefineMacros	.\shader_object.cc	/^void DefineMacros(std::string &code, const MacroList &macros) {$/;"	f	namespace:ax	signature:(std::string &code, const MacroList &macros)
DeleteProgram	.\program_glsl.h	/^  void DeleteProgram() {$/;"	f	class:ax::ProgramGLSL	access:private	signature:()
DeleteShader	.\shader_object.cc	/^void ShaderObject::DeleteShader() {$/;"	f	class:ax::ShaderObject	signature:()
DeleteShader	.\shader_object.h	/^  void DeleteShader();$/;"	p	class:ax::ShaderObject	access:private	signature:()
DepthBuffer	.\gl_buffer.h	/^  DEPRECATED(ax::Texture2DPtr DepthBuffer() const) {$/;"	f	class:ax::FrameBuffer	access:public	signature:() const
DepthRange	.\scene.cc	/^void Scene::DepthRange(const Matrix4x4 &mat, $/;"	f	class:ax::Scene	signature:(const Matrix4x4 &mat, float *min_depth, float *max_depth) const
DepthRange	.\scene.h	/^  void DepthRange(const Matrix4x4 &mat, $/;"	p	class:ax::Scene	access:public	signature:(const Matrix4x4 &mat, float *min_depth, float *max_depth) const
Disable	.\framebuffer_object.cc	/^void FramebufferObject::Disable() {$/;"	f	class:ax::FramebufferObject	signature:()
Disable	.\framebuffer_object.h	/^  static void Disable();$/;"	p	class:ax::FramebufferObject	access:public	signature:()
Disable	.\image_texture_gl.h	/^  void Disable() const;$/;"	p	class:ax::ImageTextureGL	access:public	signature:() const
Disable	.\material.h	/^  virtual void Disable() const { }$/;"	f	class:ax::Material	access:public	signature:() const
Disable	.\texture_gl.h	/^  void Disable() const { glDisable(this->target()); }$/;"	f	class:ax::TextureGL	access:public	signature:() const
DisableColorBuffer	.\render_device_fbo.cc	/^void RenderDeviceFBO::DisableColorBuffer() {$/;"	f	class:ax::RenderDeviceFBO	signature:()
DisableColorBuffer	.\render_device_fbo.h	/^  void DisableColorBuffer();$/;"	p	class:ax::RenderDeviceFBO	access:public	signature:()
DisableDepthBuffer	.\render_device_fbo.cc	/^void RenderDeviceFBO::DisableDepthBuffer() {$/;"	f	class:ax::RenderDeviceFBO	signature:()
DisableDepthBuffer	.\render_device_fbo.h	/^  void DisableDepthBuffer();$/;"	p	class:ax::RenderDeviceFBO	access:public	signature:()
DisableStencilBuffer	.\render_device_fbo.cc	/^void RenderDeviceFBO::DisableStencilBuffer() {$/;"	f	class:ax::RenderDeviceFBO	signature:()
DisableStencilBuffer	.\render_device_fbo.h	/^  void DisableStencilBuffer();$/;"	p	class:ax::RenderDeviceFBO	access:public	signature:()
DisplayStatistics	.\gl_utils.cc	/^void DisplayStatistics(const char *name, float data, const char *unit, $/;"	f	namespace:ax	signature:(const char *name, float data, const char *unit, int x, int y)
DisplayStatistics	.\utils.h	/^void DisplayStatistics(const char *name, float data, const char *unit,$/;"	p	namespace:ax	signature:(const char *name, float data, const char *unit, int x = 2, int y = 9)
Draw	.\glmesh.cc	/^void GLGroup::Draw(Options opts) const {$/;"	f	class:ax::GLGroup	signature:(Options opts) const
Draw	.\glmesh.cc	/^void GLGroup::Draw(ProgramGLSLPtr prog, Options opts) const {  $/;"	f	class:ax::GLGroup	signature:(ProgramGLSLPtr prog, Options opts) const
Draw	.\glmesh.cc	/^void GLGroup::Draw(const Scene *s, Options opts) const {  $/;"	f	class:ax::GLGroup	signature:(const Scene *s, Options opts) const
Draw	.\glmesh.cc	/^void GLMesh::Draw(ProgramGLSLPtr prog, Options opts) const {$/;"	f	class:ax::GLMesh	signature:(ProgramGLSLPtr prog, Options opts) const
Draw	.\glmesh.cc	/^void GLMesh::Draw(const Scene *s, Options opts) const {$/;"	f	class:ax::GLMesh	signature:(const Scene *s, Options opts) const
Draw	.\glmesh.h	/^  virtual void Draw(ProgramGLSLPtr prog, Options opts) const;$/;"	p	class:ax::GLGroup	access:public	signature:(ProgramGLSLPtr prog, Options opts) const
Draw	.\glmesh.h	/^  virtual void Draw(ProgramGLSLPtr prog, Options opts) const;$/;"	p	class:ax::GLMesh	access:public	signature:(ProgramGLSLPtr prog, Options opts) const
Draw	.\glmesh.h	/^  virtual void Draw(const Scene *s, Options opts) const;$/;"	p	class:ax::GLGroup	access:public	signature:(const Scene *s, Options opts) const
Draw	.\glmesh.h	/^  virtual void Draw(const Scene *s, Options opts) const;$/;"	p	class:ax::GLMesh	access:public	signature:(const Scene *s, Options opts) const
Draw	.\glmesh.h	/^  void Draw(Options opts) const;$/;"	p	class:ax::GLGroup	access:private	signature:(Options opts) const
Draw	.\globject.h	/^  virtual void Draw(ProgramGLSLPtr prog, Options opts) const = 0;$/;"	p	class:ax::Object	access:public	signature:(ProgramGLSLPtr prog, Options opts) const
Draw	.\globject.h	/^  virtual void Draw(const Scene *s, Options opts) const = 0;$/;"	p	class:ax::Object	access:public	signature:(const Scene *s, Options opts) const
Draw	.\group.cc	/^void Group::Draw(ProgramGLSLPtr prog, Options opts) const {$/;"	f	class:ax::Group	signature:(ProgramGLSLPtr prog, Options opts) const
Draw	.\group.cc	/^void Group::Draw(const Scene *s, Options opts) const {$/;"	f	class:ax::Group	signature:(const Scene *s, Options opts) const
Draw	.\group.h	/^  void Draw(ProgramGLSLPtr prog, Options opts) const;$/;"	p	class:ax::Group	access:public	signature:(ProgramGLSLPtr prog, Options opts) const
Draw	.\group.h	/^  void Draw(const Scene *s, Options opts) const;$/;"	p	class:ax::Group	access:public	signature:(const Scene *s, Options opts) const
Draw	.\model_gl.cc	/^void MyScreenQuad::Draw() {$/;"	f	class:ax::MyScreenQuad	signature:()
Draw	.\model_gl.cc	/^void Quad2DGL::Draw() {$/;"	f	class:ax::Quad2DGL	signature:()
Draw	.\model_gl.cc	/^void ScreenQuad::Draw(ax::ProgramGLSLPtr prog) {$/;"	f	class:ax::ScreenQuad	signature:(ax::ProgramGLSLPtr prog)
Draw	.\model_gl.h	/^  void Draw();$/;"	p	class:ax::Quad2DGL	access:public	signature:()
Draw	.\model_gl.h	/^  void Draw(ax::ProgramGLSLPtr prog);$/;"	p	class:ax::ScreenQuad	access:public	signature:(ax::ProgramGLSLPtr prog)
Draw	.\scene.cc	/^void Scene::Draw(Options opts) const {  $/;"	f	class:ax::Scene	signature:(Options opts) const
Draw	.\scene.cc	/^void Scene::Draw(ProgramGLSLPtr prog, Options opts) const {$/;"	f	class:ax::Scene	signature:(ProgramGLSLPtr prog, Options opts) const
Draw	.\scene.h	/^  void Draw(Options opts) const;$/;"	p	class:ax::Scene	access:public	signature:(Options opts) const
Draw	.\scene.h	/^  void Draw(ProgramGLSLPtr prog, Options opts) const;$/;"	p	class:ax::Scene	access:public	signature:(ProgramGLSLPtr prog, Options opts) const
DrawCube	.\model_gl.cc	/^void DrawCube(float size);$/;"	p	namespace:ax	file:	signature:(float size)
DrawCube	.\model_gl.cc	/^void DrawCube(float x1, float y1, float z1, float x2, float y2, float z2) {$/;"	f	namespace:ax	signature:(float x1, float y1, float z1, float x2, float y2, float z2)
DrawCube	.\model_gl.h	/^inline void DrawCube(const Point &p1, const Point &p2) {$/;"	f	namespace:ax	signature:(const Point &p1, const Point &p2)
DrawCube	.\model_gl.h	/^void DrawCube(float x1, float y1, float z1,$/;"	p	namespace:ax	signature:(float x1, float y1, float z1, float x2, float y2, float z2)
DrawFullScreenQuad	.\gl_utils.cc	/^void TextureCopier::DrawFullScreenQuad(ax::ProgramGLSLPtr prog) {$/;"	f	class:ax::TextureCopier	signature:(ax::ProgramGLSLPtr prog)
DrawFullScreenQuad	.\utils.h	/^  static void DrawFullScreenQuad(ax::ProgramGLSLPtr prog);$/;"	p	class:ax::TextureCopier	access:private	signature:(ax::ProgramGLSLPtr prog)
DrawQuad	.\model_gl.cc	/^void DrawQuad(float x1, float y1 ,float x2, float y2, float z) {$/;"	f	namespace:ax	signature:(float x1, float y1 ,float x2, float y2, float z)
DrawQuad	.\model_gl.cc	/^void DrawQuad(float x1, float y1, float x2, float y2) {$/;"	f	namespace:ax	signature:(float x1, float y1, float x2, float y2)
DrawQuad	.\model_gl.cc	/^void DrawQuad(float x1, float y1, float z1,  float x2, float y2, float z2) {$/;"	f	namespace:ax	signature:(float x1, float y1, float z1, float x2, float y2, float z2)
DrawQuad	.\model_gl.h	/^inline void DrawQuad() { DrawQuad(0, 0, 1, 1); }$/;"	f	namespace:ax	signature:()
DrawQuad	.\model_gl.h	/^inline void DrawQuad(float size) {$/;"	f	namespace:ax	signature:(float size)
DrawQuad	.\model_gl.h	/^void DrawQuad(float x1, float y1, float x2, float y2);$/;"	p	namespace:ax	signature:(float x1, float y1, float x2, float y2)
DrawQuad	.\model_gl.h	/^void DrawQuad(float x1, float y1, float x2, float y2, float z);$/;"	p	namespace:ax	signature:(float x1, float y1, float x2, float y2, float z)
DrawQuad	.\model_gl.h	/^void DrawQuad(float x1, float y1, float z1,$/;"	p	namespace:ax	signature:(float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3)
DrawTextGL	.\utils.h	/^void DrawTextGL(int x, int y, const char *text);$/;"	p	namespace:ax	signature:(int x, int y, const char *text)
EatToEndKeyword	.\parser.cc	/^void EatToEndKeyword(FILE *fp, LineToken &token) {$/;"	f	namespace:ax	signature:(FILE *fp, LineToken &token)
EatToEndKeyword	.\parser.h	/^void EatToEndKeyword(FILE *fp, LineToken &token);$/;"	p	namespace:ax	signature:(FILE *fp, LineToken &token)
EmitVertex	.\utils.h	/^void EmitVertex(const T &p) { glVertex3f(p.x, p.y, p.z); }$/;"	f	namespace:ax	signature:(const T &p)
Enable	.\glmaterial.cc	/^void GLMaterial::Enable(ProgramGLSLPtr prog) const {$/;"	f	class:ax::GLMaterial	signature:(ProgramGLSLPtr prog) const
Enable	.\glmaterial.cc	/^void GLMaterial::Enable(const Scene *s) const{$/;"	f	class:ax::GLMaterial	signature:(const Scene *s) const
Enable	.\glmaterial.h	/^  virtual void Enable(ProgramGLSLPtr prog) const;  $/;"	p	class:ax::GLMaterial	access:public	signature:(ProgramGLSLPtr prog) const
Enable	.\glmaterial.h	/^  virtual void Enable(const Scene *s) const;$/;"	p	class:ax::GLMaterial	access:public	signature:(const Scene *s) const
Enable	.\glslmaterial.cc	/^void GLSLMaterial::Enable(ProgramGLSLPtr prog) const {  $/;"	f	class:ax::GLSLMaterial	signature:(ProgramGLSLPtr prog) const
Enable	.\glslmaterial.cc	/^void GLSLMaterial::Enable(const Scene *s) const {$/;"	f	class:ax::GLSLMaterial	signature:(const Scene *s) const
Enable	.\glslmaterial.h	/^  virtual void Enable(ProgramGLSLPtr prog) const;$/;"	p	class:ax::GLSLMaterial	access:public	signature:(ProgramGLSLPtr prog) const
Enable	.\glslmaterial.h	/^  virtual void Enable(const Scene *s) const;$/;"	p	class:ax::GLSLMaterial	access:public	signature:(const Scene *s) const
Enable	.\image_texture_gl.h	/^  void Enable() const;$/;"	p	class:ax::ImageTextureGL	access:public	signature:() const
Enable	.\material.h	/^  virtual void Enable(ProgramGLSLPtr prog) const { }$/;"	f	class:ax::Material	access:public	signature:(ProgramGLSLPtr prog) const
Enable	.\material.h	/^  virtual void Enable(const Scene *s) const { }$/;"	f	class:ax::Material	access:public	signature:(const Scene *s) const
Enable	.\texture_gl.h	/^  void Enable() const { glEnable(this->target()); }$/;"	f	class:ax::TextureGL	access:public	signature:() const
End	.\program_glsl.h	/^  void End() {$/;"	f	class:ax::ProgramGLSL	access:public	signature:()
End	.\utils.h	/^  double End() {$/;"	f	class:ax::GPUTimer	access:public	signature:()
End	.\utils.h	/^  double End(const std::string &info) {$/;"	f	class:ax::GPUTimer	access:public	signature:(const std::string &info)
EndDraw	.\glmesh.cc	/^void GLMesh::EndDraw(Options opts) const {$/;"	f	class:ax::GLMesh	signature:(Options opts) const
EndDraw	.\glmesh.h	/^  void EndDraw(Options opts) const;$/;"	p	class:ax::GLMesh	access:private	signature:(Options opts) const
EndInitialize	.\cube_texture_gl.h	/^  bool EndInitialize(void);$/;"	p	class:ax::CubeTextureGL	access:private	signature:(void)
Equals	.\parser.h	/^  bool Equals(const char *str) const {$/;"	f	class:ax::LineToken	access:public	signature:(const char *str) const
Equals	.\parser.h	/^  bool Equals(const std::string &str) const {$/;"	f	class:ax::LineToken	access:public	signature:(const std::string &str) const
Equals	.\parser.h	/^inline bool Equals(const char *s1, const char *s2) {$/;"	f	namespace:ax	signature:(const char *s1, const char *s2)
Expand	.\trimesh_glmmodel.cc	/^void TriMeshGLM::Expand(GLMmodelPtr model) {$/;"	f	class:ax::TriMeshGLM	signature:(GLMmodelPtr model)
Expand	.\trimesh_glmmodel.h	/^  void Expand(GLMmodelPtr model);$/;"	p	class:ax::TriMeshGLM	access:private	signature:(GLMmodelPtr model)
ExpandMesh	.\glmesh-loader.cc	/^size_t ExpandMesh(const GLMmodel *model, Point **vertices, Normal **normals, $/;"	f	namespace:ax	signature:(const GLMmodel *model, Point **vertices, Normal **normals, float **tcoords, uint32 **indices)
ExpandNormalAttrib	.\glmesh-loader.cc	/^size_t ExpandNormalAttrib(const GLMmodel *model, Point **vertices, $/;"	f	namespace:ax	signature:(const GLMmodel *model, Point **vertices, Normal **normals, uint32 **indices)
ExpandTexcoordAttrib	.\glmesh-loader.cc	/^size_t ExpandTexcoordAttrib(const GLMmodel *model, Point **vertices, $/;"	f	namespace:ax	signature:(const GLMmodel *model, Point **vertices, float **tcoords, uint32 **indices)
Extract	.\parser.h	/^  const char *Extract(const char *ptr) {$/;"	f	class:ax::LineToken	access:public	signature:(const char *ptr)
ExtractColorf	.\parser.h	/^inline Colorf ExtractColorf(const char *str) {  $/;"	f	namespace:ax	signature:(const char *str)
ExtractMatrix	.\object-factory.cc	/^glm::mat4 ExtractMatrix(const char *str) {$/;"	f	namespace:ax	signature:(const char *str)
ExtractVec3	.\parser.h	/^inline ax::Vector3 ExtractVec3(const char *str) {$/;"	f	namespace:ax	signature:(const char *str)
ExtractVec4	.\parser.h	/^inline ax::Vector4 ExtractVec4(const char *str) {$/;"	f	namespace:ax	signature:(const char *str)
FBODevicePtr	.\cg_fwd.h	/^typedef std::tr1::shared_ptr<RenderDeviceFBO> FBODevicePtr;$/;"	t	namespace:ax
FBParams	.\gl_buffer.h	/^struct FBParams {$/;"	s	namespace:ax
FindNextMacro	.\shader_object.cc	/^size_t FindNextMacro(const std::string &code, int s) {$/;"	f	namespace:ax	signature:(const std::string &code, int s)
FirstPersonMotion	.\camera.h	/^class FirstPersonMotion : public Motion {$/;"	c	namespace:ax	inherits:Motion
FixMissing	.\parser.h	/^void FixMissing(T v[], int n, int k) {$/;"	f	namespace:ax	signature:(T v[], int n, int k)
FloatVarMap	.\scene.h	/^typedef std::map<std::string, float> FloatVarMap;$/;"	t	namespace:ax
Fly	.\camera.cc	/^void FirstPersonMotion::Fly(float units) {$/;"	f	class:ax::FirstPersonMotion	signature:(float units)
Fly	.\camera.cc	/^void FlyMotion::Fly(float units) {$/;"	f	class:ax::FlyMotion	signature:(float units)
Fly	.\camera.h	/^  virtual void Fly(float units) = 0; \/\/ move up\/down$/;"	p	class:ax::Motion	access:public	signature:(float units)
Fly	.\camera.h	/^  virtual void Fly(float units) { }$/;"	f	class:ax::OrbitMotion	access:public	signature:(float units)
Fly	.\camera.h	/^  virtual void Fly(float units);$/;"	p	class:ax::FirstPersonMotion	access:public	signature:(float units)
Fly	.\camera.h	/^  virtual void Fly(float units);$/;"	p	class:ax::FlyMotion	access:public	signature:(float units)
Fly	.\camera.h	/^  virtual void Fly(float units);$/;"	p	class:ax::SpectatorMotion	access:public	signature:(float units)
FlyMotion	.\camera.h	/^  FlyMotion(const glm::vec3 &pos,  const glm::vec3 &target, $/;"	f	class:ax::FlyMotion	access:public	signature:(const glm::vec3 &pos, const glm::vec3 &target, const glm::vec3 &up = glm::vec3(0, 1, 0))
FlyMotion	.\camera.h	/^class FlyMotion : public Motion {$/;"	c	namespace:ax	inherits:Motion
FlyPerspectiveCameraGL	.\camera.h	/^typedef PerspectiveCameraGL<FlyMotion> FlyPerspectiveCameraGL;$/;"	t	namespace:ax
FlyPerspectiveCameraGL	.\cg_fwd.h	/^typedef PerspectiveCameraGL<FlyMotion> FlyPerspectiveCameraGL;$/;"	t	namespace:ax
FpsCounter	.\fps_counter.h	/^  FpsCounter(int average_type = kOverTime, float average_count = 1.0)$/;"	f	class:ax::FpsCounter	access:public	signature:(int average_type = kOverTime, float average_count = 1.0)
FpsCounter	.\fps_counter.h	/^class FpsCounter {$/;"	c	namespace:ax
FrameBuffer	.\gl_buffer.h	/^  FrameBuffer() : included_buffers_(0), n_color_buffers_(0), has_stencil_buffer_(false), has_zbuffer_(false) { }$/;"	f	class:ax::FrameBuffer	access:public	signature:()
FrameBuffer	.\gl_buffer.h	/^class FrameBuffer {$/;"	c	namespace:ax
FramebufferObject	.\framebuffer_object.cc	/^FramebufferObject::FramebufferObject()$/;"	f	class:ax::FramebufferObject	signature:()
FramebufferObject	.\framebuffer_object.h	/^  FramebufferObject();$/;"	p	class:ax::FramebufferObject	access:public	signature:()
FramebufferObject	.\framebuffer_object.h	/^class FramebufferObject {$/;"	c	namespace:ax
FramebufferTextureND	.\framebuffer_object.cc	/^void FramebufferObject::FramebufferTextureND(GLenum attachment, $/;"	f	class:ax::FramebufferObject	signature:(GLenum attachment, GLenum tex_target, GLuint tex_id, int mip_level, int zslice)
FramebufferTextureND	.\framebuffer_object.h	/^  void  FramebufferTextureND(GLenum attachment, GLenum tex_target, $/;"	p	class:ax::FramebufferObject	access:protected	signature:(GLenum attachment, GLenum tex_target, GLuint tex_id, int mip_level, int z_slice)
GLGroup	.\glmesh.h	/^  GLGroup(int tri_start, int n_tris) : $/;"	f	class:ax::GLGroup	access:private	signature:(int tri_start, int n_tris)
GLGroup	.\glmesh.h	/^class GLGroup : public Object {$/;"	c	namespace:ax	inherits:Object
GLGroupPtr	.\cg_fwd.h	/^typedef std::tr1::shared_ptr<GLGroup> GLGroupPtr;$/;"	t	namespace:ax
GLM_2_SIDED	.\glm_avl.h	38;"	d
GLM_AVL_H	.\glm_avl.h	2;"	d
GLM_BLENDING	.\glm_avl.h	/^static int GLM_BLENDING;   \/\/AVL Blending flag $/;"	v
GLM_COLOR	.\glm_avl.h	36;"	d
GLM_FLAT	.\glm_avl.h	33;"	d
GLM_MATERIAL	.\glm_avl.h	37;"	d
GLM_NONE	.\glm_avl.h	32;"	d
GLM_SMOOTH	.\glm_avl.h	34;"	d
GLM_TEXTURE	.\glm_avl.h	35;"	d
GLMaterial	.\glmaterial.cc	/^GLMaterial::GLMaterial(const Colorf &amb, const Colorf &dif, $/;"	f	class:ax::GLMaterial	signature:(const Colorf &amb, const Colorf &dif, const Colorf &spec, float shiny, const char *name)
GLMaterial	.\glmaterial.cc	/^GLMaterial::GLMaterial(const char *name) : Material(name),$/;"	f	class:ax::GLMaterial	signature:(const char *name)
GLMaterial	.\glmaterial.cc	/^GLMaterial::GLMaterial(float *amb, float *dif, float *spec, float shiny,$/;"	f	class:ax::GLMaterial	signature:(float *amb, float *dif, float *spec, float shiny, const char *name)
GLMaterial	.\glmaterial.cc	/^GLMaterial::GLMaterial(int predefined) : Material("") {$/;"	f	class:ax::GLMaterial	signature:(int predefined)
GLMaterial	.\glmaterial.h	/^  GLMaterial(const Colorf &amb, const Colorf &dif, const Colorf &spec, $/;"	p	class:ax::GLMaterial	access:protected	signature:(const Colorf &amb, const Colorf &dif, const Colorf &spec, float shiny, const char *name = s_unnamed)
GLMaterial	.\glmaterial.h	/^  GLMaterial(const char *name = s_unnamed);$/;"	p	class:ax::GLMaterial	access:protected	signature:(const char *name = s_unnamed)
GLMaterial	.\glmaterial.h	/^  GLMaterial(const float *Kd, const float *Ka, const float *Ks, $/;"	p	class:ax::GLMaterial	access:protected	signature:(const float *Kd, const float *Ka, const float *Ks, const float shininess)
GLMaterial	.\glmaterial.h	/^  GLMaterial(float *amb, float *dif, float *spec, float shiny,$/;"	p	class:ax::GLMaterial	access:protected	signature:(float *amb, float *dif, float *spec, float shiny, const char *name = s_unnamed)
GLMaterial	.\glmaterial.h	/^  GLMaterial(int predefined);$/;"	p	class:ax::GLMaterial	access:protected	signature:(int predefined)
GLMaterial	.\glmaterial.h	/^class GLMaterial : public Material {$/;"	c	namespace:ax	inherits:Material
GLMaterialPtr	.\cg_fwd.h	/^typedef std::tr1::shared_ptr<GLMaterial> GLMaterialPtr;$/;"	t	namespace:ax
GLMesh	.\glmesh.h	/^  GLMesh(ax::TriMeshPtr mesh) : mesh_(mesh), idx_buffer_(GL_ELEMENT_ARRAY_BUFFER), adj_idx_buffer_(GL_ELEMENT_ARRAY_BUFFER) { }$/;"	f	class:ax::GLMesh	access:private	signature:(ax::TriMeshPtr mesh)
GLMesh	.\glmesh.h	/^class GLMesh : public Object {$/;"	c	namespace:ax	inherits:Object
GLMeshPtr	.\cg_fwd.h	/^typedef std::tr1::shared_ptr<GLMesh> GLMeshPtr;$/;"	t	namespace:ax
GLMgroup	.\glm_avl.h	/^} GLMgroup;$/;"	t	typeref:struct:_GLMgroup
GLMmaterial	.\glm_avl.h	/^} GLMmaterial;$/;"	t	typeref:struct:_GLMmaterial
GLMmodel	.\glm_avl.h	/^} GLMmodel;$/;"	t	typeref:struct:_GLMmodel
GLMmodelPtr	.\trimesh_glmmodel.h	/^typedef std::tr1::shared_ptr<GLMmodel> GLMmodelPtr;$/;"	t	namespace:ax
GLMnode	.\glm_avl.cpp	/^} GLMnode;$/;"	t	typeref:struct:_GLMnode	file:
GLMtriangle	.\glm_avl.h	/^} GLMtriangle;$/;"	t	typeref:struct:_GLMtriangle
GLObject	.\gl_object.h	/^  GLObject(const std::string &name) : name_(name), id_(0) { }$/;"	f	class:ax::GLObject	access:protected	signature:(const std::string &name)
GLObject	.\gl_object.h	/^class GLObject {$/;"	c	namespace:ax
GLSLMaterial	.\glslmaterial.h	/^  GLSLMaterial() { }$/;"	f	class:ax::GLSLMaterial	access:protected	signature:()
GLSLMaterial	.\glslmaterial.h	/^class GLSLMaterial : public Material {$/;"	c	namespace:ax	inherits:Material
GLSLMaterialPtr	.\cg_fwd.h	/^typedef std::tr1::shared_ptr<GLSLMaterial> GLSLMaterialPtr;$/;"	t	namespace:ax
GPUTimer	.\utils.h	/^  GPUTimer(const std::string &name) : GLObject(name) {$/;"	f	class:ax::GPUTimer	access:protected	signature:(const std::string &name)
GPUTimer	.\utils.h	/^class GPUTimer : public ax::GLObject {$/;"	c	namespace:ax	inherits:ax::GLObject
GPUTimerPtr	.\utils.h	/^typedef std::tr1::shared_ptr<GPUTimer> GPUTimerPtr;$/;"	t	namespace:ax
GenAdjacency	.\trimesh_glmmodel.cc	/^void TriMeshGLM::GenAdjacency(GLMmodelPtr model) {  $/;"	f	class:ax::TriMeshGLM	signature:(GLMmodelPtr model)
GenAdjacency	.\trimesh_glmmodel.h	/^  void GenAdjacency(GLMmodelPtr model);$/;"	p	class:ax::TriMeshGLM	access:private	signature:(GLMmodelPtr model)
GenerateFboId	.\framebuffer_object.cc	/^GLuint FramebufferObject::GenerateFboId() {$/;"	f	class:ax::FramebufferObject	signature:()
GenerateFboId	.\framebuffer_object.h	/^  static GLuint GenerateFboId();$/;"	p	class:ax::FramebufferObject	access:protected	signature:()
GenerateMipmap	.\image_texture_gl.h	/^  void GenerateMipmap();$/;"	p	class:ax::ImageTextureGL	access:public	signature:()
GenerateMipmap	.\texture_gl.h	/^  void GenerateMipmap() { $/;"	f	class:ax::Texture2D	access:public	signature:()
GeometryShaderSettings	.\program_glsl.cc	/^void ProgramGLSL::GeometryShaderSettings(GLenum input_type, $/;"	f	class:ax::ProgramGLSL	signature:(GLenum input_type, int max_emitted_verts, GLenum output_type)
GeometryShaderSettings	.\program_glsl.h	/^  void GeometryShaderSettings(GLenum input_type, int max_emitted_verts, $/;"	p	class:ax::ProgramGLSL	access:public	signature:(GLenum input_type, int max_emitted_verts, GLenum output_type)
GetAttachedCubeFace	.\framebuffer_object.cc	/^GLint FramebufferObject::GetAttachedCubeFace(GLenum attachment) {$/;"	f	class:ax::FramebufferObject	signature:(GLenum attachment)
GetAttachedCubeFace	.\framebuffer_object.h	/^  GLint  GetAttachedCubeFace(GLenum attachment);$/;"	p	class:ax::FramebufferObject	access:public	signature:(GLenum attachment)
GetAttachedId	.\framebuffer_object.cc	/^GLuint FramebufferObject::GetAttachedId(GLenum attachment) {$/;"	f	class:ax::FramebufferObject	signature:(GLenum attachment)
GetAttachedId	.\framebuffer_object.h	/^  GLuint GetAttachedId(GLenum attachment);$/;"	p	class:ax::FramebufferObject	access:public	signature:(GLenum attachment)
GetAttachedMipLevel	.\framebuffer_object.cc	/^GLint FramebufferObject::GetAttachedMipLevel(GLenum attachment) {$/;"	f	class:ax::FramebufferObject	signature:(GLenum attachment)
GetAttachedMipLevel	.\framebuffer_object.h	/^  GLint  GetAttachedMipLevel(GLenum attachment);$/;"	p	class:ax::FramebufferObject	access:public	signature:(GLenum attachment)
GetAttachedType	.\framebuffer_object.cc	/^GLenum FramebufferObject::GetAttachedType(GLenum attachment) {$/;"	f	class:ax::FramebufferObject	signature:(GLenum attachment)
GetAttachedType	.\framebuffer_object.h	/^  GLenum GetAttachedType(GLenum attachment);$/;"	p	class:ax::FramebufferObject	access:public	signature:(GLenum attachment)
GetAttachedZSlice	.\framebuffer_object.cc	/^GLint FramebufferObject::GetAttachedZSlice(GLenum attachment) {$/;"	f	class:ax::FramebufferObject	signature:(GLenum attachment)
GetAttachedZSlice	.\framebuffer_object.h	/^  GLint  GetAttachedZSlice(GLenum attachment);$/;"	p	class:ax::FramebufferObject	access:public	signature:(GLenum attachment)
GetGPUPtr	.\gl_buffer.cc	/^GLuint64 GetGPUPtr(uint32 id, uint32 access, uint32 target) {$/;"	f	namespace:ax	signature:(uint32 id, uint32 access, uint32 target)
GetGPUPtr	.\gl_buffer.h	/^GLuint64 GetGPUPtr(uint32 id, uint32 access, uint32 target=GL_ARRAY_BUFFER);$/;"	p	namespace:ax	signature:(uint32 id, uint32 access, uint32 target=GL_ARRAY_BUFFER)
GetMaxColorAttachments	.\framebuffer_object.cc	/^GLint FramebufferObject::GetMaxColorAttachments() {$/;"	f	class:ax::FramebufferObject	signature:()
GetMaxColorAttachments	.\framebuffer_object.h	/^  static int GetMaxColorAttachments();$/;"	p	class:ax::FramebufferObject	access:public	signature:()
GetNormalIdx	.\glmesh-loader.cc	/^inline size_t GetNormalIdx(const GLMmodel *model, size_t tri, size_t vidx) {$/;"	f	namespace:ax	signature:(const GLMmodel *model, size_t tri, size_t vidx)
GetPtr	.\params.h	/^  PTR GetPtr(const KeyType &key) const { return (PTR)this->GetRawPtr(key); }$/;"	f	struct:ax::__ParamSet2	access:public	signature:(const KeyType &key) const
GetTexcoordIdx	.\glmesh-loader.cc	/^inline size_t GetTexcoordIdx(const GLMmodel *model, size_t tri, size_t vidx) {$/;"	f	namespace:ax	signature:(const GLMmodel *model, size_t tri, size_t vidx)
GetTextureImage	.\texture_gl.cc	/^ImagePtr Texture2D::GetTextureImage(int level, int format,  int type, $/;"	f	class:ax::Texture2D	signature:(int level, int format, int type, int n_channels, int depth) const
GetTextureImage	.\texture_gl.h	/^  ImagePtr GetTextureImage(int level, int format=GL_RGBA, $/;"	p	class:ax::Texture2D	access:public	signature:(int level, int format=GL_RGBA, int type=GL_UNSIGNED_BYTE, int n_channels=4, int depth=1) const
GetUniformVar	.\program_glsl.h	/^  int GetUniformVar(const char *name) const {$/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *name) const
GetVertexIdx	.\glmesh-loader.cc	/^inline size_t GetVertexIdx(const GLMmodel *model, size_t tri, size_t vidx) {$/;"	f	namespace:ax	signature:(const GLMmodel *model, size_t tri, size_t vidx)
GrabDepthBuffer	.\gl_buffer.h	/^  ax::Texture2DPtr GrabDepthBuffer();$/;"	p	class:ax::FrameBuffer	access:public	signature:()
GrabStencilBuffer	.\gl_buffer.cc	/^ax::Texture2DPtr FrameBuffer::GrabStencilBuffer() {$/;"	f	class:ax::FrameBuffer	signature:()
GrabStencilBuffer	.\gl_buffer.h	/^  ax::Texture2DPtr GrabStencilBuffer();$/;"	p	class:ax::FrameBuffer	access:public	signature:()
Group	.\group.h	/^  Group() { }$/;"	f	class:ax::Group	access:protected	signature:()
Group	.\group.h	/^class Group : public Object {$/;"	c	namespace:ax	inherits:Object
GroupPtr	.\cg_fwd.h	/^typedef std::tr1::shared_ptr<Group> GroupPtr;$/;"	t	namespace:ax
GuardedBind	.\framebuffer_object.cc	/^void FramebufferObject::GuardedBind() {$/;"	f	class:ax::FramebufferObject	signature:()
GuardedBind	.\framebuffer_object.h	/^  void  GuardedBind();$/;"	p	class:ax::FramebufferObject	access:protected	signature:()
GuardedUnbind	.\framebuffer_object.cc	/^void FramebufferObject::GuardedUnbind() {$/;"	f	class:ax::FramebufferObject	signature:()
GuardedUnbind	.\framebuffer_object.h	/^  void  GuardedUnbind();$/;"	p	class:ax::FramebufferObject	access:protected	signature:()
HasTexture	.\glslmaterial.cc	/^bool GLSLMaterial::HasTexture() const {$/;"	f	class:ax::GLSLMaterial	signature:() const
HasTexture	.\glslmaterial.h	/^  virtual bool HasTexture() const;$/;"	p	class:ax::GLSLMaterial	access:public	signature:() const
HasTexture	.\material.h	/^  virtual bool HasTexture() const { return false; }$/;"	f	class:ax::Material	access:public	signature:() const
Idxs	.\glmesh-loader.cc	/^typedef List<size_t> Idxs;$/;"	t	namespace:ax	file:
Image	.\image.h	/^  Image() : width_(0), height_(0), format_(0), type_(0), data_(0) { }$/;"	f	class:ax::Image	access:public	signature:()
Image	.\image.h	/^  Image(int w, int h, int format, int type, char *data) $/;"	f	class:ax::Image	access:private	signature:(int w, int h, int format, int type, char *data)
Image	.\image.h	/^class Image {$/;"	c	namespace:ax
ImagePtr	.\cg_fwd.h	/^typedef std::tr1::shared_ptr<Image> ImagePtr;$/;"	t	namespace:ax
ImageTextureGL	.\image_texture_gl.h	/^  ImageTextureGL();$/;"	p	class:ax::ImageTextureGL	access:public	signature:()
ImageTextureGL	.\image_texture_gl.h	/^  ImageTextureGL(uint32 target);$/;"	p	class:ax::ImageTextureGL	access:public	signature:(uint32 target)
ImageTextureGL	.\image_texture_gl.h	/^class ImageTextureGL {$/;"	c	namespace:ax
ImageTextureGLOptions	.\image_texture_gl.h	/^enum ImageTextureGLOptions {$/;"	g	namespace:ax
ImageUnit	.\texture_gl.h	/^  int ImageUnit() const { $/;"	f	class:ax::TextureGL	access:public	signature:() const
Initiaialze	.\gl_utils.cc	/^bool TextureUtil::Initiaialze() {$/;"	f	class:ax::TextureUtil	signature:()
Initiaialze	.\utils.h	/^  static bool Initiaialze();$/;"	p	class:ax::TextureUtil	access:private	signature:()
Initialize	.\cube_texture_gl.h	/^  bool Initialize(Image *images[6], GLuint internal_format);$/;"	p	class:ax::CubeTextureGL	access:public	signature:(Image *images[6], GLuint internal_format)
Initialize	.\cube_texture_gl.h	/^  bool Initialize(const CubeImage &image, GLint internal_format);$/;"	p	class:ax::CubeTextureGL	access:public	signature:(const CubeImage &image, GLint internal_format)
Initialize	.\cube_texture_gl.h	/^  bool Initialize(int width, int height, GLint internal_format);$/;"	p	class:ax::CubeTextureGL	access:public	signature:(int width, int height, GLint internal_format)
Initialize	.\gl_buffer.cc	/^bool FrameBuffer::Initialize(const ax::ParamSet &params) {$/;"	f	class:ax::FrameBuffer	signature:(const ax::ParamSet &params)
Initialize	.\gl_buffer.cc	/^bool MultiResolutionBuffer::Initialize(const ax::ParamSet &params) {$/;"	f	class:ax::MultiResolutionBuffer	signature:(const ax::ParamSet &params)
Initialize	.\gl_buffer.h	/^  bool Initialize(const ax::ParamSet &params);$/;"	p	class:ax::FrameBuffer	access:public	signature:(const ax::ParamSet &params)
Initialize	.\gl_buffer.h	/^  bool Initialize(const ax::ParamSet &params);$/;"	p	class:ax::MultiResolutionBuffer	access:public	signature:(const ax::ParamSet &params)
Initialize	.\image_texture_gl.h	/^  bool Initialize(const Image &image, uint32 internal_format,$/;"	p	class:ax::ImageTextureGL	access:public	signature:(const Image &image, uint32 internal_format, int opts = kUseDefaultParameters)
Initialize	.\image_texture_gl.h	/^  bool Initialize(int width, int height, uint32 internal_format, $/;"	p	class:ax::ImageTextureGL	access:public	signature:(int width, int height, uint32 internal_format, int opts = kUseDefaultParameters, void *data = NULL)
Initialize	.\model_gl.cc	/^bool MyScreenQuad::Initialize() {$/;"	f	class:ax::MyScreenQuad	signature:()
Initialize	.\texture_gl.cc	/^bool CubeTexture::Initialize(const CubeImage &image, int i_format) {$/;"	f	class:ax::CubeTexture	signature:(const CubeImage &image, int i_format)
Initialize	.\texture_gl.cc	/^bool CubeTexture::Initialize(const Image *images[6], int i_format) {$/;"	f	class:ax::CubeTexture	signature:(const Image *images[6], int i_format)
Initialize	.\texture_gl.cc	/^bool CubeTexture::Initialize(int w, int h, int i_format) {$/;"	f	class:ax::CubeTexture	signature:(int w, int h, int i_format)
Initialize	.\texture_gl.cc	/^bool Texture2D::Initialize(const Image &image, int i_format) {$/;"	f	class:ax::Texture2D	signature:(const Image &image, int i_format)
Initialize	.\texture_gl.cc	/^bool Texture2D::Initialize(int w, int h, int i_format) {$/;"	f	class:ax::Texture2D	signature:(int w, int h, int i_format)
Initialize	.\texture_gl.cc	/^bool Texture3D::Initialize(int w, int h, int z, int i_format) {$/;"	f	class:ax::Texture3D	signature:(int w, int h, int z, int i_format)
Initialize	.\texture_gl.h	/^  bool Initialize(const CubeImage &image, int i_format);$/;"	p	class:ax::CubeTexture	access:public	signature:(const CubeImage &image, int i_format)
Initialize	.\texture_gl.h	/^  bool Initialize(const Image &image, int i_format);$/;"	p	class:ax::Texture2D	access:public	signature:(const Image &image, int i_format)
Initialize	.\texture_gl.h	/^  bool Initialize(const Image *images[6], int i_format);$/;"	p	class:ax::CubeTexture	access:public	signature:(const Image *images[6], int i_format)
Initialize	.\texture_gl.h	/^  bool Initialize(int w, int h, int i_format);$/;"	p	class:ax::CubeTexture	access:public	signature:(int w, int h, int i_format)
Initialize	.\texture_gl.h	/^  bool Initialize(int w, int h, int i_format);$/;"	p	class:ax::Texture2D	access:public	signature:(int w, int h, int i_format)
Initialize	.\texture_gl.h	/^  bool Initialize(int w, int h, int z, int i_format);$/;"	p	class:ax::Texture3D	access:public	signature:(int w, int h, int z, int i_format)
Initialize	.\utils.h	/^  virtual bool Initialize(const ax::ParamSet2 &params) = 0;$/;"	p	class:ax::RenderAppI	access:private	signature:(const ax::ParamSet2 &params)
InitializeDepth	.\texture_gl.cc	/^bool Texture2D::InitializeDepth(int w, int h, int i_format) {$/;"	f	class:ax::Texture2D	signature:(int w, int h, int i_format)
InitializeDepth	.\texture_gl.h	/^  bool InitializeDepth(int w, int h, int i_format);$/;"	p	class:ax::Texture2D	access:public	signature:(int w, int h, int i_format)
IntVarMap	.\scene.h	/^typedef std::map<std::string, int> IntVarMap;$/;"	t	namespace:ax
InvalidVar	.\program_glsl.h	/^inline bool InvalidVar(const int var) { return var < 0; }$/;"	f	namespace:ax	signature:(const int var)
IsBlankOrComment	.\parser.h	/^inline bool IsBlankOrComment(const char *str) { $/;"	f	namespace:ax	signature:(const char *str)
IsEmpty	.\cg_fwd.h	/^  bool IsEmpty() const { return opts_ == kNone; }  $/;"	f	class:ax::Options	access:public	signature:() const
IsValid	.\framebuffer_object.h	/^  bool IsValid() { return CheckBufferStatus(); }$/;"	f	class:ax::FramebufferObject	access:public	signature:()
IsValid	.\program_glsl.h	/^  bool IsValid() const { return 0 != id_ && is_linked_; }$/;"	f	class:ax::ProgramGLSL	access:public	signature:() const
IsVarValid	.\program_glsl.h	/^  bool IsVarValid(GLint var, const char *name = "") const {$/;"	f	class:ax::ProgramGLSL	access:private	signature:(GLint var, const char *name = Ó) const
KeyType	.\params.h	/^  typedef T KeyType;$/;"	t	struct:ax::__ParamSet	access:public
KeyType	.\params.h	/^  typedef typename __ParamSet<T>::KeyType KeyType;$/;"	t	struct:ax::__ParamSet2	access:public
LineToken	.\parser.h	/^  LineToken() { token_[0] = '\\0'; }$/;"	f	class:ax::LineToken	access:public	signature:()
LineToken	.\parser.h	/^class LineToken {$/;"	c	namespace:ax
Link	.\program_glsl.h	/^  bool Link() {$/;"	f	class:ax::ProgramGLSL	access:public	signature:()
Load	.\cube_image.cc	/^bool CubeImage::Load(const char *filename) {$/;"	f	class:ax::CubeImage	signature:(const char *filename)
Load	.\cube_image.h	/^  bool Load(const char *filename);$/;"	p	class:ax::CubeImage	access:public	signature:(const char *filename)
Load	.\image.cc	/^bool Image::Load(const char *filename) {  $/;"	f	class:ax::Image	signature:(const char *filename)
Load	.\image.h	/^  bool Load(const char *filename);$/;"	p	class:ax::Image	access:public	signature:(const char *filename)
Load	.\program_glsl.cc	/^bool ProgramGLSL::Load(const char *vertex_shader, const char *fragment_shader, const MacroList &macros) {$/;"	f	class:ax::ProgramGLSL	signature:(const char *vertex_shader, const char *fragment_shader, const MacroList &macros)
Load	.\program_glsl.h	/^  bool Load(const char *vertex_shader, const char *fragment_shader, const MacroList &macros = MacroList());$/;"	p	class:ax::ProgramGLSL	access:public	signature:(const char *vertex_shader, const char *fragment_shader, const MacroList &macros = MacroList())
Load	.\scene.cc	/^bool Scene::Load(const std::string &filename) {$/;"	f	class:ax::Scene	signature:(const std::string &filename)
Load	.\scene.h	/^  bool Load(const std::string &filename);$/;"	p	class:ax::NamedVariables	access:public	signature:(const std::string &filename)
Load	.\scene.h	/^  bool Load(const std::string &filename);$/;"	p	class:ax::Scene	access:private	signature:(const std::string &filename)
Load	.\shader_object.cc	/^bool ShaderObject::Load(int type, const char *file, const MacroList &macros) {$/;"	f	class:ax::ShaderObject	signature:(int type, const char *file, const MacroList &macros)
Load	.\shader_object.h	/^  bool Load(int type, const char *file, const MacroList &macros = MacroList());$/;"	p	class:ax::ShaderObject	access:private	signature:(int type, const char *file, const MacroList &macros = MacroList())
LoadCode	.\shader_object.cc	/^bool ShaderObject::LoadCode(int type, const char *code) {$/;"	f	class:ax::ShaderObject	signature:(int type, const char *code)
LoadCode	.\shader_object.h	/^  bool LoadCode(int type, const char *code);$/;"	p	class:ax::ShaderObject	access:private	signature:(int type, const char *code)
LoadFromGLMmodel	.\trimesh_glmmodel.cc	/^void TriMeshGLM::LoadFromGLMmodel(GLMmodelPtr model, ax::Options opts) {$/;"	f	class:ax::TriMeshGLM	signature:(GLMmodelPtr model, ax::Options opts)
LoadFromGLMmodel	.\trimesh_glmmodel.h	/^  void LoadFromGLMmodel(GLMmodelPtr model, ax::Options opts);$/;"	p	class:ax::TriMeshGLM	access:private	signature:(GLMmodelPtr model, ax::Options opts)
LoadGLMesh	.\glmesh-loader.cc	/^ObjectPtr LoadGLMesh(Scene *s, const std::string &filename, Options opts) {$/;"	f	namespace:ax	signature:(Scene *s, const std::string &filename, Options opts)
LoadGLMesh	.\glmesh.h	/^ObjectPtr LoadGLMesh(Scene *s, const std::string &filename, Options opts);$/;"	p	namespace:ax	signature:(Scene *s, const std::string &filename, Options opts)
LoadMaterial	.\object-factory.cc	/^MaterialPtr ObjectFactory::LoadMaterial(const char *ptr, Scene *s, FILE *fp) {$/;"	f	class:ax::ObjectFactory	signature:(const char *ptr, Scene *s, FILE *fp)
LoadMaterial	.\object-factory.h	/^  static MaterialPtr LoadMaterial(const char *ptr, Scene *s, FILE *fp);$/;"	p	class:ax::ObjectFactory	access:private	signature:(const char *ptr, Scene *s, FILE *fp)
LoadMaterial	.\scene.cc	/^MaterialPtr Scene::LoadMaterial(const char *buff, FILE *fp) {$/;"	f	class:ax::Scene	signature:(const char *buff, FILE *fp)
LoadMaterial	.\scene.h	/^  MaterialPtr LoadMaterial(const char *type, FILE *fp);$/;"	p	class:ax::Scene	access:private	signature:(const char *type, FILE *fp)
LoadObject	.\scene.cc	/^ObjectPtr Scene::LoadObject(const char *buff, FILE *fp) {$/;"	f	class:ax::Scene	signature:(const char *buff, FILE *fp)
LoadObject	.\scene.h	/^  ObjectPtr LoadObject(const char *type, FILE *fp);$/;"	p	class:ax::Scene	access:private	signature:(const char *type, FILE *fp)
LoadTexture	.\scene.cc	/^Texture2DPtr Scene::LoadTexture(const char *buff) {$/;"	f	class:ax::Scene	signature:(const char *buff)
LoadTexture	.\scene.h	/^  Texture2DPtr LoadTexture(const char *ptr);$/;"	p	class:ax::Scene	access:private	signature:(const char *ptr)
LoadToVBO	.\glmesh.cc	/^void GLMesh::LoadToVBO(Options opts) {$/;"	f	class:ax::GLMesh	signature:(Options opts)
LoadToVBO	.\glmesh.h	/^  void LoadToVBO(Options opts);  $/;"	p	class:ax::GLMesh	access:private	signature:(Options opts)
LoadWavefront	.\object-factory.cc	/^ObjectPtr ObjectFactory::LoadWavefront(FILE *fp, Scene *s, Options opts) {$/;"	f	class:ax::ObjectFactory	signature:(FILE *fp, Scene *s, Options opts)
LoadWavefront	.\object-factory.h	/^  static ObjectPtr LoadWavefront(FILE *fp, Scene *s, Options opts);$/;"	p	class:ax::ObjectFactory	access:public	signature:(FILE *fp, Scene *s, Options opts)
M_PI	.\glm_avl.h	29;"	d
MacroList	.\shader_object.h	/^typedef std::hash_map<std::string, std::string> MacroList;$/;"	t	namespace:ax
MakeFullScreenQuad	.\model_gl.cc	/^GLuint MakeFullScreenQuad() {$/;"	f	namespace:ax	signature:()
MakeFullScreenQuad	.\utils.h	/^GLuint MakeFullScreenQuad();$/;"	p	namespace:ax	signature:()
MapBuffer	.\gl_buffer.h	/^  T *MapBuffer(uint32 access = GL_READ_ONLY) {$/;"	f	class:ax::ArrayBufferGL	access:public	signature:(uint32 access = GL_READ_ONLY)
MapBuffer_	.\gl_buffer.cc	/^void *ArrayBufferGL::MapBuffer_(uint32 access) {$/;"	f	class:ax::ArrayBufferGL	signature:(uint32 access)
MapBuffer_	.\gl_buffer.h	/^  void *MapBuffer_(uint32 access);$/;"	p	class:ax::ArrayBufferGL	access:private	signature:(uint32 access)
MapCudaPtr	.\gl_buffer.h	/^  T *MapCudaPtr() {$/;"	f	class:ax::CudaArrayBufferGL	access:public	signature:()
Material	.\material.h	/^  Material() : name_(s_unnamed) { }$/;"	f	class:ax::Material	access:protected	signature:()
Material	.\material.h	/^  Material(const char *name) : name_(name) { }$/;"	f	class:ax::Material	access:protected	signature:(const char *name)
Material	.\material.h	/^class Material {$/;"	c	namespace:ax
MaterialFactory	.\material-factory.h	/^class MaterialFactory {$/;"	c	namespace:ax
MaterialMap	.\scene.h	/^typedef std::map<std::string, ax::MaterialPtr> MaterialMap;$/;"	t	namespace:ax
MaterialPtr	.\cg_fwd.h	/^typedef std::tr1::shared_ptr<Material> MaterialPtr;$/;"	t	namespace:ax
MipmapLevel	.\gl_buffer.h	/^  int MipmapLevel(int resolution) const {$/;"	f	class:ax::MultiResolutionBuffer	access:public	signature:(int resolution) const
MipmapWidth	.\gl_buffer.h	/^  int MipmapWidth(int level) const { return this->widths_[level]; }$/;"	f	class:ax::MultiResolutionBuffer	access:public	signature:(int level) const
MipmapXOffset	.\gl_buffer.h	/^  int MipmapXOffset(int level) const { return this->offsets_[level]; }$/;"	f	class:ax::MultiResolutionBuffer	access:public	signature:(int level) const
Motion	.\camera.h	/^  Motion(const glm::vec3 &pos, const glm::vec3 &target, const glm::vec3 &up)$/;"	f	class:ax::Motion	access:public	signature:(const glm::vec3 &pos, const glm::vec3 &target, const glm::vec3 &up)
Motion	.\camera.h	/^class Motion {$/;"	c	namespace:ax
MultiResolutionBuffer	.\gl_buffer.h	/^class MultiResolutionBuffer : public FrameBuffer {$/;"	c	namespace:ax	inherits:FrameBuffer
NPOD_PARAM	.\params.h	35;"	d
NamedVariables	.\scene.h	/^class NamedVariables {$/;"	c	namespace:ax
NextTextureSlot	.\program_glsl.h	/^  int NextTextureSlot() {$/;"	f	class:ax::ProgramGLSL	access:private	signature:()
Object	.\globject.h	/^  Object() : transform_applied_(false), matl_(Material::kNullMatl) { }$/;"	f	class:ax::Object	access:protected	signature:()
Object	.\globject.h	/^class Object {$/;"	c	namespace:ax
ObjectFactory	.\object-factory.h	/^class ObjectFactory {$/;"	c	namespace:ax
ObjectList	.\glmesh.h	/^  typedef std::vector<GLGroupPtr> ObjectList;$/;"	t	class:ax::GLMesh	access:private
ObjectList	.\group.h	/^  typedef std::vector<ObjectPtr> ObjectList;$/;"	t	class:ax::Group	access:private
ObjectMap	.\scene.h	/^typedef std::map<std::string, ax::ObjectPtr> ObjectMap;$/;"	t	namespace:ax
ObjectPtr	.\cg_fwd.h	/^typedef std::tr1::shared_ptr<Object> ObjectPtr;$/;"	t	namespace:ax
Options	.\cg_fwd.h	/^  Options() : opts_(0) { }$/;"	f	class:ax::Options	access:public	signature:()
Options	.\cg_fwd.h	/^  Options(int opts) : opts_(opts) { }$/;"	f	class:ax::Options	access:public	signature:(int opts)
Options	.\cg_fwd.h	/^class Options {$/;"	c	namespace:ax
OrbitMotion	.\camera.h	/^  OrbitMotion(const glm::vec3 &pos, $/;"	f	class:ax::OrbitMotion	access:public	signature:(const glm::vec3 &pos, const glm::vec3 &target = glm::vec3(0, 0, 0), const glm::vec3 &up = glm::vec3(0, 1, 0))
OrbitMotion	.\camera.h	/^class OrbitMotion : public Motion {$/;"	c	namespace:ax	inherits:Motion
OrbitPerspectiveCameraGL	.\camera.h	/^typedef PerspectiveCameraGL<OrbitMotion> OrbitPerspectiveCameraGL;$/;"	t	namespace:ax
OrbitPerspectiveCameraGL	.\cg_fwd.h	/^typedef PerspectiveCameraGL<OrbitMotion> OrbitPerspectiveCameraGL;$/;"	t	namespace:ax
OrbitPerspectiveCameraGLPtr	.\cg_fwd.h	/^OrbitPerspectiveCameraGLPtr;$/;"	t	namespace:ax
OrthoCameraGL	.\camera.h	/^  OrthoCameraGL(float left, float right, float bottom, float up, float near, float far);$/;"	p	class:ax::OrthoCameraGL	access:public	signature:(float left, float right, float bottom, float up, float near, float far)
OrthoCameraGL	.\camera.h	/^class OrthoCameraGL : public MotionType {$/;"	c	namespace:ax	inherits:MotionType
PARAM	.\params.h	10;"	d
POD_PARAM	.\params.h	34;"	d
ParamSet	.\params.h	/^typedef __ParamSet<CGParamKeyType> ParamSet;$/;"	t	namespace:ax
ParamSet2	.\params.h	/^typedef __ParamSet2<CGParamKeyType> ParamSet2;$/;"	t	namespace:ax
ParseNumber	.\parser.h	/^inline float ParseNumber(const char *str, float def=1.0f) {$/;"	f	namespace:ax	signature:(const char *str, float def=1.0f)
PerspectiveCameraGL	.\camera.h	/^  PerspectiveCameraGL(const glm::vec3 &pos = glm::vec3(0, 0, 1),$/;"	f	class:ax::PerspectiveCameraGL	access:public	signature:(const glm::vec3 &pos = glm::vec3(0, 0, 1), const glm::vec3 &target = glm::vec3(0, 0, 0), const glm::vec3 &up = glm::vec3(0, 1, 0))
PerspectiveCameraGL	.\camera.h	/^class PerspectiveCameraGL : public MotionType {$/;"	c	namespace:ax	inherits:MotionType
Pitch	.\camera.cc	/^void FirstPersonMotion::Pitch(float angle) {$/;"	f	class:ax::FirstPersonMotion	signature:(float angle)
Pitch	.\camera.cc	/^void FlyMotion::Pitch(float angle) {$/;"	f	class:ax::FlyMotion	signature:(float angle)
Pitch	.\camera.cc	/^void OrbitMotion::Pitch(float angle) {$/;"	f	class:ax::OrbitMotion	signature:(float angle)
Pitch	.\camera.h	/^  virtual void Pitch(float angle) = 0; \/\/ rotate on right vector$/;"	p	class:ax::Motion	access:public	signature:(float angle)
Pitch	.\camera.h	/^  virtual void Pitch(float angle);$/;"	p	class:ax::FirstPersonMotion	access:public	signature:(float angle)
Pitch	.\camera.h	/^  virtual void Pitch(float angle);$/;"	p	class:ax::FlyMotion	access:public	signature:(float angle)
Pitch	.\camera.h	/^  virtual void Pitch(float angle);$/;"	p	class:ax::OrbitMotion	access:public	signature:(float angle)
PreProcess	.\glmesh.cc	/^void GLMesh::PreProcess(Options opts) {$/;"	f	class:ax::GLMesh	signature:(Options opts)
PreProcess	.\glmesh.h	/^  virtual void PreProcess(Options opts) { }  $/;"	f	class:ax::GLGroup	access:private	signature:(Options opts)
PreProcess	.\glmesh.h	/^  virtual void PreProcess(Options opts);$/;"	p	class:ax::GLMesh	access:public	signature:(Options opts)
PreProcess	.\globject.h	/^  virtual void PreProcess(Options opts) = 0;$/;"	p	class:ax::Object	access:public	signature:(Options opts)
PreProcess	.\group.cc	/^void Group::PreProcess(Options opts) {$/;"	f	class:ax::Group	signature:(Options opts)
PreProcess	.\group.h	/^  virtual void PreProcess(Options opts);$/;"	p	class:ax::Group	access:public	signature:(Options opts)
PreProcess	.\scene.cc	/^void Scene::PreProcess() {$/;"	f	class:ax::Scene	signature:()
PreProcess	.\scene.h	/^  void PreProcess();$/;"	p	class:ax::Scene	access:private	signature:()
PrintCompileLog	.\shader_object.cc	/^void ShaderObject::PrintCompileLog() {$/;"	f	class:ax::ShaderObject	signature:()
PrintCompileLog	.\shader_object.h	/^  void PrintCompileLog(); $/;"	p	class:ax::ShaderObject	access:private	signature:()
PrintLinkLog	.\program_glsl.cc	/^void ProgramGLSL::PrintLinkLog() const {$/;"	f	class:ax::ProgramGLSL	signature:() const
PrintLinkLog	.\program_glsl.h	/^  void PrintLinkLog() const;$/;"	p	class:ax::ProgramGLSL	access:private	signature:() const
ProgramGLSL	.\program_glsl.h	/^  ProgramGLSL(const std::string &name) : $/;"	f	class:ax::ProgramGLSL	access:private	signature:(const std::string &name)
ProgramGLSL	.\program_glsl.h	/^class ProgramGLSL : public GLObject {$/;"	c	namespace:ax	inherits:GLObject
ProgramGLSLPtr	.\cg_fwd.h	/^typedef std::tr1::shared_ptr<ProgramGLSL> ProgramGLSLPtr;$/;"	t	namespace:ax
ProjMatrix	.\camera.h	/^  glm::mat4 ProjMatrix() const {$/;"	f	class:ax::PerspectiveCameraGL	access:public	signature:() const
Quad2DGL	.\model_gl.h	/^  Quad2DGL(const Point &p1, const Point &p2) {$/;"	f	class:ax::Quad2DGL	access:public	signature:(const Point &p1, const Point &p2)
Quad2DGL	.\model_gl.h	/^  Quad2DGL(const float x1, const float y1, const float x2, const float y2) {$/;"	f	class:ax::Quad2DGL	access:public	signature:(const float x1, const float y1, const float x2, const float y2)
Quad2DGL	.\model_gl.h	/^class Quad2DGL {$/;"	c	namespace:ax
Quad3DGL	.\model_gl.h	/^  Quad3DGL(const Point &p1, const Point &p2, const Normal &n);$/;"	p	class:ax::Quad3DGL	access:public	signature:(const Point &p1, const Point &p2, const Normal &n)
Quad3DGL	.\model_gl.h	/^  Quad3DGL(const float x1, const float y1, const float z1,$/;"	p	class:ax::Quad3DGL	access:public	signature:(const float x1, const float y1, const float z1, const float x2, const float y2, const float z2, const float nx, const float ny, const float nz)
Quad3DGL	.\model_gl.h	/^class Quad3DGL {$/;"	c	namespace:ax
ReadSahderFile	.\shader_object.cc	/^std::string ReadSahderFile(const char *file) {$/;"	f	namespace:ax	signature:(const char *file)
ReduceMinMax	.\gl_utils.cc	/^void TextureUtil::ReduceMinMax(ax::ImagePtr img, float *ret) {$/;"	f	class:ax::TextureUtil	signature:(ax::ImagePtr img, float *ret)
ReduceMinMax	.\gl_utils.cc	/^void TextureUtil::ReduceMinMax(ax::Texture2DPtr tex, float *ret) {$/;"	f	class:ax::TextureUtil	signature:(ax::Texture2DPtr tex, float *ret)
ReduceMinMax	.\utils.h	/^  static void ReduceMinMax(ax::ImagePtr img, float *ret);  $/;"	p	class:ax::TextureUtil	access:public	signature:(ax::ImagePtr img, float *ret)
ReduceMinMax	.\utils.h	/^  static void ReduceMinMax(ax::Texture2DPtr tex, float *ret);$/;"	p	class:ax::TextureUtil	access:public	signature:(ax::Texture2DPtr tex, float *ret)
Register	.\gl_buffer.h	/^  void Register() {$/;"	f	class:ax::CudaArrayBufferGL	access:public	signature:()
Release	.\camera.h	/^  void Release() { is_captured_ = false; }$/;"	f	class:ax::TrackableI	access:public	signature:()
Release	.\cube_texture_gl.h	/^  void Release(void);$/;"	p	class:ax::CubeTextureGL	access:private	signature:(void)
Release	.\gl_buffer.cc	/^void ArrayBufferGL::Release() {$/;"	f	class:ax::ArrayBufferGL	signature:()
Release	.\gl_buffer.h	/^  void Release();  $/;"	p	class:ax::ArrayBufferGL	access:private	signature:()
Release	.\image.h	/^  void Release() {$/;"	f	class:ax::Image	access:private	signature:()
Release	.\image_texture_gl.h	/^  void Release();$/;"	p	class:ax::ImageTextureGL	access:private	signature:()
Render	.\utils.h	/^  virtual void Render(const ax::ScenePtr scene, const ax::ParamSet2 &params) = 0;  $/;"	p	class:ax::RenderAppI	access:public	signature:(const ax::ScenePtr scene, const ax::ParamSet2 &params)
RenderAppI	.\utils.h	/^  RenderAppI(const std::string &name) : name_(name), width_(0), height_(0) { }$/;"	f	class:ax::RenderAppI	access:public	signature:(const std::string &name)
RenderAppI	.\utils.h	/^class RenderAppI {$/;"	c	namespace:ax
RenderAppPtr	.\utils.h	/^typedef std::tr1::shared_ptr<RenderAppI> RenderAppPtr;$/;"	t	namespace:ax
RenderBuffer	.\render_buffer.cc	/^RenderBuffer::RenderBuffer(int width, int height, GLint internal_format) $/;"	f	class:ax::RenderBuffer	signature:(int width, int height, GLint internal_format)
RenderBuffer	.\render_buffer.h	/^  RenderBuffer(int width, int height, GLint internal_format);$/;"	p	class:ax::RenderBuffer	access:public	signature:(int width, int height, GLint internal_format)
RenderBuffer	.\render_buffer.h	/^class RenderBuffer {$/;"	c	namespace:ax
RenderDeviceFBO	.\render_device_fbo.h	/^  RenderDeviceFBO() { }$/;"	f	class:ax::RenderDeviceFBO	access:private	signature:()
RenderDeviceFBO	.\render_device_fbo.h	/^class RenderDeviceFBO {$/;"	c	namespace:ax
RenderFullScreen	.\gl_buffer.cc	/^void MultiResolutionBuffer::RenderFullScreen($/;"	f	class:ax::MultiResolutionBuffer	signature:( ax::ProgramGLSLPtr shader, int mipmap_level)
RenderFullScreen	.\gl_buffer.cc	/^void MultiResolutionBuffer::RenderFullScreen(ax::ProgramGLSLPtr shader) {$/;"	f	class:ax::MultiResolutionBuffer	signature:(ax::ProgramGLSLPtr shader)
RenderFullScreen	.\gl_buffer.h	/^  void RenderFullScreen(ax::ProgramGLSLPtr shader);$/;"	p	class:ax::MultiResolutionBuffer	access:public	signature:(ax::ProgramGLSLPtr shader)
RenderFullScreen	.\gl_buffer.h	/^  void RenderFullScreen(ax::ProgramGLSLPtr shader, int mipmap_level);$/;"	p	class:ax::MultiResolutionBuffer	access:public	signature:(ax::ProgramGLSLPtr shader, int mipmap_level)
ResetTextureSlot	.\program_glsl.h	/^  void ResetTextureSlot() {$/;"	f	class:ax::ProgramGLSL	access:private	signature:()
Resize	.\gl_buffer.cc	/^bool ArrayBufferGL::Resize(uint32 size, const void *data, bool force_shrink) {$/;"	f	class:ax::ArrayBufferGL	signature:(uint32 size, const void *data, bool force_shrink)
Resize	.\gl_buffer.cc	/^bool FrameBuffer::Resize(int w, int h) { $/;"	f	class:ax::FrameBuffer	signature:(int w, int h)
Resize	.\gl_buffer.cc	/^bool MultiResolutionBuffer::Resize(int w, int h) {$/;"	f	class:ax::MultiResolutionBuffer	signature:(int w, int h)
Resize	.\gl_buffer.h	/^  bool Resize(int w, int h);$/;"	p	class:ax::FrameBuffer	access:public	signature:(int w, int h)
Resize	.\gl_buffer.h	/^  bool Resize(int w, int h);$/;"	p	class:ax::MultiResolutionBuffer	access:public	signature:(int w, int h)
Resize	.\gl_buffer.h	/^  virtual bool Resize(uint32 size, const void *data=NULL, bool force_shrink=false) {$/;"	f	class:ax::CudaArrayBufferGL	access:public	signature:(uint32 size, const void *data=NULL, bool force_shrink=false)
Resize	.\gl_buffer.h	/^  virtual bool Resize(uint32 size, const void *data=NULL, bool force_shrink=false);$/;"	p	class:ax::ArrayBufferGL	access:public	signature:(uint32 size, const void *data=NULL, bool force_shrink=false)
Resize	.\utils.h	/^  virtual void Resize(int w, int h) { this->width_ = w, this->height_ = h; }$/;"	f	class:ax::RenderAppI	access:public	signature:(int w, int h)
ResizeWindow	.\camera.h	/^  void ResizeWindow(int w, int h) { w_ = w; h_ = h; }$/;"	f	class:ax::TrackableI	access:public	signature:(int w, int h)
RestoreMVP	.\render_device_fbo.cc	/^void RenderDeviceFBO::RestoreMVP() {$/;"	f	class:ax::RenderDeviceFBO	signature:()
RestoreMVP	.\render_device_fbo.h	/^  void RestoreMVP();$/;"	p	class:ax::RenderDeviceFBO	access:public	signature:()
Roll	.\camera.cc	/^void FirstPersonMotion::Roll(float angle) {$/;"	f	class:ax::FirstPersonMotion	signature:(float angle)
Roll	.\camera.cc	/^void FlyMotion::Roll(float angle) {  Motion::roll_(angle);  }$/;"	f	class:ax::FlyMotion	signature:(float angle)
Roll	.\camera.cc	/^void OrbitMotion::Roll(float angle) {$/;"	f	class:ax::OrbitMotion	signature:(float angle)
Roll	.\camera.h	/^  virtual void Roll(float angle) = 0; \/\/ rotate on look vector$/;"	p	class:ax::Motion	access:public	signature:(float angle)
Roll	.\camera.h	/^  virtual void Roll(float angle);$/;"	p	class:ax::FirstPersonMotion	access:public	signature:(float angle)
Roll	.\camera.h	/^  virtual void Roll(float angle);$/;"	p	class:ax::FlyMotion	access:public	signature:(float angle)
Roll	.\camera.h	/^  virtual void Roll(float angle);$/;"	p	class:ax::OrbitMotion	access:public	signature:(float angle)
Save	.\image_texture_gl.h	/^  void Save(const char* filename, const int level = 0) const;$/;"	p	class:ax::ImageTextureGL	access:public	signature:(const char* filename, const int level = 0) const
Save	.\texture_gl.cc	/^void Texture2D::Save(const char *filename, int level) const {$/;"	f	class:ax::Texture2D	signature:(const char *filename, int level) const
Save	.\texture_gl.cc	/^void Texture3D::Save(const char *filename, int z, int level) const {$/;"	f	class:ax::Texture3D	signature:(const char *filename, int z, int level) const
Save	.\texture_gl.h	/^  void Save(const char *filename, int level = 0) const;$/;"	p	class:ax::Texture2D	access:public	signature:(const char *filename, int level = 0) const
Save	.\texture_gl.h	/^  void Save(const char *filename, int level, int format, int type,$/;"	p	class:ax::Texture2D	access:public	signature:(const char *filename, int level, int format, int type, void *data) const
Save	.\texture_gl.h	/^  void Save(const char *filename, int z, int level = 0) const;   $/;"	p	class:ax::Texture3D	access:public	signature:(const char *filename, int z, int level = 0) const
SaveFrameBuffer	.\gl_utils.cc	/^void SaveFrameBuffer(const char *filename) {$/;"	f	namespace:ax	signature:(const char *filename)
SaveFrameBuffer	.\utils.h	/^void SaveFrameBuffer(const char *filename);$/;"	p	namespace:ax	signature:(const char *filename)
SaveImage	.\image.cc	/^void SaveImage(const char *filename, const int w, const int h,$/;"	f	namespace:ax	signature:(const char *filename, const int w, const int h, uint32 depth, uint8 n_channels, uint32 format, uint32 type, const void *data)
SaveImage	.\image.h	/^void SaveImage(const char *filename, const int w, const int h,$/;"	p	namespace:ax	signature:(const char *filename, const int w, const int h, uint32 depth, uint8 n_channels, uint32 format, uint32 type, const void *data)
SaveMVP	.\render_device_fbo.cc	/^void RenderDeviceFBO::SaveMVP() {$/;"	f	class:ax::RenderDeviceFBO	signature:()
SaveMVP	.\render_device_fbo.h	/^  void SaveMVP();$/;"	p	class:ax::RenderDeviceFBO	access:public	signature:()
Scene	.\scene.h	/^  Scene(ax::Options opts) : opts_(opts) { }$/;"	f	class:ax::Scene	access:private	signature:(ax::Options opts)
Scene	.\scene.h	/^class Scene {$/;"	c	namespace:ax
ScenePtr	.\cg_fwd.h	/^typedef std::tr1::shared_ptr<Scene> ScenePtr;$/;"	t	namespace:ax
ScopeGPUTimer	.\utils.h	/^  ScopeGPUTimer(const std::string &name) : GPUTimer(name) { $/;"	f	class:ax::ScopeGPUTimer	access:public	signature:(const std::string &name)
ScopeGPUTimer	.\utils.h	/^class ScopeGPUTimer : private GPUTimer {$/;"	c	namespace:ax	inherits:GPUTimer
ScopeStatistics	.\utils.h	/^  ScopeStatistics(const std::string &name, ax::Options opts) : name_(name), opts_(opts) {$/;"	f	class:ax::ScopeStatistics	access:public	signature:(const std::string &name, ax::Options opts)
ScopeStatistics	.\utils.h	/^class ScopeStatistics {$/;"	c	namespace:ax
ScreenQuad	.\model_gl.cc	/^ScreenQuad::ScreenQuad() : Quad2DGL(0, 0, 1, 1) {$/;"	f	class:ax::ScreenQuad	signature:()
ScreenQuad	.\model_gl.h	/^  ScreenQuad();$/;"	p	class:ax::ScreenQuad	access:private	signature:()
ScreenQuad	.\model_gl.h	/^class ScreenQuad : public Quad2DGL {$/;"	c	namespace:ax	inherits:Quad2DGL
ScreenQuadPtr	.\cg_fwd.h	/^typedef std::tr1::shared_ptr<ScreenQuad> ScreenQuadPtr;$/;"	t	namespace:ax
ScreenQuadPtr	.\model_gl.h	/^typedef std::tr1::shared_ptr<ScreenQuad> ScreenQuadPtr;$/;"	t	namespace:ax
Set	.\texture_gl.h	/^  void Set(int w, int h, int iformat) {$/;"	f	class:ax::TextureGL	access:protected	signature:(int w, int h, int iformat)
Set1DVar	.\program_glsl.h	/^  void Set1DVar(const char *name, const GLuint64EXT *vals, int n = 1) const {$/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *name, const GLuint64EXT *vals, int n = 1) const
Set1DVar	.\program_glsl.h	/^  void Set1DVar(const char *name, const float *vals, int n = 1) const {$/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *name, const float *vals, int n = 1) const
Set1DVar	.\program_glsl.h	/^  void Set1DVar(const char *name, const int *vals, int n = 1) const {$/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *name, const int *vals, int n = 1) const
Set2DVar	.\program_glsl.h	/^  void Set2DVar(const char *name, const float *vals, int n = 1) const {$/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *name, const float *vals, int n = 1) const
Set2DVar	.\program_glsl.h	/^  void Set2DVar(const char *name, const int *vals, int n = 1) const {$/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *name, const int *vals, int n = 1) const
Set3DMatVar	.\program_glsl.h	/^  void Set3DMatVar(const char *name, const MAT3D &m,$/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *name, const MAT3D &m, int transpose = GL_FALSE) const
Set3DMatVar	.\program_glsl.h	/^  void Set3DMatVar(const char *name, const float *vals, int n = 1,$/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *name, const float *vals, int n = 1, int transpose = GL_FALSE) const
Set3DVar	.\program_glsl.h	/^  void Set3DVar(const char *name, const VEC3D &vec) {$/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *name, const VEC3D &vec)
Set3DVar	.\program_glsl.h	/^  void Set3DVar(const char *name, const float *vals, int n = 1) const {$/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *name, const float *vals, int n = 1) const
Set3DVar	.\program_glsl.h	/^  void Set3DVar(const char *name, const int *vals, int n = 1) const {$/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *name, const int *vals, int n = 1) const
Set4DMatVar	.\program_glsl.h	/^  void Set4DMatVar(const char *name, const MAT4D &m,$/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *name, const MAT4D &m, int transpose = GL_FALSE) const
Set4DMatVar	.\program_glsl.h	/^  void Set4DMatVar(const char *name, const float *vals, int n = 1, $/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *name, const float *vals, int n = 1, int transpose = GL_FALSE) const
Set4DVar	.\program_glsl.h	/^  void Set4DVar(const char *name, const float *vals, int n = 1) const {$/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *name, const float *vals, int n = 1) const
Set4DVar	.\program_glsl.h	/^  void Set4DVar(const char *name, const int *vals, int n = 1) const {$/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *name, const int *vals, int n = 1) const
SetArrayVar	.\program_glsl.h	/^  void SetArrayVar(const char *name, int n, const T *vals, F f) const {$/;"	f	class:ax::ProgramGLSL	access:private	signature:(const char *name, int n, const T *vals, F f) const
SetData	.\gl_buffer.cc	/^uint32 ArrayBufferGL::SetData(int offset, int size, const void *data) {$/;"	f	class:ax::ArrayBufferGL	signature:(int offset, int size, const void *data)
SetData	.\gl_buffer.h	/^  uint32 SetData(int offset, int size, const void *data);$/;"	p	class:ax::ArrayBufferGL	access:public	signature:(int offset, int size, const void *data)
SetDefaultParameters	.\cube_texture_gl.h	/^  void SetDefaultParameters(void);$/;"	p	class:ax::CubeTextureGL	access:private	signature:(void)
SetDefaultParameters	.\image_texture_gl.h	/^  void SetDefaultParameters();$/;"	p	class:ax::ImageTextureGL	access:public	signature:()
SetDefaultParameters	.\texture_gl.cc	/^void TextureGL::SetDefaultParameters() {$/;"	f	class:ax::TextureGL	signature:()
SetDefaultParameters	.\texture_gl.h	/^  void SetDefaultParameters();$/;"	p	class:ax::TextureGL	access:public	signature:()
SetDepthBuffer	.\render_device_fbo.cc	/^void RenderDeviceFBO::SetDepthBuffer(const RenderBuffer *render_buffer) {$/;"	f	class:ax::RenderDeviceFBO	signature:(const RenderBuffer *render_buffer)
SetDepthBuffer	.\render_device_fbo.cc	/^void RenderDeviceFBO::SetDepthBuffer(const Texture2DPtr texture) {$/;"	f	class:ax::RenderDeviceFBO	signature:(const Texture2DPtr texture)
SetDepthBuffer	.\render_device_fbo.h	/^  void SetDepthBuffer(const RenderBuffer *render_buffer);$/;"	p	class:ax::RenderDeviceFBO	access:public	signature:(const RenderBuffer *render_buffer)
SetDepthBuffer	.\render_device_fbo.h	/^  void SetDepthBuffer(const Texture2DPtr texture);$/;"	p	class:ax::RenderDeviceFBO	access:public	signature:(const Texture2DPtr texture)
SetMatArrayVar	.\program_glsl.h	/^  void SetMatArrayVar(const char *name, int n, int transpose, $/;"	f	class:ax::ProgramGLSL	access:private	signature:(const char *name, int n, int transpose, const T *vals, F f) const
SetParameter	.\image_texture_gl.h	/^  void SetParameter(uint32 name, float *val);$/;"	p	class:ax::ImageTextureGL	access:public	signature:(uint32 name, float *val)
SetParameter	.\image_texture_gl.h	/^  void SetParameter(uint32 name, float val);$/;"	p	class:ax::ImageTextureGL	access:public	signature:(uint32 name, float val)
SetParameter	.\image_texture_gl.h	/^  void SetParameter(uint32 name, int32 *val);$/;"	p	class:ax::ImageTextureGL	access:public	signature:(uint32 name, int32 *val)
SetParameter	.\image_texture_gl.h	/^  void SetParameter(uint32 name, int32 val);$/;"	p	class:ax::ImageTextureGL	access:public	signature:(uint32 name, int32 val)
SetParameter	.\texture_gl.h	/^  void SetParameter(uint32 name, float *val) {$/;"	f	class:ax::TextureGL	access:public	signature:(uint32 name, float *val)
SetParameter	.\texture_gl.h	/^  void SetParameter(uint32 name, float val) {$/;"	f	class:ax::TextureGL	access:public	signature:(uint32 name, float val)
SetParameter	.\texture_gl.h	/^  void SetParameter(uint32 name, int32 *val) {$/;"	f	class:ax::TextureGL	access:public	signature:(uint32 name, int32 *val)
SetParameter	.\texture_gl.h	/^  void SetParameter(uint32 name, int32 val) {$/;"	f	class:ax::TextureGL	access:public	signature:(uint32 name, int32 val)
SetParameteri	.\program_glsl.h	/^  void SetParameteri(uint32 name, int param) {$/;"	f	class:ax::ProgramGLSL	access:public	signature:(uint32 name, int param)
SetPosition	.\camera.h	/^  void SetPosition(const glm::vec3 &p) { set_position(p); update_(); }$/;"	f	class:ax::Motion	access:public	signature:(const glm::vec3 &p)
SetPosition	.\camera.h	/^  void SetPosition(float x, float y, float z) {  SetPosition(glm::vec3(x, y, z)); }$/;"	f	class:ax::Motion	access:public	signature:(float x, float y, float z)
SetPtr	.\params.h	/^  void SetPtr(const KeyType &key, PTR ptr) { this->SetRawPtr(key, (const void*)ptr); }$/;"	f	struct:ax::__ParamSet2	access:public	signature:(const KeyType &key, PTR ptr)
SetRenderTarget	.\render_device_fbo.cc	/^void RenderDeviceFBO::SetRenderTarget(const RenderBuffer *render_buffer) {$/;"	f	class:ax::RenderDeviceFBO	signature:(const RenderBuffer *render_buffer)
SetRenderTarget	.\render_device_fbo.cc	/^void RenderDeviceFBO::SetRenderTarget(const Texture2DPtr texture, int level) {$/;"	f	class:ax::RenderDeviceFBO	signature:(const Texture2DPtr texture, int level)
SetRenderTarget	.\render_device_fbo.h	/^  void SetRenderTarget(const RenderBuffer *render_buffer);$/;"	p	class:ax::RenderDeviceFBO	access:public	signature:(const RenderBuffer *render_buffer)
SetRenderTarget	.\render_device_fbo.h	/^  void SetRenderTarget(const Texture2DPtr texture, int level = 0);$/;"	p	class:ax::RenderDeviceFBO	access:public	signature:(const Texture2DPtr texture, int level = 0)
SetRenderTargets	.\render_device_fbo.cc	/^void RenderDeviceFBO::SetRenderTargets($/;"	f	class:ax::RenderDeviceFBO	signature:( int target_count, const RenderBuffer *const render_buffers[])
SetRenderTargets	.\render_device_fbo.cc	/^void RenderDeviceFBO::SetRenderTargets(const std::vector<Texture2DPtr> &textures, int level) {$/;"	f	class:ax::RenderDeviceFBO	signature:(const std::vector<Texture2DPtr> &textures, int level)
SetRenderTargets	.\render_device_fbo.h	/^  void SetRenderTargets(const std::vector<Texture2DPtr> &textures, int level = 0);$/;"	p	class:ax::RenderDeviceFBO	access:public	signature:(const std::vector<Texture2DPtr> &textures, int level = 0)
SetRenderTargets	.\render_device_fbo.h	/^  void SetRenderTargets(int target_counts, $/;"	p	class:ax::RenderDeviceFBO	access:public	signature:(int target_counts, const RenderBuffer *const render_buffers[])
SetScalarVar	.\program_glsl.h	/^  void SetScalarVar(const char *name, T val, F f) const {$/;"	f	class:ax::ProgramGLSL	access:private	signature:(const char *name, T val, F f) const
SetStencilBuffer	.\render_device_fbo.cc	/^void RenderDeviceFBO::SetStencilBuffer(const Texture2DPtr texture) {$/;"	f	class:ax::RenderDeviceFBO	signature:(const Texture2DPtr texture)
SetStencilBuffer	.\render_device_fbo.h	/^  void SetStencilBuffer(const Texture2DPtr texture);$/;"	p	class:ax::RenderDeviceFBO	access:public	signature:(const Texture2DPtr texture)
SetSubroutineVar	.\program_glsl.cc	/^void ProgramGLSL::SetSubroutineVar(const std::string &var_name, $/;"	f	class:ax::ProgramGLSL	signature:(const std::string &var_name, const std::string &routine_name, int shader_type)
SetSubroutineVar	.\program_glsl.h	/^  void SetSubroutineVar(const std::string &var_name, $/;"	p	class:ax::ProgramGLSL	access:public	signature:(const std::string &var_name, const std::string &routine_name, int shader_type)
SetTarget	.\camera.h	/^  void SetTarget(const glm::vec3 &p) {  set_target(p); update_(); }$/;"	f	class:ax::Motion	access:public	signature:(const glm::vec3 &p)
SetTarget	.\camera.h	/^  void SetTarget(float x, float y, float z) { SetTarget(glm::vec3(x, y, z)); }$/;"	f	class:ax::Motion	access:public	signature:(float x, float y, float z)
SetTextureVar	.\program_glsl.cc	/^void ProgramGLSL::SetTextureVar(const char *name, $/;"	f	class:ax::ProgramGLSL	signature:(const char *name, const Texture2DPtr &tex)
SetTextureVar	.\program_glsl.cc	/^void ProgramGLSL::SetTextureVar(const char *name, const Texture2DPtr *texs,$/;"	f	class:ax::ProgramGLSL	signature:(const char *name, const Texture2DPtr *texs, size_t n)
SetTextureVar	.\program_glsl.h	/^  void SetTextureVar(const char *name) {$/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *name)
SetTextureVar	.\program_glsl.h	/^  void SetTextureVar(const char *name, const Texture2DPtr &tex);$/;"	p	class:ax::ProgramGLSL	access:public	signature:(const char *name, const Texture2DPtr &tex)
SetTextureVar	.\program_glsl.h	/^  void SetTextureVar(const char *name, const Texture2DPtr *texs, size_t n);$/;"	p	class:ax::ProgramGLSL	access:public	signature:(const char *name, const Texture2DPtr *texs, size_t n)
SetTextureVar	.\program_glsl.h	/^  void SetTextureVar(const char *name, const std::vector<Texture2DPtr> &texs) {$/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *name, const std::vector<Texture2DPtr> &texs)
SetTextureVars	.\program_glsl.h	/^  void SetTextureVars(const char *names[], $/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *names[], const std::vector<Texture2DPtr> &texs)
SetTextureVars	.\program_glsl.h	/^  void SetTextureVars(const char *names[], const Texture2DPtr *texs, $/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *names[], const Texture2DPtr *texs, size_t n)
SetUp	.\camera.h	/^  void SetUp(const glm::vec3 &v) { $/;"	f	class:ax::Motion	access:public	signature:(const glm::vec3 &v)
SetUp	.\camera.h	/^  void SetUp(float x, float y, float z) { SetUp(glm::vec3(x, y, z)); }$/;"	f	class:ax::Motion	access:public	signature:(float x, float y, float z)
SetVar	.\program_glsl.h	/^  void SetVar(const char *name, GLuint64EXT val) const {$/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *name, GLuint64EXT val) const
SetVar	.\program_glsl.h	/^  void SetVar(const char *name, T val) const {$/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *name, T val) const
SetVar	.\program_glsl.h	/^  void SetVar(const char *name, float val) const {$/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *name, float val) const
ShaderObject	.\shader_object.h	/^  ShaderObject(const std::string name = "") : GLObject(name) { };$/;"	f	class:ax::ShaderObject	access:private	signature:(const std::string name = Ó)
ShaderObject	.\shader_object.h	/^class ShaderObject : public GLObject {$/;"	c	namespace:ax	inherits:GLObject
ShaderPtr	.\cg_fwd.h	/^typedef std::tr1::shared_ptr<ShaderObject> ShaderPtr;$/;"	t	namespace:ax
SpectatorMotion	.\camera.h	/^class SpectatorMotion : public Motion {$/;"	c	namespace:ax	inherits:Motion
StatisticsOption	.\utils.h	/^enum StatisticsOption {$/;"	g	namespace:ax
Strafe	.\camera.cc	/^void FirstPersonMotion::Strafe(float units) {$/;"	f	class:ax::FirstPersonMotion	signature:(float units)
Strafe	.\camera.cc	/^void FlyMotion::Strafe(float units) {$/;"	f	class:ax::FlyMotion	signature:(float units)
Strafe	.\camera.h	/^  virtual void Strafe(float units) = 0; \/\/ move left\/right$/;"	p	class:ax::Motion	access:public	signature:(float units)
Strafe	.\camera.h	/^  virtual void Strafe(float units) { }$/;"	f	class:ax::OrbitMotion	access:public	signature:(float units)
Strafe	.\camera.h	/^  virtual void Strafe(float units);$/;"	p	class:ax::FirstPersonMotion	access:public	signature:(float units)
Strafe	.\camera.h	/^  virtual void Strafe(float units);$/;"	p	class:ax::FlyMotion	access:public	signature:(float units)
Strafe	.\camera.h	/^  virtual void Strafe(float units);$/;"	p	class:ax::SpectatorMotion	access:public	signature:(float units)
StripLeading	.\parser.cc	/^const char *StripLeading(const char *str) {  $/;"	f	namespace:ax	signature:(const char *str)
StripLeading	.\parser.h	/^const char *StripLeading(const char *str);$/;"	p	namespace:ax	signature:(const char *str)
StripToken	.\parser.cc	/^const char *StripToken(const char *ptr, char *token) {$/;"	f	namespace:ax	signature:(const char *ptr, char *token)
StripToken	.\parser.h	/^const char *StripToken(const char *ptr, char *token);$/;"	p	namespace:ax	signature:(const char *ptr, char *token)
T	.\glm_avl.cpp	24;"	d	file:
Texture2D	.\texture_gl.h	/^  Texture2D(uint32 target, const std::string &name) : $/;"	f	class:ax::Texture2D	access:private	signature:(uint32 target, const std::string &name)
Texture2D	.\texture_gl.h	/^class Texture2D : public TextureGL {$/;"	c	namespace:ax	inherits:TextureGL
Texture2DPtr	.\cg_fwd.h	/^typedef std::tr1::shared_ptr<Texture2D> Texture2DPtr;$/;"	t	namespace:ax
Texture3D	.\texture_gl.h	/^  Texture3D(int target, const std::string &name) $/;"	f	class:ax::Texture3D	access:private	signature:(int target, const std::string &name)
Texture3D	.\texture_gl.h	/^class Texture3D : public TextureGL {$/;"	c	namespace:ax	inherits:TextureGL
Texture3DPtr	.\cg_fwd.h	/^typedef std::tr1::shared_ptr<Texture3D> Texture3DPtr;$/;"	t	namespace:ax
TextureCopier	.\utils.h	/^class TextureCopier {$/;"	c	namespace:ax
TextureGL	.\texture_gl.h	/^  TextureGL(uint32 target, const std::string &name) $/;"	f	class:ax::TextureGL	access:public	signature:(uint32 target, const std::string &name)
TextureGL	.\texture_gl.h	/^class TextureGL : public GLObject {$/;"	c	namespace:ax	inherits:GLObject
TextureMap	.\scene.h	/^typedef std::map<std::string, ax::Texture2DPtr> TextureMap;$/;"	t	namespace:ax
TextureUtil	.\utils.h	/^  TextureUtil() { }$/;"	f	class:ax::TextureUtil	access:public	signature:()
TextureUtil	.\utils.h	/^class TextureUtil {$/;"	c	namespace:ax
ToLower	.\parser.cc	/^void ToLower(char *str) {$/;"	f	namespace:ax	signature:(char *str)
ToLower	.\parser.h	/^void ToLower(char *str);$/;"	p	namespace:ax	signature:(char *str)
TrackableI	.\camera.h	/^  TrackableI() : is_captured_(false), w_(1), h_(1), scale_(1.f) { }$/;"	f	class:ax::TrackableI	access:public	signature:()
TrackableI	.\camera.h	/^class TrackableI {$/;"	c	namespace:ax
Transform	.\globject.h	/^  void Transform(const ax::Matrix4x4 &m = ax::Matrix4x4(1.f)) {$/;"	f	class:ax::Object	access:public	signature:(const ax::Matrix4x4 &m = ax::Matrix4x4(1.f))
TriMeshGLM	.\trimesh_glmmodel.h	/^  TriMeshGLM() { }$/;"	f	class:ax::TriMeshGLM	access:private	signature:()
TriMeshGLM	.\trimesh_glmmodel.h	/^class TriMeshGLM : public ax::TriangleMesh {$/;"	c	namespace:ax	inherits:ax::TriangleMesh
TriVertAttribIdx	.\glmesh-loader.cc	/^typedef size_t TriVertAttribIdx(const GLMmodel *model, size_t tri, size_t vidx);$/;"	t	namespace:ax	file:
Unattach	.\framebuffer_object.cc	/^void FramebufferObject::Unattach(GLenum attachment) {$/;"	f	class:ax::FramebufferObject	signature:(GLenum attachment)
Unattach	.\framebuffer_object.h	/^  void Unattach(GLenum attachment);$/;"	p	class:ax::FramebufferObject	access:public	signature:(GLenum attachment)
UnattachAll	.\framebuffer_object.cc	/^void FramebufferObject::UnattachAll() {$/;"	f	class:ax::FramebufferObject	signature:()
UnattachAll	.\framebuffer_object.h	/^  void UnattachAll();$/;"	p	class:ax::FramebufferObject	access:public	signature:()
UnattachAllColorAttachement	.\framebuffer_object.cc	/^void FramebufferObject::UnattachAllColorAttachement() {$/;"	f	class:ax::FramebufferObject	signature:()
UnattachAllColorAttachement	.\framebuffer_object.h	/^  void UnattachAllColorAttachement();$/;"	p	class:ax::FramebufferObject	access:public	signature:()
Unbind	.\cube_texture_gl.h	/^  void Unbind(void) const;$/;"	p	class:ax::CubeTextureGL	access:public	signature:(void) const
Unbind	.\gl_buffer.h	/^  void Unbind() const { glBindBuffer(this->target_, 0); }  $/;"	f	class:ax::ArrayBufferGL	access:public	signature:() const
Unbind	.\gl_buffer.h	/^  void Unbind() { this->device_->Deactivate(); }$/;"	f	class:ax::FrameBuffer	access:public	signature:()
Unbind	.\image_texture_gl.h	/^  void Unbind() const;$/;"	p	class:ax::ImageTextureGL	access:public	signature:() const
Unbind	.\texture_gl.h	/^  void Unbind() const { glBindTexture(this->target(), 0); }$/;"	f	class:ax::TextureGL	access:public	signature:() const
UnitIdManager	.\texture_gl.h	/^class UnitIdManager {$/;"	c	namespace:ax
Unknown	.\parser.h	/^inline void Unknown(const char *type, const char *type_name, $/;"	f	namespace:ax	signature:(const char *type, const char *type_name, const char *obj_type)
UnknownCommand	.\parser.h	/^inline void UnknownCommand(const char *cmd, const char *obj_type) {$/;"	f	namespace:ax	signature:(const char *cmd, const char *obj_type)
UnknownKeyword	.\parser.h	/^inline void UnknownKeyword(const char *keyword, const char *obj_type) {$/;"	f	namespace:ax	signature:(const char *keyword, const char *obj_type)
UnmapCudaPtr	.\gl_buffer.h	/^  void UnmapCudaPtr() {$/;"	f	class:ax::CudaArrayBufferGL	access:public	signature:()
Unregister	.\gl_buffer.h	/^  void Unregister() {$/;"	f	class:ax::CudaArrayBufferGL	access:public	signature:()
Unsupported	.\parser.h	/^inline void Unsupported(const char *obj_type, const char *obj) {$/;"	f	namespace:ax	signature:(const char *obj_type, const char *obj)
UpdataPosition	.\camera.cc	/^void OrbitMotion::UpdataPosition() {$/;"	f	class:ax::OrbitMotion	signature:()
UpdataPosition	.\camera.h	/^  void UpdataPosition();$/;"	p	class:ax::OrbitMotion	access:private	signature:()
Update	.\camera.h	/^  bool Update(int x, int y) {$/;"	f	class:ax::TrackableI	access:public	signature:(int x, int y)
Update	.\fps_counter.h	/^  double Update() {$/;"	f	class:ax::FpsCounter	access:public	signature:()
UpdateObject	.\camera.h	/^  virtual void UpdateObject(float x, float y) = 0;$/;"	p	class:ax::TrackableI	access:private	signature:(float x, float y)
UpdateObject	.\camera.h	/^  void UpdateObject(float deltax, float deltay) {$/;"	f	class:ax::CameraPan	access:private	signature:(float deltax, float deltay)
UpdateObject	.\camera.h	/^  void UpdateObject(float deltax, float deltay) {$/;"	f	class:ax::CameraRot	access:private	signature:(float deltax, float deltay)
VOffset	.\glmesh-loader.cc	/^size_t VOffset(const Idxs &nidxs, size_t nidx) {$/;"	f	namespace:ax	signature:(const Idxs &nidxs, size_t nidx)
VarNames	.\glslmaterial.h	/^  typedef std::vector<std::string> VarNames;$/;"	t	class:ax::GLSLMaterial	access:private
VertAttribStastics	.\glmesh-loader.cc	/^void VertAttribStastics(const GLMmodel *model, VertAttribsVec *vert_attribs,$/;"	f	namespace:ax	signature:(const GLMmodel *model, VertAttribsVec *vert_attribs, TriVertAttribIdx attrib)
VertAttribsVec	.\glmesh-loader.cc	/^typedef Array<Idxs> VertAttribsVec;$/;"	t	namespace:ax	file:
ViewMatrix	.\camera.h	/^  glm::mat4 ViewMatrix() const {    $/;"	f	class:ax::PerspectiveCameraGL	access:public	signature:() const
ViewProjMatrix	.\camera.h	/^  glm::mat4 ViewProjMatrix() const {   $/;"	f	class:ax::PerspectiveCameraGL	access:public	signature:() const
VisualizeTexture	.\gl_utils.cc	/^void VisualizeTexture(const Texture2DPtr tex, bool full_screen) {  $/;"	f	namespace:ax	signature:(const Texture2DPtr tex, bool full_screen)
VisualizeTexture	.\utils.h	/^void VisualizeTexture(const Texture2DPtr tex, bool full_screen = false);$/;"	p	namespace:ax	signature:(const Texture2DPtr tex, bool full_screen = false)
VisualizeViewSpace	.\utils.h	/^void VisualizeViewSpace(const C &camera, float alpha = 0.5f) {$/;"	f	namespace:ax	signature:(const C &camera, float alpha = 0.5f)
Walk	.\camera.cc	/^void FirstPersonMotion::Walk(float units) {$/;"	f	class:ax::FirstPersonMotion	signature:(float units)
Walk	.\camera.cc	/^void FlyMotion::Walk(float units) {$/;"	f	class:ax::FlyMotion	signature:(float units)
Walk	.\camera.cc	/^void OrbitMotion::Walk( float units ) {$/;"	f	class:ax::OrbitMotion	signature:( float units )
Walk	.\camera.cc	/^void SpectatorMotion::Walk(float units) {$/;"	f	class:ax::SpectatorMotion	signature:(float units)
Walk	.\camera.h	/^  virtual void Walk(float units) = 0; \/\/ move forward\/backward$/;"	p	class:ax::Motion	access:public	signature:(float units)
Walk	.\camera.h	/^  virtual void Walk(float units);$/;"	p	class:ax::FirstPersonMotion	access:public	signature:(float units)
Walk	.\camera.h	/^  virtual void Walk(float units);$/;"	p	class:ax::FlyMotion	access:public	signature:(float units)
Walk	.\camera.h	/^  virtual void Walk(float units);$/;"	p	class:ax::OrbitMotion	access:public	signature:(float units)
Walk	.\camera.h	/^  virtual void Walk(float units);$/;"	p	class:ax::SpectatorMotion	access:public	signature:(float units)
Yaw	.\camera.cc	/^void FirstPersonMotion::Yaw(float angle) {$/;"	f	class:ax::FirstPersonMotion	signature:(float angle)
Yaw	.\camera.cc	/^void FlyMotion::Yaw(float angle) {$/;"	f	class:ax::FlyMotion	signature:(float angle)
Yaw	.\camera.cc	/^void OrbitMotion::Yaw(float angle) {$/;"	f	class:ax::OrbitMotion	signature:(float angle)
Yaw	.\camera.h	/^  virtual void Yaw(float angle) = 0; \/\/ rotate on up vector$/;"	p	class:ax::Motion	access:public	signature:(float angle)
Yaw	.\camera.h	/^  virtual void Yaw(float angle);$/;"	p	class:ax::FirstPersonMotion	access:public	signature:(float angle)
Yaw	.\camera.h	/^  virtual void Yaw(float angle);$/;"	p	class:ax::FlyMotion	access:public	signature:(float angle)
Yaw	.\camera.h	/^  virtual void Yaw(float angle);$/;"	p	class:ax::OrbitMotion	access:public	signature:(float angle)
Zoom	.\camera.h	/^  void Zoom(float f) { scale_ *= f; }$/;"	f	class:ax::TrackableI	access:public	signature:(float f)
_GLMgroup	.\glm_avl.h	/^typedef struct _GLMgroup {$/;"	s
_GLMgroup::material	.\glm_avl.h	/^  GLuint            material;       \/* index to material for group *\/$/;"	m	struct:_GLMgroup	access:public
_GLMgroup::name	.\glm_avl.h	/^  char*             name;           \/* name of this group *\/$/;"	m	struct:_GLMgroup	access:public
_GLMgroup::next	.\glm_avl.h	/^  struct _GLMgroup* next;           \/* pointer to next group in model *\/$/;"	m	struct:_GLMgroup	typeref:struct:_GLMgroup::_GLMgroup	access:public
_GLMgroup::numtriangles	.\glm_avl.h	/^  GLuint            numtriangles;   \/* number of triangles in this group *\/$/;"	m	struct:_GLMgroup	access:public
_GLMgroup::triangles	.\glm_avl.h	/^  GLuint*           triangles;      \/* array of triangle indices *\/$/;"	m	struct:_GLMgroup	access:public
_GLMmaterial	.\glm_avl.h	/^typedef struct _GLMmaterial$/;"	s
_GLMmaterial::ambient	.\glm_avl.h	/^  GLfloat ambient[4];           \/* ambient component *\/$/;"	m	struct:_GLMmaterial	access:public
_GLMmaterial::diffuse	.\glm_avl.h	/^  GLfloat diffuse[4];           \/* diffuse component *\/$/;"	m	struct:_GLMmaterial	access:public
_GLMmaterial::emmissive	.\glm_avl.h	/^  GLfloat emmissive[4];         \/* emmissive component *\/$/;"	m	struct:_GLMmaterial	access:public
_GLMmaterial::height	.\glm_avl.h	/^  int height,$/;"	m	struct:_GLMmaterial	access:public
_GLMmaterial::image	.\glm_avl.h	/^  unsigned char* image;$/;"	m	struct:_GLMmaterial	access:public
_GLMmaterial::name	.\glm_avl.h	/^  char* name;                   \/* name of material *\/$/;"	m	struct:_GLMmaterial	access:public
_GLMmaterial::shininess	.\glm_avl.h	/^  GLfloat shininess;            \/* specular exponent *\/$/;"	m	struct:_GLMmaterial	access:public
_GLMmaterial::specular	.\glm_avl.h	/^  GLfloat specular[4];          \/* specular component *\/$/;"	m	struct:_GLMmaterial	access:public
_GLMmaterial::t_filename	.\glm_avl.h	/^  char *t_filename;$/;"	m	struct:_GLMmaterial	access:public
_GLMmaterial::t_id	.\glm_avl.h	/^  GLuint t_id[1];$/;"	m	struct:_GLMmaterial	access:public
_GLMmaterial::textured	.\glm_avl.h	/^  int textured;$/;"	m	struct:_GLMmaterial	access:public
_GLMmaterial::width	.\glm_avl.h	/^      width;$/;"	m	struct:_GLMmaterial	access:public
_GLMmodel	.\glm_avl.h	/^typedef struct _GLMmodel {$/;"	s
_GLMmodel::facetnorms	.\glm_avl.h	/^  GLfloat* facetnorms;          \/* array of facetnorms *\/$/;"	m	struct:_GLMmodel	access:public
_GLMmodel::groups	.\glm_avl.h	/^  GLMgroup*    groups;          \/* linked list of groups *\/$/;"	m	struct:_GLMmodel	access:public
_GLMmodel::materials	.\glm_avl.h	/^  GLMmaterial* materials;       \/* array of materials *\/$/;"	m	struct:_GLMmodel	access:public
_GLMmodel::mtllibname	.\glm_avl.h	/^  char*    mtllibname;          \/* name of the material library *\/$/;"	m	struct:_GLMmodel	access:public
_GLMmodel::normals	.\glm_avl.h	/^  GLfloat* normals;             \/* array of normals *\/$/;"	m	struct:_GLMmodel	access:public
_GLMmodel::numfacetnorms	.\glm_avl.h	/^  GLuint   numfacetnorms;       \/* number of facetnorms in model *\/$/;"	m	struct:_GLMmodel	access:public
_GLMmodel::numgroups	.\glm_avl.h	/^  GLuint       numgroups;       \/* number of groups in model *\/$/;"	m	struct:_GLMmodel	access:public
_GLMmodel::nummaterials	.\glm_avl.h	/^  GLuint       nummaterials;    \/* number of materials in model *\/$/;"	m	struct:_GLMmodel	access:public
_GLMmodel::numnormals	.\glm_avl.h	/^  GLuint   numnormals;          \/* number of normals in model *\/$/;"	m	struct:_GLMmodel	access:public
_GLMmodel::numtexcoords	.\glm_avl.h	/^  GLuint   numtexcoords;        \/* number of texcoords in model *\/$/;"	m	struct:_GLMmodel	access:public
_GLMmodel::numtriangles	.\glm_avl.h	/^  GLuint       numtriangles;    \/* number of triangles in model *\/$/;"	m	struct:_GLMmodel	access:public
_GLMmodel::numvertices	.\glm_avl.h	/^  GLuint   numvertices;         \/* number of vertices in model *\/$/;"	m	struct:_GLMmodel	access:public
_GLMmodel::pathname	.\glm_avl.h	/^  char*    pathname;            \/* path to this model *\/$/;"	m	struct:_GLMmodel	access:public
_GLMmodel::position	.\glm_avl.h	/^  GLfloat position[3];          \/* position of the model *\/$/;"	m	struct:_GLMmodel	access:public
_GLMmodel::texcoords	.\glm_avl.h	/^  GLfloat* texcoords;           \/* array of texture coordinates *\/$/;"	m	struct:_GLMmodel	access:public
_GLMmodel::triangles	.\glm_avl.h	/^  GLMtriangle* triangles;       \/* array of triangles *\/$/;"	m	struct:_GLMmodel	access:public
_GLMmodel::vertices	.\glm_avl.h	/^  GLfloat* vertices;            \/* array of vertices  *\/$/;"	m	struct:_GLMmodel	access:public
_GLMnode	.\glm_avl.cpp	/^typedef struct _GLMnode {$/;"	s	file:
_GLMnode::averaged	.\glm_avl.cpp	/^    GLboolean      averaged;$/;"	m	struct:_GLMnode	file:	access:public
_GLMnode::index	.\glm_avl.cpp	/^    GLuint         index;$/;"	m	struct:_GLMnode	file:	access:public
_GLMnode::next	.\glm_avl.cpp	/^    struct _GLMnode* next;$/;"	m	struct:_GLMnode	typeref:struct:_GLMnode::_GLMnode	file:	access:public
_GLMtriangle	.\glm_avl.h	/^typedef struct _GLMtriangle {$/;"	s
_GLMtriangle::findex	.\glm_avl.h	/^  GLuint findex;                \/* index of triangle facet normal *\/$/;"	m	struct:_GLMtriangle	access:public
_GLMtriangle::nindices	.\glm_avl.h	/^  GLuint nindices[3];           \/* array of triangle normal indices *\/$/;"	m	struct:_GLMtriangle	access:public
_GLMtriangle::tindices	.\glm_avl.h	/^  GLuint tindices[3];           \/* array of triangle texcoord indices*\/$/;"	m	struct:_GLMtriangle	access:public
_GLMtriangle::vindices	.\glm_avl.h	/^  GLuint vindices[3];           \/* array of triangle vertex indices *\/$/;"	m	struct:_GLMtriangle	access:public
__HAS_CUDA__	.\gl_buffer.h	8;"	d
__ParamSet	.\params.h	/^struct __ParamSet {$/;"	s	namespace:ax
__ParamSet2	.\params.h	/^struct __ParamSet2 : public __ParamSet<T> {$/;"	s	namespace:ax	inherits:__ParamSet
a	.\color.h	/^   T r, g, b, a;$/;"	m	class:ax::Color	access:public
adj_idx_buffer_	.\glmesh.h	/^  ax::ArrayBufferGL adj_idx_buffer_;$/;"	m	class:ax::GLMesh	access:private
ambient	.\glm_avl.h	/^  GLfloat ambient[4];           \/* ambient component *\/$/;"	m	struct:_GLMmaterial	access:public
ambient	.\glmaterial.h	/^  const Colorf &ambient() const { return ambient_; }$/;"	f	class:ax::GLMaterial	access:public	signature:() const
ambient_	.\glmaterial.h	/^  Colorf ambient_, diffuse_, specular_, emission_;$/;"	m	class:ax::GLMaterial	access:private
aspect_ratio	.\camera.h	/^  float aspect_ratio() const { return aspect_ratio_; }$/;"	f	class:ax::PerspectiveCameraGL	access:public	signature:() const
aspect_ratio_	.\camera.h	/^  float fovy_, aspect_ratio_, z_near_, z_far_;$/;"	m	class:ax::PerspectiveCameraGL	access:private
average_count_	.\fps_counter.h	/^  float average_count_;$/;"	m	class:ax::FpsCounter	access:private
average_type_	.\fps_counter.h	/^  const int average_type_;$/;"	m	class:ax::FpsCounter	access:private
averaged	.\glm_avl.cpp	/^    GLboolean      averaged;$/;"	m	struct:_GLMnode	file:	access:public
ax	.\camera.cc	/^namespace ax {$/;"	n	file:
ax	.\camera.h	/^namespace ax {$/;"	n
ax	.\cg_fwd.h	/^namespace ax {$/;"	n
ax	.\color.h	/^namespace ax {$/;"	n
ax	.\cube_image.cc	/^namespace ax {$/;"	n	file:
ax	.\cube_image.h	/^namespace ax {$/;"	n
ax	.\cube_texture_gl.h	/^namespace ax {$/;"	n
ax	.\fps_counter.h	/^namespace ax {$/;"	n
ax	.\framebuffer_object.cc	/^namespace ax {$/;"	n	file:
ax	.\framebuffer_object.h	/^namespace ax {$/;"	n
ax	.\gl_buffer.cc	/^namespace ax {$/;"	n	file:
ax	.\gl_buffer.h	/^namespace ax {$/;"	n
ax	.\gl_object.cc	/^namespace ax {$/;"	n	file:
ax	.\gl_object.h	/^namespace ax {$/;"	n
ax	.\gl_utils.cc	/^namespace ax {$/;"	n	file:
ax	.\glmaterial.cc	/^namespace ax {$/;"	n	file:
ax	.\glmaterial.h	/^namespace ax {$/;"	n
ax	.\glmesh-loader.cc	/^namespace ax {$/;"	n	file:
ax	.\glmesh.cc	/^namespace ax {$/;"	n	file:
ax	.\glmesh.h	/^namespace ax {$/;"	n
ax	.\globject.h	/^namespace ax {$/;"	n
ax	.\glslmaterial.cc	/^namespace ax {$/;"	n	file:
ax	.\glslmaterial.h	/^namespace ax {$/;"	n
ax	.\group.cc	/^namespace ax {$/;"	n	file:
ax	.\group.h	/^namespace ax {$/;"	n
ax	.\image.cc	/^namespace ax {$/;"	n	file:
ax	.\image.h	/^namespace ax {$/;"	n
ax	.\image_texture_gl.h	/^namespace ax {$/;"	n
ax	.\material-factory.cc	/^namespace ax {$/;"	n	file:
ax	.\material-factory.h	/^namespace ax {$/;"	n
ax	.\material.cc	/^namespace ax {$/;"	n	file:
ax	.\material.h	/^namespace ax {$/;"	n
ax	.\model_gl.cc	/^namespace ax {$/;"	n	file:
ax	.\model_gl.h	/^namespace ax {$/;"	n
ax	.\object-factory.cc	/^namespace ax {$/;"	n	file:
ax	.\object-factory.h	/^namespace ax {$/;"	n
ax	.\params.h	/^namespace ax {$/;"	n
ax	.\parser.cc	/^namespace ax {$/;"	n	file:
ax	.\parser.h	/^namespace ax {$/;"	n
ax	.\program_glsl.cc	/^namespace ax {$/;"	n	file:
ax	.\program_glsl.h	/^namespace ax {$/;"	n
ax	.\render_buffer.cc	/^namespace ax {$/;"	n	file:
ax	.\render_buffer.h	/^namespace ax {$/;"	n
ax	.\render_device_fbo.cc	/^namespace ax {$/;"	n	file:
ax	.\render_device_fbo.h	/^namespace ax {$/;"	n
ax	.\scene.cc	/^namespace ax {$/;"	n	file:
ax	.\scene.h	/^namespace ax {$/;"	n
ax	.\shader_object.cc	/^namespace ax {$/;"	n	file:
ax	.\shader_object.h	/^namespace ax {$/;"	n
ax	.\texture_gl.cc	/^namespace ax {$/;"	n	file:
ax	.\texture_gl.h	/^namespace ax {$/;"	n
ax	.\trimesh_glmmodel.cc	/^namespace ax {$/;"	n	file:
ax	.\trimesh_glmmodel.h	/^namespace ax {$/;"	n
ax	.\utils.h	/^namespace ax {$/;"	n
ax::ArrayBufferGL	.\gl_buffer.h	/^class ArrayBufferGL {$/;"	c	namespace:ax
ax::ArrayBufferGL::ArrayBufferGL	.\gl_buffer.h	/^  ArrayBufferGL(int target = GL_ARRAY_BUFFER) : target_(target), capacity_(0), id_(0), gpu_ptr_(0), size_(0) { }$/;"	f	class:ax::ArrayBufferGL	access:public	signature:(int target = GL_ARRAY_BUFFER)
ax::ArrayBufferGL::Bind	.\gl_buffer.h	/^  void Bind() const { glBindBuffer(this->target_, this->id_); }$/;"	f	class:ax::ArrayBufferGL	access:public	signature:() const
ax::ArrayBufferGL::BindGPUPtr	.\gl_buffer.cc	/^GLuint64 ArrayBufferGL::BindGPUPtr(uint32 access) {$/;"	f	class:ax::ArrayBufferGL	signature:(uint32 access)
ax::ArrayBufferGL::BindGPUPtr	.\gl_buffer.h	/^  GLuint64 BindGPUPtr(uint32 access = GL_READ_ONLY);  $/;"	p	class:ax::ArrayBufferGL	access:public	signature:(uint32 access = GL_READ_ONLY)
ax::ArrayBufferGL::Create	.\gl_buffer.h	/^  static ax::ArrayBufferGLPtr Create(uint32 size, uint32 access) {$/;"	f	class:ax::ArrayBufferGL	access:public	signature:(uint32 size, uint32 access)
ax::ArrayBufferGL::Create	.\gl_buffer.h	/^  static ax::ArrayBufferGLPtr Create(uint32 target, uint32 size, uint32 access,$/;"	f	class:ax::ArrayBufferGL	access:public	signature:(uint32 target, uint32 size, uint32 access, const void *data)
ax::ArrayBufferGL::MapBuffer	.\gl_buffer.h	/^  T *MapBuffer(uint32 access = GL_READ_ONLY) {$/;"	f	class:ax::ArrayBufferGL	access:public	signature:(uint32 access = GL_READ_ONLY)
ax::ArrayBufferGL::MapBuffer_	.\gl_buffer.cc	/^void *ArrayBufferGL::MapBuffer_(uint32 access) {$/;"	f	class:ax::ArrayBufferGL	signature:(uint32 access)
ax::ArrayBufferGL::MapBuffer_	.\gl_buffer.h	/^  void *MapBuffer_(uint32 access);$/;"	p	class:ax::ArrayBufferGL	access:private	signature:(uint32 access)
ax::ArrayBufferGL::Release	.\gl_buffer.cc	/^void ArrayBufferGL::Release() {$/;"	f	class:ax::ArrayBufferGL	signature:()
ax::ArrayBufferGL::Release	.\gl_buffer.h	/^  void Release();  $/;"	p	class:ax::ArrayBufferGL	access:private	signature:()
ax::ArrayBufferGL::Resize	.\gl_buffer.cc	/^bool ArrayBufferGL::Resize(uint32 size, const void *data, bool force_shrink) {$/;"	f	class:ax::ArrayBufferGL	signature:(uint32 size, const void *data, bool force_shrink)
ax::ArrayBufferGL::Resize	.\gl_buffer.h	/^  virtual bool Resize(uint32 size, const void *data=NULL, bool force_shrink=false);$/;"	p	class:ax::ArrayBufferGL	access:public	signature:(uint32 size, const void *data=NULL, bool force_shrink=false)
ax::ArrayBufferGL::SetData	.\gl_buffer.cc	/^uint32 ArrayBufferGL::SetData(int offset, int size, const void *data) {$/;"	f	class:ax::ArrayBufferGL	signature:(int offset, int size, const void *data)
ax::ArrayBufferGL::SetData	.\gl_buffer.h	/^  uint32 SetData(int offset, int size, const void *data);$/;"	p	class:ax::ArrayBufferGL	access:public	signature:(int offset, int size, const void *data)
ax::ArrayBufferGL::Unbind	.\gl_buffer.h	/^  void Unbind() const { glBindBuffer(this->target_, 0); }  $/;"	f	class:ax::ArrayBufferGL	access:public	signature:() const
ax::ArrayBufferGL::capacity_	.\gl_buffer.h	/^  uint32 capacity_;$/;"	m	class:ax::ArrayBufferGL	access:private
ax::ArrayBufferGL::gpu_ptr	.\gl_buffer.h	/^  GLuint64EXT gpu_ptr() const { return this->gpu_ptr_; }$/;"	f	class:ax::ArrayBufferGL	access:public	signature:() const
ax::ArrayBufferGL::gpu_ptr_	.\gl_buffer.h	/^  GLuint64EXT gpu_ptr_;$/;"	m	class:ax::ArrayBufferGL	access:private
ax::ArrayBufferGL::id	.\gl_buffer.h	/^  GLuint id() const { return this->id_; }$/;"	f	class:ax::ArrayBufferGL	access:public	signature:() const
ax::ArrayBufferGL::id_	.\gl_buffer.h	/^  GLuint id_;$/;"	m	class:ax::ArrayBufferGL	access:private
ax::ArrayBufferGL::size	.\gl_buffer.h	/^  uint32 size() const { return this->size_; }$/;"	f	class:ax::ArrayBufferGL	access:public	signature:() const
ax::ArrayBufferGL::size_	.\gl_buffer.h	/^  uint32 size_;$/;"	m	class:ax::ArrayBufferGL	access:private
ax::ArrayBufferGL::target_	.\gl_buffer.h	/^  uint32 target_;$/;"	m	class:ax::ArrayBufferGL	access:private
ax::ArrayBufferGL::~ArrayBufferGL	.\gl_buffer.h	/^  virtual ~ArrayBufferGL() { this->Release(); }$/;"	f	class:ax::ArrayBufferGL	access:public	signature:()
ax::ArrayBufferGLPtr	.\cg_fwd.h	/^typedef std::tr1::shared_ptr<ArrayBufferGL> ArrayBufferGLPtr;$/;"	t	namespace:ax
ax::CGParamKeyType	.\params.h	/^typedef std::string CGParamKeyType;$/;"	t	namespace:ax
ax::CameraPan	.\camera.h	/^class CameraPan : public TrackableI {$/;"	c	namespace:ax	inherits:TrackableI
ax::CameraPan::CameraPan	.\camera.h	/^  CameraPan(C *camera) : camera_(camera) { }$/;"	f	class:ax::CameraPan	access:public	signature:(C *camera)
ax::CameraPan::UpdateObject	.\camera.h	/^  void UpdateObject(float deltax, float deltay) {$/;"	f	class:ax::CameraPan	access:private	signature:(float deltax, float deltay)
ax::CameraPan::camera_	.\camera.h	/^  C *camera_;$/;"	m	class:ax::CameraPan	access:private
ax::CameraRot	.\camera.h	/^class CameraRot : public TrackableI {$/;"	c	namespace:ax	inherits:TrackableI
ax::CameraRot::CameraRot	.\camera.h	/^  CameraRot(C *camera) : camera_(camera) { }$/;"	f	class:ax::CameraRot	access:public	signature:(C *camera)
ax::CameraRot::UpdateObject	.\camera.h	/^  void UpdateObject(float deltax, float deltay) {$/;"	f	class:ax::CameraRot	access:private	signature:(float deltax, float deltay)
ax::CameraRot::camera_	.\camera.h	/^  C *camera_;$/;"	m	class:ax::CameraRot	access:private
ax::CheckErrorsGL	.\gl_utils.cc	/^bool CheckErrorsGL(const char* location) {	$/;"	f	namespace:ax	signature:(const char* location)
ax::CheckErrorsGL	.\utils.h	/^bool CheckErrorsGL(const char *location);$/;"	p	namespace:ax	signature:(const char *location)
ax::CheckGLInfo	.\gl_utils.cc	/^bool CheckGLInfo() {$/;"	f	namespace:ax	signature:()
ax::CheckGLInfo	.\utils.h	/^bool CheckGLInfo();$/;"	p	namespace:ax	signature:()
ax::Color	.\color.h	/^class Color {$/;"	c	namespace:ax
ax::Color::Color	.\color.h	/^   Color() : r(0), g(0), b(0), a(0) { }$/;"	f	class:ax::Color	access:public	signature:()
ax::Color::Color	.\color.h	/^   Color(T r, T g, T b) : r(r), g(g), b(b), a(0) { }$/;"	f	class:ax::Color	access:public	signature:(T r, T g, T b)
ax::Color::Color	.\color.h	/^   Color(T r, T g, T b, T a) : r(r), g(g), b(b), a(a) { }$/;"	f	class:ax::Color	access:public	signature:(T r, T g, T b, T a)
ax::Color::Color	.\color.h	/^   Color(const V &v) : r(v.r), g(v.g), b(v.b), a(v.a) { }$/;"	f	class:ax::Color	access:public	signature:(const V &v)
ax::Color::a	.\color.h	/^   T r, g, b, a;$/;"	m	class:ax::Color	access:public
ax::Color::b	.\color.h	/^   T r, g, b, a;$/;"	m	class:ax::Color	access:public
ax::Color::g	.\color.h	/^   T r, g, b, a;$/;"	m	class:ax::Color	access:public
ax::Color::kBlack	.\color.h	/^   static const Color kBlack;$/;"	m	class:ax::Color	access:public
ax::Color::kBlack	.\color.h	/^const Color<T> Color<T>::kBlack = Color<T>(0, 0, 0, 1);$/;"	m	class:ax::Color
ax::Color::kWhite	.\color.h	/^   static const Color kWhite;$/;"	m	class:ax::Color	access:public
ax::Color::kWhite	.\color.h	/^const Color<T> Color<T>::kWhite = Color<T>(1, 1, 1, 1);$/;"	m	class:ax::Color
ax::Color::ptr	.\color.h	/^   T *ptr() { return &r; }$/;"	f	class:ax::Color	access:public	signature:()
ax::Color::ptr	.\color.h	/^   const T *ptr() const { return &r; }$/;"	f	class:ax::Color	access:public	signature:() const
ax::Color::r	.\color.h	/^   T r, g, b, a;$/;"	m	class:ax::Color	access:public
ax::Colord	.\color.h	/^typedef Color<double> Colord;$/;"	t	namespace:ax
ax::Colorf	.\color.h	/^typedef Color<float> Colorf;$/;"	t	namespace:ax
ax::CountExpandedVerts	.\glmesh-loader.cc	/^size_t CountExpandedVerts(const VertAttribsVec &attribs) {$/;"	f	namespace:ax	signature:(const VertAttribsVec &attribs)
ax::CountExpandedVerts	.\glmesh-loader.cc	/^size_t CountExpandedVerts(const VertAttribsVec &attribs1, $/;"	f	namespace:ax	signature:(const VertAttribsVec &attribs1, const VertAttribsVec &attribs2)
ax::CreateIndexArray	.\glmesh-loader.cc	/^uint32 *CreateIndexArray(const GLMmodel *model) {$/;"	f	namespace:ax	signature:(const GLMmodel *model)
ax::CreateNormalArray	.\glmesh-loader.cc	/^Normal *CreateNormalArray(const GLMmodel *model) {$/;"	f	namespace:ax	signature:(const GLMmodel *model)
ax::CreateTexCoordArray	.\glmesh-loader.cc	/^float *CreateTexCoordArray(const GLMmodel *model) {$/;"	f	namespace:ax	signature:(const GLMmodel *model)
ax::CreateVertexArray	.\glmesh-loader.cc	/^Point *CreateVertexArray(const GLMmodel *model) {$/;"	f	namespace:ax	signature:(const GLMmodel *model)
ax::CubeImage	.\cube_image.h	/^class CubeImage {$/;"	c	namespace:ax
ax::CubeImage::CubeImage	.\cube_image.h	/^  CubeImage() : width_(0), height_(0), format_(0), type_(0) {$/;"	f	class:ax::CubeImage	access:public	signature:()
ax::CubeImage::DISABLE_COPY_AND_ASSIGN	.\cube_image.h	/^  DISABLE_COPY_AND_ASSIGN(CubeImage);$/;"	p	class:ax::CubeImage	access:private	signature:(CubeImage)
ax::CubeImage::Load	.\cube_image.cc	/^bool CubeImage::Load(const char *filename) {$/;"	f	class:ax::CubeImage	signature:(const char *filename)
ax::CubeImage::Load	.\cube_image.h	/^  bool Load(const char *filename);$/;"	p	class:ax::CubeImage	access:public	signature:(const char *filename)
ax::CubeImage::data	.\cube_image.h	/^  const char *data(int i) const { return data_[i]; }$/;"	f	class:ax::CubeImage	access:public	signature:(int i) const
ax::CubeImage::data_	.\cube_image.h	/^  char *data_[6];$/;"	m	class:ax::CubeImage	access:private
ax::CubeImage::format	.\cube_image.h	/^  int format() const { return format_; }$/;"	f	class:ax::CubeImage	access:public	signature:() const
ax::CubeImage::format_	.\cube_image.h	/^  int format_;$/;"	m	class:ax::CubeImage	access:private
ax::CubeImage::height	.\cube_image.h	/^  int height() const { return height_; }$/;"	f	class:ax::CubeImage	access:public	signature:() const
ax::CubeImage::height_	.\cube_image.h	/^  int width_,height_;$/;"	m	class:ax::CubeImage	access:private
ax::CubeImage::type	.\cube_image.h	/^  int type() const { return type_; }$/;"	f	class:ax::CubeImage	access:public	signature:() const
ax::CubeImage::type_	.\cube_image.h	/^  int type_;$/;"	m	class:ax::CubeImage	access:private
ax::CubeImage::width	.\cube_image.h	/^  int width() const { return width_; }$/;"	f	class:ax::CubeImage	access:public	signature:() const
ax::CubeImage::width_	.\cube_image.h	/^  int width_,height_;$/;"	m	class:ax::CubeImage	access:private
ax::CubeImage::~CubeImage	.\cube_image.h	/^  ~CubeImage() {$/;"	f	class:ax::CubeImage	access:public	signature:()
ax::CubeTexture	.\texture_gl.h	/^class CubeTexture : public TextureGL {$/;"	c	namespace:ax	inherits:TextureGL
ax::CubeTexture::CubeTexture	.\texture_gl.h	/^  CubeTexture(const std::string &name = "") : $/;"	f	class:ax::CubeTexture	access:public	signature:(const std::string &name = Ó)
ax::CubeTexture::Initialize	.\texture_gl.cc	/^bool CubeTexture::Initialize(const CubeImage &image, int i_format) {$/;"	f	class:ax::CubeTexture	signature:(const CubeImage &image, int i_format)
ax::CubeTexture::Initialize	.\texture_gl.cc	/^bool CubeTexture::Initialize(const Image *images[6], int i_format) {$/;"	f	class:ax::CubeTexture	signature:(const Image *images[6], int i_format)
ax::CubeTexture::Initialize	.\texture_gl.cc	/^bool CubeTexture::Initialize(int w, int h, int i_format) {$/;"	f	class:ax::CubeTexture	signature:(int w, int h, int i_format)
ax::CubeTexture::Initialize	.\texture_gl.h	/^  bool Initialize(const CubeImage &image, int i_format);$/;"	p	class:ax::CubeTexture	access:public	signature:(const CubeImage &image, int i_format)
ax::CubeTexture::Initialize	.\texture_gl.h	/^  bool Initialize(const Image *images[6], int i_format);$/;"	p	class:ax::CubeTexture	access:public	signature:(const Image *images[6], int i_format)
ax::CubeTexture::Initialize	.\texture_gl.h	/^  bool Initialize(int w, int h, int i_format);$/;"	p	class:ax::CubeTexture	access:public	signature:(int w, int h, int i_format)
ax::CubeTextureGL	.\cube_texture_gl.h	/^class CubeTextureGL {$/;"	c	namespace:ax
ax::CubeTextureGL::BeginInitialize	.\cube_texture_gl.h	/^  bool BeginInitialize(void);$/;"	p	class:ax::CubeTextureGL	access:private	signature:(void)
ax::CubeTextureGL::Bind	.\cube_texture_gl.h	/^  void Bind(void) const;$/;"	p	class:ax::CubeTextureGL	access:public	signature:(void) const
ax::CubeTextureGL::CubeTextureGL	.\cube_texture_gl.h	/^  CubeTextureGL(void) : tex_id_(0) { }$/;"	f	class:ax::CubeTextureGL	access:public	signature:(void)
ax::CubeTextureGL::DISABLE_COPY_AND_ASSIGN	.\cube_texture_gl.h	/^  DISABLE_COPY_AND_ASSIGN(CubeTextureGL);$/;"	p	class:ax::CubeTextureGL	access:private	signature:(CubeTextureGL)
ax::CubeTextureGL::EndInitialize	.\cube_texture_gl.h	/^  bool EndInitialize(void);$/;"	p	class:ax::CubeTextureGL	access:private	signature:(void)
ax::CubeTextureGL::Initialize	.\cube_texture_gl.h	/^  bool Initialize(Image *images[6], GLuint internal_format);$/;"	p	class:ax::CubeTextureGL	access:public	signature:(Image *images[6], GLuint internal_format)
ax::CubeTextureGL::Initialize	.\cube_texture_gl.h	/^  bool Initialize(const CubeImage &image, GLint internal_format);$/;"	p	class:ax::CubeTextureGL	access:public	signature:(const CubeImage &image, GLint internal_format)
ax::CubeTextureGL::Initialize	.\cube_texture_gl.h	/^  bool Initialize(int width, int height, GLint internal_format);$/;"	p	class:ax::CubeTextureGL	access:public	signature:(int width, int height, GLint internal_format)
ax::CubeTextureGL::Release	.\cube_texture_gl.h	/^  void Release(void);$/;"	p	class:ax::CubeTextureGL	access:private	signature:(void)
ax::CubeTextureGL::SetDefaultParameters	.\cube_texture_gl.h	/^  void SetDefaultParameters(void);$/;"	p	class:ax::CubeTextureGL	access:private	signature:(void)
ax::CubeTextureGL::Unbind	.\cube_texture_gl.h	/^  void Unbind(void) const;$/;"	p	class:ax::CubeTextureGL	access:public	signature:(void) const
ax::CubeTextureGL::tex_id	.\cube_texture_gl.h	/^  GLuint tex_id() const { return tex_id_; }$/;"	f	class:ax::CubeTextureGL	access:public	signature:() const
ax::CubeTextureGL::tex_id_	.\cube_texture_gl.h	/^  GLuint tex_id_;$/;"	m	class:ax::CubeTextureGL	access:private
ax::CubeTextureGL::~CubeTextureGL	.\cube_texture_gl.h	/^  ~CubeTextureGL(void);$/;"	p	class:ax::CubeTextureGL	access:public	signature:(void)
ax::CudaArrayBufferGL	.\gl_buffer.h	/^class CudaArrayBufferGL : public ax::ArrayBufferGL {$/;"	c	namespace:ax	inherits:ax::ArrayBufferGL
ax::CudaArrayBufferGL::CudaArrayBufferGL	.\gl_buffer.h	/^  CudaArrayBufferGL() : registered_(false), mapped_(false) { }$/;"	f	class:ax::CudaArrayBufferGL	access:public	signature:()
ax::CudaArrayBufferGL::MapCudaPtr	.\gl_buffer.h	/^  T *MapCudaPtr() {$/;"	f	class:ax::CudaArrayBufferGL	access:public	signature:()
ax::CudaArrayBufferGL::Register	.\gl_buffer.h	/^  void Register() {$/;"	f	class:ax::CudaArrayBufferGL	access:public	signature:()
ax::CudaArrayBufferGL::Resize	.\gl_buffer.h	/^  virtual bool Resize(uint32 size, const void *data=NULL, bool force_shrink=false) {$/;"	f	class:ax::CudaArrayBufferGL	access:public	signature:(uint32 size, const void *data=NULL, bool force_shrink=false)
ax::CudaArrayBufferGL::UnmapCudaPtr	.\gl_buffer.h	/^  void UnmapCudaPtr() {$/;"	f	class:ax::CudaArrayBufferGL	access:public	signature:()
ax::CudaArrayBufferGL::Unregister	.\gl_buffer.h	/^  void Unregister() {$/;"	f	class:ax::CudaArrayBufferGL	access:public	signature:()
ax::CudaArrayBufferGL::mapped_	.\gl_buffer.h	/^  bool mapped_;$/;"	m	class:ax::CudaArrayBufferGL	access:private
ax::CudaArrayBufferGL::registered_	.\gl_buffer.h	/^  bool registered_;$/;"	m	class:ax::CudaArrayBufferGL	access:private
ax::CudaArrayBufferGL::~CudaArrayBufferGL	.\gl_buffer.h	/^  ~CudaArrayBufferGL() { this->Unregister(); }$/;"	f	class:ax::CudaArrayBufferGL	access:public	signature:()
ax::DEPRECATED	.\model_gl.h	/^class DEPRECATED(MyScreenQuad) {$/;"	f	namespace:ax	signature:(MyScreenQuad)
ax::DEPRECATED	.\utils.h	/^class DEPRECATED(GPUTimerManager) {$/;"	f	namespace:ax	signature:(GPUTimerManager)
ax::DefineMacros	.\shader_object.cc	/^void DefineMacros(std::string &code, const MacroList &macros) {$/;"	f	namespace:ax	signature:(std::string &code, const MacroList &macros)
ax::DisplayStatistics	.\gl_utils.cc	/^void DisplayStatistics(const char *name, float data, const char *unit, $/;"	f	namespace:ax	signature:(const char *name, float data, const char *unit, int x, int y)
ax::DisplayStatistics	.\utils.h	/^void DisplayStatistics(const char *name, float data, const char *unit,$/;"	p	namespace:ax	signature:(const char *name, float data, const char *unit, int x = 2, int y = 9)
ax::DrawCube	.\model_gl.cc	/^void DrawCube(float size);$/;"	p	namespace:ax	file:	signature:(float size)
ax::DrawCube	.\model_gl.cc	/^void DrawCube(float x1, float y1, float z1, float x2, float y2, float z2) {$/;"	f	namespace:ax	signature:(float x1, float y1, float z1, float x2, float y2, float z2)
ax::DrawCube	.\model_gl.h	/^inline void DrawCube(const Point &p1, const Point &p2) {$/;"	f	namespace:ax	signature:(const Point &p1, const Point &p2)
ax::DrawCube	.\model_gl.h	/^void DrawCube(float x1, float y1, float z1,$/;"	p	namespace:ax	signature:(float x1, float y1, float z1, float x2, float y2, float z2)
ax::DrawQuad	.\model_gl.cc	/^void DrawQuad(float x1, float y1 ,float x2, float y2, float z) {$/;"	f	namespace:ax	signature:(float x1, float y1 ,float x2, float y2, float z)
ax::DrawQuad	.\model_gl.cc	/^void DrawQuad(float x1, float y1, float x2, float y2) {$/;"	f	namespace:ax	signature:(float x1, float y1, float x2, float y2)
ax::DrawQuad	.\model_gl.cc	/^void DrawQuad(float x1, float y1, float z1,  float x2, float y2, float z2) {$/;"	f	namespace:ax	signature:(float x1, float y1, float z1, float x2, float y2, float z2)
ax::DrawQuad	.\model_gl.h	/^inline void DrawQuad() { DrawQuad(0, 0, 1, 1); }$/;"	f	namespace:ax	signature:()
ax::DrawQuad	.\model_gl.h	/^inline void DrawQuad(float size) {$/;"	f	namespace:ax	signature:(float size)
ax::DrawQuad	.\model_gl.h	/^void DrawQuad(float x1, float y1, float x2, float y2);$/;"	p	namespace:ax	signature:(float x1, float y1, float x2, float y2)
ax::DrawQuad	.\model_gl.h	/^void DrawQuad(float x1, float y1, float x2, float y2, float z);$/;"	p	namespace:ax	signature:(float x1, float y1, float x2, float y2, float z)
ax::DrawQuad	.\model_gl.h	/^void DrawQuad(float x1, float y1, float z1,$/;"	p	namespace:ax	signature:(float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3)
ax::DrawTextGL	.\utils.h	/^void DrawTextGL(int x, int y, const char *text);$/;"	p	namespace:ax	signature:(int x, int y, const char *text)
ax::EatToEndKeyword	.\parser.cc	/^void EatToEndKeyword(FILE *fp, LineToken &token) {$/;"	f	namespace:ax	signature:(FILE *fp, LineToken &token)
ax::EatToEndKeyword	.\parser.h	/^void EatToEndKeyword(FILE *fp, LineToken &token);$/;"	p	namespace:ax	signature:(FILE *fp, LineToken &token)
ax::EmitVertex	.\utils.h	/^void EmitVertex(const T &p) { glVertex3f(p.x, p.y, p.z); }$/;"	f	namespace:ax	signature:(const T &p)
ax::Equals	.\parser.h	/^inline bool Equals(const char *s1, const char *s2) {$/;"	f	namespace:ax	signature:(const char *s1, const char *s2)
ax::ExpandMesh	.\glmesh-loader.cc	/^size_t ExpandMesh(const GLMmodel *model, Point **vertices, Normal **normals, $/;"	f	namespace:ax	signature:(const GLMmodel *model, Point **vertices, Normal **normals, float **tcoords, uint32 **indices)
ax::ExpandNormalAttrib	.\glmesh-loader.cc	/^size_t ExpandNormalAttrib(const GLMmodel *model, Point **vertices, $/;"	f	namespace:ax	signature:(const GLMmodel *model, Point **vertices, Normal **normals, uint32 **indices)
ax::ExpandTexcoordAttrib	.\glmesh-loader.cc	/^size_t ExpandTexcoordAttrib(const GLMmodel *model, Point **vertices, $/;"	f	namespace:ax	signature:(const GLMmodel *model, Point **vertices, float **tcoords, uint32 **indices)
ax::ExtractColorf	.\parser.h	/^inline Colorf ExtractColorf(const char *str) {  $/;"	f	namespace:ax	signature:(const char *str)
ax::ExtractMatrix	.\object-factory.cc	/^glm::mat4 ExtractMatrix(const char *str) {$/;"	f	namespace:ax	signature:(const char *str)
ax::ExtractVec3	.\parser.h	/^inline ax::Vector3 ExtractVec3(const char *str) {$/;"	f	namespace:ax	signature:(const char *str)
ax::ExtractVec4	.\parser.h	/^inline ax::Vector4 ExtractVec4(const char *str) {$/;"	f	namespace:ax	signature:(const char *str)
ax::FBODevicePtr	.\cg_fwd.h	/^typedef std::tr1::shared_ptr<RenderDeviceFBO> FBODevicePtr;$/;"	t	namespace:ax
ax::FBParams	.\gl_buffer.h	/^struct FBParams {$/;"	s	namespace:ax
ax::FBParams::kBufferName	.\gl_buffer.h	/^  static const std::string kBufferName;$/;"	m	struct:ax::FBParams	access:public
ax::FBParams::kColorBufferCount	.\gl_buffer.h	/^  static const std::string kColorBufferCount;$/;"	m	struct:ax::FBParams	access:public
ax::FBParams::kColorFormat	.\gl_buffer.h	/^  static const std::string kColorFormat;$/;"	m	struct:ax::FBParams	access:public
ax::FBParams::kDepthFormat	.\gl_buffer.h	/^  static const std::string kDepthFormat;$/;"	m	struct:ax::FBParams	access:public
ax::FBParams::kHasDepthBuffer	.\gl_buffer.h	/^  static const std::string kHasDepthBuffer;$/;"	m	struct:ax::FBParams	access:public
ax::FBParams::kHasStencilBuffer	.\gl_buffer.h	/^  static const std::string kHasStencilBuffer;$/;"	m	struct:ax::FBParams	access:public
ax::FBParams::kTextureTarget	.\gl_buffer.h	/^  static const std::string kTextureTarget;$/;"	m	struct:ax::FBParams	access:public
ax::FindNextMacro	.\shader_object.cc	/^size_t FindNextMacro(const std::string &code, int s) {$/;"	f	namespace:ax	signature:(const std::string &code, int s)
ax::FirstPersonMotion	.\camera.h	/^class FirstPersonMotion : public Motion {$/;"	c	namespace:ax	inherits:Motion
ax::FirstPersonMotion::Fly	.\camera.cc	/^void FirstPersonMotion::Fly(float units) {$/;"	f	class:ax::FirstPersonMotion	signature:(float units)
ax::FirstPersonMotion::Fly	.\camera.h	/^  virtual void Fly(float units);$/;"	p	class:ax::FirstPersonMotion	access:public	signature:(float units)
ax::FirstPersonMotion::Pitch	.\camera.cc	/^void FirstPersonMotion::Pitch(float angle) {$/;"	f	class:ax::FirstPersonMotion	signature:(float angle)
ax::FirstPersonMotion::Pitch	.\camera.h	/^  virtual void Pitch(float angle);$/;"	p	class:ax::FirstPersonMotion	access:public	signature:(float angle)
ax::FirstPersonMotion::Roll	.\camera.cc	/^void FirstPersonMotion::Roll(float angle) {$/;"	f	class:ax::FirstPersonMotion	signature:(float angle)
ax::FirstPersonMotion::Roll	.\camera.h	/^  virtual void Roll(float angle);$/;"	p	class:ax::FirstPersonMotion	access:public	signature:(float angle)
ax::FirstPersonMotion::Strafe	.\camera.cc	/^void FirstPersonMotion::Strafe(float units) {$/;"	f	class:ax::FirstPersonMotion	signature:(float units)
ax::FirstPersonMotion::Strafe	.\camera.h	/^  virtual void Strafe(float units);$/;"	p	class:ax::FirstPersonMotion	access:public	signature:(float units)
ax::FirstPersonMotion::Walk	.\camera.cc	/^void FirstPersonMotion::Walk(float units) {$/;"	f	class:ax::FirstPersonMotion	signature:(float units)
ax::FirstPersonMotion::Walk	.\camera.h	/^  virtual void Walk(float units);$/;"	p	class:ax::FirstPersonMotion	access:public	signature:(float units)
ax::FirstPersonMotion::Yaw	.\camera.cc	/^void FirstPersonMotion::Yaw(float angle) {$/;"	f	class:ax::FirstPersonMotion	signature:(float angle)
ax::FirstPersonMotion::Yaw	.\camera.h	/^  virtual void Yaw(float angle);$/;"	p	class:ax::FirstPersonMotion	access:public	signature:(float angle)
ax::FixMissing	.\parser.h	/^void FixMissing(T v[], int n, int k) {$/;"	f	namespace:ax	signature:(T v[], int n, int k)
ax::FloatVarMap	.\scene.h	/^typedef std::map<std::string, float> FloatVarMap;$/;"	t	namespace:ax
ax::FlyMotion	.\camera.h	/^class FlyMotion : public Motion {$/;"	c	namespace:ax	inherits:Motion
ax::FlyMotion::Fly	.\camera.cc	/^void FlyMotion::Fly(float units) {$/;"	f	class:ax::FlyMotion	signature:(float units)
ax::FlyMotion::Fly	.\camera.h	/^  virtual void Fly(float units);$/;"	p	class:ax::FlyMotion	access:public	signature:(float units)
ax::FlyMotion::FlyMotion	.\camera.h	/^  FlyMotion(const glm::vec3 &pos,  const glm::vec3 &target, $/;"	f	class:ax::FlyMotion	access:public	signature:(const glm::vec3 &pos, const glm::vec3 &target, const glm::vec3 &up = glm::vec3(0, 1, 0))
ax::FlyMotion::Pitch	.\camera.cc	/^void FlyMotion::Pitch(float angle) {$/;"	f	class:ax::FlyMotion	signature:(float angle)
ax::FlyMotion::Pitch	.\camera.h	/^  virtual void Pitch(float angle);$/;"	p	class:ax::FlyMotion	access:public	signature:(float angle)
ax::FlyMotion::Roll	.\camera.cc	/^void FlyMotion::Roll(float angle) {  Motion::roll_(angle);  }$/;"	f	class:ax::FlyMotion	signature:(float angle)
ax::FlyMotion::Roll	.\camera.h	/^  virtual void Roll(float angle);$/;"	p	class:ax::FlyMotion	access:public	signature:(float angle)
ax::FlyMotion::Strafe	.\camera.cc	/^void FlyMotion::Strafe(float units) {$/;"	f	class:ax::FlyMotion	signature:(float units)
ax::FlyMotion::Strafe	.\camera.h	/^  virtual void Strafe(float units);$/;"	p	class:ax::FlyMotion	access:public	signature:(float units)
ax::FlyMotion::Walk	.\camera.cc	/^void FlyMotion::Walk(float units) {$/;"	f	class:ax::FlyMotion	signature:(float units)
ax::FlyMotion::Walk	.\camera.h	/^  virtual void Walk(float units);$/;"	p	class:ax::FlyMotion	access:public	signature:(float units)
ax::FlyMotion::Yaw	.\camera.cc	/^void FlyMotion::Yaw(float angle) {$/;"	f	class:ax::FlyMotion	signature:(float angle)
ax::FlyMotion::Yaw	.\camera.h	/^  virtual void Yaw(float angle);$/;"	p	class:ax::FlyMotion	access:public	signature:(float angle)
ax::FlyMotion::update_	.\camera.cc	/^void FlyMotion::update_() {$/;"	f	class:ax::FlyMotion	signature:()
ax::FlyMotion::update_	.\camera.h	/^  void update_(void);$/;"	p	class:ax::FlyMotion	access:private	signature:(void)
ax::FlyPerspectiveCameraGL	.\camera.h	/^typedef PerspectiveCameraGL<FlyMotion> FlyPerspectiveCameraGL;$/;"	t	namespace:ax
ax::FlyPerspectiveCameraGL	.\cg_fwd.h	/^typedef PerspectiveCameraGL<FlyMotion> FlyPerspectiveCameraGL;$/;"	t	namespace:ax
ax::FpsCounter	.\fps_counter.h	/^class FpsCounter {$/;"	c	namespace:ax
ax::FpsCounter::AverageType	.\fps_counter.h	/^  enum AverageType { kOverFrames, kOverTime };$/;"	g	class:ax::FpsCounter	access:public
ax::FpsCounter::FpsCounter	.\fps_counter.h	/^  FpsCounter(int average_type = kOverTime, float average_count = 1.0)$/;"	f	class:ax::FpsCounter	access:public	signature:(int average_type = kOverTime, float average_count = 1.0)
ax::FpsCounter::Update	.\fps_counter.h	/^  double Update() {$/;"	f	class:ax::FpsCounter	access:public	signature:()
ax::FpsCounter::average_count_	.\fps_counter.h	/^  float average_count_;$/;"	m	class:ax::FpsCounter	access:private
ax::FpsCounter::average_type_	.\fps_counter.h	/^  const int average_type_;$/;"	m	class:ax::FpsCounter	access:private
ax::FpsCounter::fps	.\fps_counter.h	/^  double fps() const { return this->last_fps_; }$/;"	f	class:ax::FpsCounter	access:public	signature:() const
ax::FpsCounter::frame_count_	.\fps_counter.h	/^  int frame_count_;$/;"	m	class:ax::FpsCounter	access:private
ax::FpsCounter::kOverFrames	.\fps_counter.h	/^  enum AverageType { kOverFrames, kOverTime };$/;"	e	enum:ax::FpsCounter::AverageType
ax::FpsCounter::kOverTime	.\fps_counter.h	/^  enum AverageType { kOverFrames, kOverTime };$/;"	e	enum:ax::FpsCounter::AverageType
ax::FpsCounter::last_fps_	.\fps_counter.h	/^  double last_fps_;$/;"	m	class:ax::FpsCounter	access:private
ax::FpsCounter::last_time_	.\fps_counter.h	/^  double last_time_;$/;"	m	class:ax::FpsCounter	access:private
ax::FrameBuffer	.\gl_buffer.h	/^class FrameBuffer {$/;"	c	namespace:ax
ax::FrameBuffer::BindAsRenderTarget	.\gl_buffer.h	/^  void BindAsRenderTarget() { $/;"	f	class:ax::FrameBuffer	access:public	signature:()
ax::FrameBuffer::ClearBuffers	.\gl_buffer.h	/^  void ClearBuffers() { glClear(included_buffers_); }$/;"	f	class:ax::FrameBuffer	access:public	signature:()
ax::FrameBuffer::ColorBuffer	.\gl_buffer.h	/^  ax::Texture2DPtr ColorBuffer(int i) const { return this->color_buffers_[i]; }$/;"	f	class:ax::FrameBuffer	access:public	signature:(int i) const
ax::FrameBuffer::DEPRECATED	.\gl_buffer.h	/^  struct DEPRECATED(ParamNames) {$/;"	f	class:ax::FrameBuffer	access:public	signature:(ParamNames)
ax::FrameBuffer::DepthBuffer	.\gl_buffer.h	/^  DEPRECATED(ax::Texture2DPtr DepthBuffer() const) {$/;"	f	class:ax::FrameBuffer	access:public	signature:() const
ax::FrameBuffer::FrameBuffer	.\gl_buffer.h	/^  FrameBuffer() : included_buffers_(0), n_color_buffers_(0), has_stencil_buffer_(false), has_zbuffer_(false) { }$/;"	f	class:ax::FrameBuffer	access:public	signature:()
ax::FrameBuffer::GrabDepthBuffer	.\gl_buffer.h	/^  ax::Texture2DPtr GrabDepthBuffer();$/;"	p	class:ax::FrameBuffer	access:public	signature:()
ax::FrameBuffer::GrabStencilBuffer	.\gl_buffer.cc	/^ax::Texture2DPtr FrameBuffer::GrabStencilBuffer() {$/;"	f	class:ax::FrameBuffer	signature:()
ax::FrameBuffer::GrabStencilBuffer	.\gl_buffer.h	/^  ax::Texture2DPtr GrabStencilBuffer();$/;"	p	class:ax::FrameBuffer	access:public	signature:()
ax::FrameBuffer::Initialize	.\gl_buffer.cc	/^bool FrameBuffer::Initialize(const ax::ParamSet &params) {$/;"	f	class:ax::FrameBuffer	signature:(const ax::ParamSet &params)
ax::FrameBuffer::Initialize	.\gl_buffer.h	/^  bool Initialize(const ax::ParamSet &params);$/;"	p	class:ax::FrameBuffer	access:public	signature:(const ax::ParamSet &params)
ax::FrameBuffer::ParamNames::kBufferName	.\gl_buffer.cc	/^const std::string FrameBuffer::ParamNames::kBufferName = ax::FBParams::kBufferName;$/;"	m	class:ax::FrameBuffer::ParamNames	file:
ax::FrameBuffer::ParamNames::kColorBufferCount	.\gl_buffer.cc	/^const std::string FrameBuffer::ParamNames::kColorBufferCount = ax::FBParams::kColorBufferCount;$/;"	m	class:ax::FrameBuffer::ParamNames	file:
ax::FrameBuffer::ParamNames::kColorFormat	.\gl_buffer.cc	/^const std::string FrameBuffer::ParamNames::kColorFormat = ax::FBParams::kColorFormat;$/;"	m	class:ax::FrameBuffer::ParamNames	file:
ax::FrameBuffer::ParamNames::kDepthFormat	.\gl_buffer.cc	/^const std::string FrameBuffer::ParamNames::kDepthFormat = ax::FBParams::kDepthFormat;$/;"	m	class:ax::FrameBuffer::ParamNames	file:
ax::FrameBuffer::ParamNames::kHasDepthBuffer	.\gl_buffer.cc	/^const std::string FrameBuffer::ParamNames::kHasDepthBuffer = ax::FBParams::kHasDepthBuffer;$/;"	m	class:ax::FrameBuffer::ParamNames	file:
ax::FrameBuffer::ParamNames::kHasStencilBuffer	.\gl_buffer.cc	/^const std::string FrameBuffer::ParamNames::kHasStencilBuffer = ax::FBParams::kHasStencilBuffer;$/;"	m	class:ax::FrameBuffer::ParamNames	file:
ax::FrameBuffer::ParamNames::kTextureTarget	.\gl_buffer.cc	/^const std::string FrameBuffer::ParamNames::kTextureTarget = ax::FBParams::kTextureTarget;$/;"	m	class:ax::FrameBuffer::ParamNames	file:
ax::FrameBuffer::Resize	.\gl_buffer.cc	/^bool FrameBuffer::Resize(int w, int h) { $/;"	f	class:ax::FrameBuffer	signature:(int w, int h)
ax::FrameBuffer::Resize	.\gl_buffer.h	/^  bool Resize(int w, int h);$/;"	p	class:ax::FrameBuffer	access:public	signature:(int w, int h)
ax::FrameBuffer::Unbind	.\gl_buffer.h	/^  void Unbind() { this->device_->Deactivate(); }$/;"	f	class:ax::FrameBuffer	access:public	signature:()
ax::FrameBuffer::color_buffers	.\gl_buffer.h	/^  const std::vector<ax::Texture2DPtr> color_buffers() const { return this->color_buffers_; }$/;"	f	class:ax::FrameBuffer	access:public	signature:() const
ax::FrameBuffer::color_buffers_	.\gl_buffer.h	/^  std::vector<ax::Texture2DPtr> color_buffers_;$/;"	m	class:ax::FrameBuffer	access:protected
ax::FrameBuffer::color_format_	.\gl_buffer.h	/^  int color_format_;$/;"	m	class:ax::FrameBuffer	access:private
ax::FrameBuffer::depth_buffer	.\gl_buffer.h	/^  ax::Texture2DPtr depth_buffer() const { return this->depth_buffer_; }$/;"	f	class:ax::FrameBuffer	access:public	signature:() const
ax::FrameBuffer::depth_buffer_	.\gl_buffer.h	/^  ax::Texture2DPtr depth_buffer_;$/;"	m	class:ax::FrameBuffer	access:protected
ax::FrameBuffer::depth_format_	.\gl_buffer.h	/^  int depth_format_;$/;"	m	class:ax::FrameBuffer	access:private
ax::FrameBuffer::device_	.\gl_buffer.h	/^  ax::FBODevicePtr device_;$/;"	m	class:ax::FrameBuffer	access:protected
ax::FrameBuffer::has_stencil_buffer_	.\gl_buffer.h	/^  bool has_stencil_buffer_;$/;"	m	class:ax::FrameBuffer	access:private
ax::FrameBuffer::has_zbuffer_	.\gl_buffer.h	/^  bool has_zbuffer_;$/;"	m	class:ax::FrameBuffer	access:private
ax::FrameBuffer::height	.\gl_buffer.h	/^  int height() const {$/;"	f	class:ax::FrameBuffer	access:public	signature:() const
ax::FrameBuffer::included_buffers_	.\gl_buffer.h	/^  int included_buffers_;$/;"	m	class:ax::FrameBuffer	access:private
ax::FrameBuffer::n_color_buffers_	.\gl_buffer.h	/^  int n_color_buffers_;$/;"	m	class:ax::FrameBuffer	access:private
ax::FrameBuffer::name_	.\gl_buffer.h	/^  std::string name_;$/;"	m	class:ax::FrameBuffer	access:private
ax::FrameBuffer::texture_target_	.\gl_buffer.h	/^  int texture_target_;$/;"	m	class:ax::FrameBuffer	access:private
ax::FrameBuffer::width	.\gl_buffer.h	/^  int width() const {$/;"	f	class:ax::FrameBuffer	access:public	signature:() const
ax::FramebufferObject	.\framebuffer_object.h	/^class FramebufferObject {$/;"	c	namespace:ax
ax::FramebufferObject::AttachRenderBuffer	.\framebuffer_object.cc	/^void FramebufferObject::AttachRenderBuffer(GLuint buffer_id, $/;"	f	class:ax::FramebufferObject	signature:(GLuint buffer_id, GLenum attachment)
ax::FramebufferObject::AttachRenderBuffer	.\framebuffer_object.h	/^  void AttachRenderBuffer(GLuint buffId,$/;"	p	class:ax::FramebufferObject	access:public	signature:(GLuint buffId, GLenum attachment = GL_COLOR_ATTACHMENT0_EXT)
ax::FramebufferObject::AttachRenderBuffers	.\framebuffer_object.cc	/^void FramebufferObject::AttachRenderBuffers($/;"	f	class:ax::FramebufferObject	signature:( int buffer_count, GLuint buffer_id[], GLenum attachment[])
ax::FramebufferObject::AttachRenderBuffers	.\framebuffer_object.h	/^  void AttachRenderBuffers(int buffer_count, GLuint buffer_id[],$/;"	p	class:ax::FramebufferObject	access:public	signature:(int buffer_count, GLuint buffer_id[], GLenum attachment[] = NULL)
ax::FramebufferObject::AttachTexture	.\framebuffer_object.cc	/^void FramebufferObject::AttachTexture(GLenum tex_target, GLuint tex_id, $/;"	f	class:ax::FramebufferObject	signature:(GLenum tex_target, GLuint tex_id, GLenum attachment, int mip_level, int zslice)
ax::FramebufferObject::AttachTexture	.\framebuffer_object.h	/^  void AttachTexture(GLenum tex_target, GLuint tex_id,$/;"	p	class:ax::FramebufferObject	access:public	signature:(GLenum tex_target, GLuint tex_id, GLenum attachment = GL_COLOR_ATTACHMENT0_EXT, int mip_level = 0, int zslice = 0)
ax::FramebufferObject::AttachTextures	.\framebuffer_object.cc	/^void FramebufferObject::AttachTextures(int tex_count, GLenum tex_target[], $/;"	f	class:ax::FramebufferObject	signature:(int tex_count, GLenum tex_target[], GLuint tex_id[], GLenum attachment[], int mip_level[], int zslice[])
ax::FramebufferObject::AttachTextures	.\framebuffer_object.h	/^  void AttachTextures(int tex_count, GLenum tex_target[], $/;"	p	class:ax::FramebufferObject	access:public	signature:(int tex_count, GLenum tex_target[], GLuint tex_id[], GLenum attachment[] = NULL, int mip_level[] = NULL, int zslice[] = NULL)
ax::FramebufferObject::Bind	.\framebuffer_object.cc	/^void FramebufferObject::Bind() const {$/;"	f	class:ax::FramebufferObject	signature:() const
ax::FramebufferObject::Bind	.\framebuffer_object.h	/^  void Bind() const;$/;"	p	class:ax::FramebufferObject	access:public	signature:() const
ax::FramebufferObject::CheckBufferStatus	.\framebuffer_object.cc	/^bool FramebufferObject::CheckBufferStatus() {$/;"	f	class:ax::FramebufferObject	signature:()
ax::FramebufferObject::CheckBufferStatus	.\framebuffer_object.h	/^  bool CheckBufferStatus();$/;"	p	class:ax::FramebufferObject	access:public	signature:()
ax::FramebufferObject::CheckRedundancy	.\framebuffer_object.cc	/^bool FramebufferObject::CheckRedundancy(GLenum attachment, GLuint tex_id,$/;"	f	class:ax::FramebufferObject	signature:(GLenum attachment, GLuint tex_id, int mip_level, int z_slice)
ax::FramebufferObject::CheckRedundancy	.\framebuffer_object.h	/^  bool CheckRedundancy(GLenum attachment, GLuint tex_id, $/;"	p	class:ax::FramebufferObject	access:protected	signature:(GLenum attachment, GLuint tex_id, int mip_level, int z_slice)
ax::FramebufferObject::Disable	.\framebuffer_object.cc	/^void FramebufferObject::Disable() {$/;"	f	class:ax::FramebufferObject	signature:()
ax::FramebufferObject::Disable	.\framebuffer_object.h	/^  static void Disable();$/;"	p	class:ax::FramebufferObject	access:public	signature:()
ax::FramebufferObject::FramebufferObject	.\framebuffer_object.cc	/^FramebufferObject::FramebufferObject()$/;"	f	class:ax::FramebufferObject	signature:()
ax::FramebufferObject::FramebufferObject	.\framebuffer_object.h	/^  FramebufferObject();$/;"	p	class:ax::FramebufferObject	access:public	signature:()
ax::FramebufferObject::FramebufferTextureND	.\framebuffer_object.cc	/^void FramebufferObject::FramebufferTextureND(GLenum attachment, $/;"	f	class:ax::FramebufferObject	signature:(GLenum attachment, GLenum tex_target, GLuint tex_id, int mip_level, int zslice)
ax::FramebufferObject::FramebufferTextureND	.\framebuffer_object.h	/^  void  FramebufferTextureND(GLenum attachment, GLenum tex_target, $/;"	p	class:ax::FramebufferObject	access:protected	signature:(GLenum attachment, GLenum tex_target, GLuint tex_id, int mip_level, int z_slice)
ax::FramebufferObject::GenerateFboId	.\framebuffer_object.cc	/^GLuint FramebufferObject::GenerateFboId() {$/;"	f	class:ax::FramebufferObject	signature:()
ax::FramebufferObject::GenerateFboId	.\framebuffer_object.h	/^  static GLuint GenerateFboId();$/;"	p	class:ax::FramebufferObject	access:protected	signature:()
ax::FramebufferObject::GetAttachedCubeFace	.\framebuffer_object.cc	/^GLint FramebufferObject::GetAttachedCubeFace(GLenum attachment) {$/;"	f	class:ax::FramebufferObject	signature:(GLenum attachment)
ax::FramebufferObject::GetAttachedCubeFace	.\framebuffer_object.h	/^  GLint  GetAttachedCubeFace(GLenum attachment);$/;"	p	class:ax::FramebufferObject	access:public	signature:(GLenum attachment)
ax::FramebufferObject::GetAttachedId	.\framebuffer_object.cc	/^GLuint FramebufferObject::GetAttachedId(GLenum attachment) {$/;"	f	class:ax::FramebufferObject	signature:(GLenum attachment)
ax::FramebufferObject::GetAttachedId	.\framebuffer_object.h	/^  GLuint GetAttachedId(GLenum attachment);$/;"	p	class:ax::FramebufferObject	access:public	signature:(GLenum attachment)
ax::FramebufferObject::GetAttachedMipLevel	.\framebuffer_object.cc	/^GLint FramebufferObject::GetAttachedMipLevel(GLenum attachment) {$/;"	f	class:ax::FramebufferObject	signature:(GLenum attachment)
ax::FramebufferObject::GetAttachedMipLevel	.\framebuffer_object.h	/^  GLint  GetAttachedMipLevel(GLenum attachment);$/;"	p	class:ax::FramebufferObject	access:public	signature:(GLenum attachment)
ax::FramebufferObject::GetAttachedType	.\framebuffer_object.cc	/^GLenum FramebufferObject::GetAttachedType(GLenum attachment) {$/;"	f	class:ax::FramebufferObject	signature:(GLenum attachment)
ax::FramebufferObject::GetAttachedType	.\framebuffer_object.h	/^  GLenum GetAttachedType(GLenum attachment);$/;"	p	class:ax::FramebufferObject	access:public	signature:(GLenum attachment)
ax::FramebufferObject::GetAttachedZSlice	.\framebuffer_object.cc	/^GLint FramebufferObject::GetAttachedZSlice(GLenum attachment) {$/;"	f	class:ax::FramebufferObject	signature:(GLenum attachment)
ax::FramebufferObject::GetAttachedZSlice	.\framebuffer_object.h	/^  GLint  GetAttachedZSlice(GLenum attachment);$/;"	p	class:ax::FramebufferObject	access:public	signature:(GLenum attachment)
ax::FramebufferObject::GetMaxColorAttachments	.\framebuffer_object.cc	/^GLint FramebufferObject::GetMaxColorAttachments() {$/;"	f	class:ax::FramebufferObject	signature:()
ax::FramebufferObject::GetMaxColorAttachments	.\framebuffer_object.h	/^  static int GetMaxColorAttachments();$/;"	p	class:ax::FramebufferObject	access:public	signature:()
ax::FramebufferObject::GuardedBind	.\framebuffer_object.cc	/^void FramebufferObject::GuardedBind() {$/;"	f	class:ax::FramebufferObject	signature:()
ax::FramebufferObject::GuardedBind	.\framebuffer_object.h	/^  void  GuardedBind();$/;"	p	class:ax::FramebufferObject	access:protected	signature:()
ax::FramebufferObject::GuardedUnbind	.\framebuffer_object.cc	/^void FramebufferObject::GuardedUnbind() {$/;"	f	class:ax::FramebufferObject	signature:()
ax::FramebufferObject::GuardedUnbind	.\framebuffer_object.h	/^  void  GuardedUnbind();$/;"	p	class:ax::FramebufferObject	access:protected	signature:()
ax::FramebufferObject::IsValid	.\framebuffer_object.h	/^  bool IsValid() { return CheckBufferStatus(); }$/;"	f	class:ax::FramebufferObject	access:public	signature:()
ax::FramebufferObject::Unattach	.\framebuffer_object.cc	/^void FramebufferObject::Unattach(GLenum attachment) {$/;"	f	class:ax::FramebufferObject	signature:(GLenum attachment)
ax::FramebufferObject::Unattach	.\framebuffer_object.h	/^  void Unattach(GLenum attachment);$/;"	p	class:ax::FramebufferObject	access:public	signature:(GLenum attachment)
ax::FramebufferObject::UnattachAll	.\framebuffer_object.cc	/^void FramebufferObject::UnattachAll() {$/;"	f	class:ax::FramebufferObject	signature:()
ax::FramebufferObject::UnattachAll	.\framebuffer_object.h	/^  void UnattachAll();$/;"	p	class:ax::FramebufferObject	access:public	signature:()
ax::FramebufferObject::UnattachAllColorAttachement	.\framebuffer_object.cc	/^void FramebufferObject::UnattachAllColorAttachement() {$/;"	f	class:ax::FramebufferObject	signature:()
ax::FramebufferObject::UnattachAllColorAttachement	.\framebuffer_object.h	/^  void UnattachAllColorAttachement();$/;"	p	class:ax::FramebufferObject	access:public	signature:()
ax::FramebufferObject::fbo_id_	.\framebuffer_object.h	/^  GLuint fbo_id_;$/;"	m	class:ax::FramebufferObject	access:private
ax::FramebufferObject::saved_fbo_id_	.\framebuffer_object.h	/^  GLint  saved_fbo_id_;$/;"	m	class:ax::FramebufferObject	access:private
ax::FramebufferObject::~FramebufferObject	.\framebuffer_object.cc	/^FramebufferObject::~FramebufferObject() {$/;"	f	class:ax::FramebufferObject	signature:()
ax::FramebufferObject::~FramebufferObject	.\framebuffer_object.h	/^  ~FramebufferObject();$/;"	p	class:ax::FramebufferObject	access:public	signature:()
ax::GLGroup	.\glmesh.h	/^class GLGroup : public Object {$/;"	c	namespace:ax	inherits:Object
ax::GLGroup::ApplyTransform	.\glmesh.h	/^  virtual void ApplyTransform(const ax::Matrix4x4 &m) { }$/;"	f	class:ax::GLGroup	access:private	signature:(const ax::Matrix4x4 &m)
ax::GLGroup::ComputeBound	.\glmesh.h	/^  virtual ax::AABB ComputeBound(const ax::Matrix4x4 &m) const { $/;"	f	class:ax::GLGroup	access:private	signature:(const ax::Matrix4x4 &m) const
ax::GLGroup::Create	.\glmesh.h	/^  static GLGroupPtr Create(int tri_start, int n_tris) {$/;"	f	class:ax::GLGroup	access:public	signature:(int tri_start, int n_tris)
ax::GLGroup::Draw	.\glmesh.cc	/^void GLGroup::Draw(Options opts) const {$/;"	f	class:ax::GLGroup	signature:(Options opts) const
ax::GLGroup::Draw	.\glmesh.cc	/^void GLGroup::Draw(ProgramGLSLPtr prog, Options opts) const {  $/;"	f	class:ax::GLGroup	signature:(ProgramGLSLPtr prog, Options opts) const
ax::GLGroup::Draw	.\glmesh.cc	/^void GLGroup::Draw(const Scene *s, Options opts) const {  $/;"	f	class:ax::GLGroup	signature:(const Scene *s, Options opts) const
ax::GLGroup::Draw	.\glmesh.h	/^  virtual void Draw(ProgramGLSLPtr prog, Options opts) const;$/;"	p	class:ax::GLGroup	access:public	signature:(ProgramGLSLPtr prog, Options opts) const
ax::GLGroup::Draw	.\glmesh.h	/^  virtual void Draw(const Scene *s, Options opts) const;$/;"	p	class:ax::GLGroup	access:public	signature:(const Scene *s, Options opts) const
ax::GLGroup::Draw	.\glmesh.h	/^  void Draw(Options opts) const;$/;"	p	class:ax::GLGroup	access:private	signature:(Options opts) const
ax::GLGroup::GLGroup	.\glmesh.h	/^  GLGroup(int tri_start, int n_tris) : $/;"	f	class:ax::GLGroup	access:private	signature:(int tri_start, int n_tris)
ax::GLGroup::PreProcess	.\glmesh.h	/^  virtual void PreProcess(Options opts) { }  $/;"	f	class:ax::GLGroup	access:private	signature:(Options opts)
ax::GLGroup::n_tris_	.\glmesh.h	/^  int n_tris_;$/;"	m	class:ax::GLGroup	access:private
ax::GLGroup::tri_start_	.\glmesh.h	/^  int tri_start_;$/;"	m	class:ax::GLGroup	access:private
ax::GLGroupPtr	.\cg_fwd.h	/^typedef std::tr1::shared_ptr<GLGroup> GLGroupPtr;$/;"	t	namespace:ax
ax::GLMaterial	.\glmaterial.h	/^class GLMaterial : public Material {$/;"	c	namespace:ax	inherits:Material
ax::GLMaterial::Enable	.\glmaterial.cc	/^void GLMaterial::Enable(ProgramGLSLPtr prog) const {$/;"	f	class:ax::GLMaterial	signature:(ProgramGLSLPtr prog) const
ax::GLMaterial::Enable	.\glmaterial.cc	/^void GLMaterial::Enable(const Scene *s) const{$/;"	f	class:ax::GLMaterial	signature:(const Scene *s) const
ax::GLMaterial::Enable	.\glmaterial.h	/^  virtual void Enable(ProgramGLSLPtr prog) const;  $/;"	p	class:ax::GLMaterial	access:public	signature:(ProgramGLSLPtr prog) const
ax::GLMaterial::Enable	.\glmaterial.h	/^  virtual void Enable(const Scene *s) const;$/;"	p	class:ax::GLMaterial	access:public	signature:(const Scene *s) const
ax::GLMaterial::GLMaterial	.\glmaterial.cc	/^GLMaterial::GLMaterial(const Colorf &amb, const Colorf &dif, $/;"	f	class:ax::GLMaterial	signature:(const Colorf &amb, const Colorf &dif, const Colorf &spec, float shiny, const char *name)
ax::GLMaterial::GLMaterial	.\glmaterial.cc	/^GLMaterial::GLMaterial(const char *name) : Material(name),$/;"	f	class:ax::GLMaterial	signature:(const char *name)
ax::GLMaterial::GLMaterial	.\glmaterial.cc	/^GLMaterial::GLMaterial(float *amb, float *dif, float *spec, float shiny,$/;"	f	class:ax::GLMaterial	signature:(float *amb, float *dif, float *spec, float shiny, const char *name)
ax::GLMaterial::GLMaterial	.\glmaterial.cc	/^GLMaterial::GLMaterial(int predefined) : Material("") {$/;"	f	class:ax::GLMaterial	signature:(int predefined)
ax::GLMaterial::GLMaterial	.\glmaterial.h	/^  GLMaterial(const Colorf &amb, const Colorf &dif, const Colorf &spec, $/;"	p	class:ax::GLMaterial	access:protected	signature:(const Colorf &amb, const Colorf &dif, const Colorf &spec, float shiny, const char *name = s_unnamed)
ax::GLMaterial::GLMaterial	.\glmaterial.h	/^  GLMaterial(const char *name = s_unnamed);$/;"	p	class:ax::GLMaterial	access:protected	signature:(const char *name = s_unnamed)
ax::GLMaterial::GLMaterial	.\glmaterial.h	/^  GLMaterial(const float *Kd, const float *Ka, const float *Ks, $/;"	p	class:ax::GLMaterial	access:protected	signature:(const float *Kd, const float *Ka, const float *Ks, const float shininess)
ax::GLMaterial::GLMaterial	.\glmaterial.h	/^  GLMaterial(float *amb, float *dif, float *spec, float shiny,$/;"	p	class:ax::GLMaterial	access:protected	signature:(float *amb, float *dif, float *spec, float shiny, const char *name = s_unnamed)
ax::GLMaterial::GLMaterial	.\glmaterial.h	/^  GLMaterial(int predefined);$/;"	p	class:ax::GLMaterial	access:protected	signature:(int predefined)
ax::GLMaterial::ambient	.\glmaterial.h	/^  const Colorf &ambient() const { return ambient_; }$/;"	f	class:ax::GLMaterial	access:public	signature:() const
ax::GLMaterial::ambient_	.\glmaterial.h	/^  Colorf ambient_, diffuse_, specular_, emission_;$/;"	m	class:ax::GLMaterial	access:private
ax::GLMaterial::diffuse	.\glmaterial.h	/^  const Colorf &diffuse() const { return diffuse_; }$/;"	f	class:ax::GLMaterial	access:public	signature:() const
ax::GLMaterial::diffuse_	.\glmaterial.h	/^  Colorf ambient_, diffuse_, specular_, emission_;$/;"	m	class:ax::GLMaterial	access:private
ax::GLMaterial::emission	.\glmaterial.h	/^  const Colorf &emission() const { return emission_; }$/;"	f	class:ax::GLMaterial	access:public	signature:() const
ax::GLMaterial::emission_	.\glmaterial.h	/^  Colorf ambient_, diffuse_, specular_, emission_;$/;"	m	class:ax::GLMaterial	access:private
ax::GLMaterial::set_ambient	.\glmaterial.h	/^  void set_ambient(const Colorf &c) { ambient_ = c; }$/;"	f	class:ax::GLMaterial	access:public	signature:(const Colorf &c)
ax::GLMaterial::set_diffuse	.\glmaterial.h	/^  void set_diffuse(const Colorf &c) { diffuse_ = c; }$/;"	f	class:ax::GLMaterial	access:public	signature:(const Colorf &c)
ax::GLMaterial::set_emission	.\glmaterial.h	/^  void set_emission(const Colorf &c) { emission_ = c; }$/;"	f	class:ax::GLMaterial	access:public	signature:(const Colorf &c)
ax::GLMaterial::set_shininess	.\glmaterial.h	/^  void set_shininess(float s) { shininess_ = s; }$/;"	f	class:ax::GLMaterial	access:public	signature:(float s)
ax::GLMaterial::set_specular	.\glmaterial.h	/^  void set_specular(const Colorf &c) { specular_ = c; }$/;"	f	class:ax::GLMaterial	access:public	signature:(const Colorf &c)
ax::GLMaterial::shininess	.\glmaterial.h	/^  float shininess() const { return shininess_; }$/;"	f	class:ax::GLMaterial	access:public	signature:() const
ax::GLMaterial::shininess_	.\glmaterial.h	/^  float shininess_;$/;"	m	class:ax::GLMaterial	access:private
ax::GLMaterial::specular	.\glmaterial.h	/^  const Colorf &specular() const { return specular_; }$/;"	f	class:ax::GLMaterial	access:public	signature:() const
ax::GLMaterial::specular_	.\glmaterial.h	/^  Colorf ambient_, diffuse_, specular_, emission_;$/;"	m	class:ax::GLMaterial	access:private
ax::GLMaterialPtr	.\cg_fwd.h	/^typedef std::tr1::shared_ptr<GLMaterial> GLMaterialPtr;$/;"	t	namespace:ax
ax::GLMesh	.\glmesh.h	/^class GLMesh : public Object {$/;"	c	namespace:ax	inherits:Object
ax::GLMesh::Add	.\glmesh.h	/^  void Add(GLGroupPtr g) { objs_.push_back(g); }$/;"	f	class:ax::GLMesh	access:public	signature:(GLGroupPtr g)
ax::GLMesh::ApplyTransform	.\glmesh.cc	/^void GLMesh::ApplyTransform(const ax::Matrix4x4 &m) {$/;"	f	class:ax::GLMesh	signature:(const ax::Matrix4x4 &m)
ax::GLMesh::ApplyTransform	.\glmesh.h	/^  virtual void ApplyTransform(const ax::Matrix4x4 &m);$/;"	p	class:ax::GLMesh	access:public	signature:(const ax::Matrix4x4 &m)
ax::GLMesh::BeginDraw	.\glmesh.cc	/^bool GLMesh::BeginDraw(Options opts) const {$/;"	f	class:ax::GLMesh	signature:(Options opts) const
ax::GLMesh::BeginDraw	.\glmesh.h	/^  bool BeginDraw(Options opts) const;$/;"	p	class:ax::GLMesh	access:private	signature:(Options opts) const
ax::GLMesh::ComputeBound	.\glmesh.cc	/^ax::AABB GLMesh::ComputeBound(const ax::Matrix4x4 &m) const {$/;"	f	class:ax::GLMesh	signature:(const ax::Matrix4x4 &m) const
ax::GLMesh::ComputeBound	.\glmesh.h	/^  virtual ax::AABB ComputeBound(const ax::Matrix4x4 &m) const;$/;"	p	class:ax::GLMesh	access:public	signature:(const ax::Matrix4x4 &m) const
ax::GLMesh::Create	.\glmesh.h	/^  static GLMeshPtr Create(ax::TriMeshPtr mesh, bool as_whole = false) {$/;"	f	class:ax::GLMesh	access:public	signature:(ax::TriMeshPtr mesh, bool as_whole = false)
ax::GLMesh::Draw	.\glmesh.cc	/^void GLMesh::Draw(ProgramGLSLPtr prog, Options opts) const {$/;"	f	class:ax::GLMesh	signature:(ProgramGLSLPtr prog, Options opts) const
ax::GLMesh::Draw	.\glmesh.cc	/^void GLMesh::Draw(const Scene *s, Options opts) const {$/;"	f	class:ax::GLMesh	signature:(const Scene *s, Options opts) const
ax::GLMesh::Draw	.\glmesh.h	/^  virtual void Draw(ProgramGLSLPtr prog, Options opts) const;$/;"	p	class:ax::GLMesh	access:public	signature:(ProgramGLSLPtr prog, Options opts) const
ax::GLMesh::Draw	.\glmesh.h	/^  virtual void Draw(const Scene *s, Options opts) const;$/;"	p	class:ax::GLMesh	access:public	signature:(const Scene *s, Options opts) const
ax::GLMesh::EndDraw	.\glmesh.cc	/^void GLMesh::EndDraw(Options opts) const {$/;"	f	class:ax::GLMesh	signature:(Options opts) const
ax::GLMesh::EndDraw	.\glmesh.h	/^  void EndDraw(Options opts) const;$/;"	p	class:ax::GLMesh	access:private	signature:(Options opts) const
ax::GLMesh::GLMesh	.\glmesh.h	/^  GLMesh(ax::TriMeshPtr mesh) : mesh_(mesh), idx_buffer_(GL_ELEMENT_ARRAY_BUFFER), adj_idx_buffer_(GL_ELEMENT_ARRAY_BUFFER) { }$/;"	f	class:ax::GLMesh	access:private	signature:(ax::TriMeshPtr mesh)
ax::GLMesh::LoadToVBO	.\glmesh.cc	/^void GLMesh::LoadToVBO(Options opts) {$/;"	f	class:ax::GLMesh	signature:(Options opts)
ax::GLMesh::LoadToVBO	.\glmesh.h	/^  void LoadToVBO(Options opts);  $/;"	p	class:ax::GLMesh	access:private	signature:(Options opts)
ax::GLMesh::ObjectList	.\glmesh.h	/^  typedef std::vector<GLGroupPtr> ObjectList;$/;"	t	class:ax::GLMesh	access:private
ax::GLMesh::PreProcess	.\glmesh.cc	/^void GLMesh::PreProcess(Options opts) {$/;"	f	class:ax::GLMesh	signature:(Options opts)
ax::GLMesh::PreProcess	.\glmesh.h	/^  virtual void PreProcess(Options opts);$/;"	p	class:ax::GLMesh	access:public	signature:(Options opts)
ax::GLMesh::adj_idx_buffer_	.\glmesh.h	/^  ax::ArrayBufferGL adj_idx_buffer_;$/;"	m	class:ax::GLMesh	access:private
ax::GLMesh::idx_buffer_	.\glmesh.h	/^  ax::ArrayBufferGL idx_buffer_;$/;"	m	class:ax::GLMesh	access:private
ax::GLMesh::mesh_	.\glmesh.h	/^  ax::TriMeshPtr mesh_;$/;"	m	class:ax::GLMesh	access:private
ax::GLMesh::normal_slot_	.\glmesh.h	/^  int normal_slot_;$/;"	m	class:ax::GLMesh	access:private
ax::GLMesh::objs_	.\glmesh.h	/^  ObjectList objs_;$/;"	m	class:ax::GLMesh	access:private
ax::GLMesh::tcoord_slot_	.\glmesh.h	/^  int tcoord_slot_;$/;"	m	class:ax::GLMesh	access:private
ax::GLMesh::tri_mesh	.\glmesh.h	/^  ax::TriMeshPtr tri_mesh() const { return this->mesh_; }$/;"	f	class:ax::GLMesh	access:public	signature:() const
ax::GLMesh::vert_buffer_	.\glmesh.h	/^  ax::ArrayBufferGL vert_buffer_;$/;"	m	class:ax::GLMesh	access:private
ax::GLMesh::vert_vbo	.\glmesh.h	/^  uint32 vert_vbo() const { return this->vert_buffer_.id(); }$/;"	f	class:ax::GLMesh	access:public	signature:() const
ax::GLMesh::vertex_slot_	.\glmesh.h	/^  int vertex_slot_;$/;"	m	class:ax::GLMesh	access:private
ax::GLMesh::~GLMesh	.\glmesh.cc	/^GLMesh::~GLMesh() { }$/;"	f	class:ax::GLMesh	signature:()
ax::GLMesh::~GLMesh	.\glmesh.h	/^  ~GLMesh();$/;"	p	class:ax::GLMesh	access:public	signature:()
ax::GLMeshPtr	.\cg_fwd.h	/^typedef std::tr1::shared_ptr<GLMesh> GLMeshPtr;$/;"	t	namespace:ax
ax::GLMmodelPtr	.\trimesh_glmmodel.h	/^typedef std::tr1::shared_ptr<GLMmodel> GLMmodelPtr;$/;"	t	namespace:ax
ax::GLObject	.\gl_object.h	/^class GLObject {$/;"	c	namespace:ax
ax::GLObject::CheckResult	.\gl_object.cc	/^bool GLObject::CheckResult(const std::string &method) const {$/;"	f	class:ax::GLObject	signature:(const std::string &method) const
ax::GLObject::CheckResult	.\gl_object.h	/^  bool CheckResult(const std::string &method) const;$/;"	p	class:ax::GLObject	access:protected	signature:(const std::string &method) const
ax::GLObject::DISABLE_COPY_AND_ASSIGN	.\gl_object.h	/^  DISABLE_COPY_AND_ASSIGN(GLObject);$/;"	p	class:ax::GLObject	access:protected	signature:(GLObject)
ax::GLObject::GLObject	.\gl_object.h	/^  GLObject(const std::string &name) : name_(name), id_(0) { }$/;"	f	class:ax::GLObject	access:protected	signature:(const std::string &name)
ax::GLObject::id	.\gl_object.h	/^  GLuint id() const { return id_; }$/;"	f	class:ax::GLObject	access:public	signature:() const
ax::GLObject::id_	.\gl_object.h	/^  GLuint id_;$/;"	m	class:ax::GLObject	access:protected
ax::GLObject::name	.\gl_object.h	/^  const std::string &name() const { return name_; }$/;"	f	class:ax::GLObject	access:public	signature:() const
ax::GLObject::name_	.\gl_object.h	/^  const std::string name_;$/;"	m	class:ax::GLObject	access:protected
ax::GLObject::~GLObject	.\gl_object.h	/^  virtual ~GLObject() { id_ = 0; }$/;"	f	class:ax::GLObject	access:public	signature:()
ax::GLSLMaterial	.\glslmaterial.h	/^class GLSLMaterial : public Material {$/;"	c	namespace:ax	inherits:Material
ax::GLSLMaterial::Bind	.\glslmaterial.h	/^  void Bind(const N &names, const V &vals, F f) {$/;"	f	class:ax::GLSLMaterial	access:private	signature:(const N &names, const V &vals, F f)
ax::GLSLMaterial::BindConst	.\glslmaterial.h	/^  void BindConst(const char *name, float val) {$/;"	f	class:ax::GLSLMaterial	access:private	signature:(const char *name, float val)
ax::GLSLMaterial::BindConstVec3	.\glslmaterial.h	/^  void BindConstVec3(const char *name, const ax::Vector3 &val) {$/;"	f	class:ax::GLSLMaterial	access:private	signature:(const char *name, const ax::Vector3 &val)
ax::GLSLMaterial::BindConstVec4	.\glslmaterial.h	/^  void BindConstVec4(const char *name, const ax::Vector4 &val) {$/;"	f	class:ax::GLSLMaterial	access:private	signature:(const char *name, const ax::Vector4 &val)
ax::GLSLMaterial::BindFragSubroutine	.\glslmaterial.h	/^  void BindFragSubroutine(const char *name) {$/;"	f	class:ax::GLSLMaterial	access:private	signature:(const char *name)
ax::GLSLMaterial::BindTexture	.\glslmaterial.h	/^  void BindTexture(const char *name, const Texture2DPtr &tex) {$/;"	f	class:ax::GLSLMaterial	access:private	signature:(const char *name, const Texture2DPtr &tex)
ax::GLSLMaterial::BindVertSubroutine	.\glslmaterial.h	/^  void BindVertSubroutine(const char *name) {$/;"	f	class:ax::GLSLMaterial	access:private	signature:(const char *name)
ax::GLSLMaterial::Enable	.\glslmaterial.cc	/^void GLSLMaterial::Enable(ProgramGLSLPtr prog) const {  $/;"	f	class:ax::GLSLMaterial	signature:(ProgramGLSLPtr prog) const
ax::GLSLMaterial::Enable	.\glslmaterial.cc	/^void GLSLMaterial::Enable(const Scene *s) const {$/;"	f	class:ax::GLSLMaterial	signature:(const Scene *s) const
ax::GLSLMaterial::Enable	.\glslmaterial.h	/^  virtual void Enable(ProgramGLSLPtr prog) const;$/;"	p	class:ax::GLSLMaterial	access:public	signature:(ProgramGLSLPtr prog) const
ax::GLSLMaterial::Enable	.\glslmaterial.h	/^  virtual void Enable(const Scene *s) const;$/;"	p	class:ax::GLSLMaterial	access:public	signature:(const Scene *s) const
ax::GLSLMaterial::GLSLMaterial	.\glslmaterial.h	/^  GLSLMaterial() { }$/;"	f	class:ax::GLSLMaterial	access:protected	signature:()
ax::GLSLMaterial::HasTexture	.\glslmaterial.cc	/^bool GLSLMaterial::HasTexture() const {$/;"	f	class:ax::GLSLMaterial	signature:() const
ax::GLSLMaterial::HasTexture	.\glslmaterial.h	/^  virtual bool HasTexture() const;$/;"	p	class:ax::GLSLMaterial	access:public	signature:() const
ax::GLSLMaterial::VarNames	.\glslmaterial.h	/^  typedef std::vector<std::string> VarNames;$/;"	t	class:ax::GLSLMaterial	access:private
ax::GLSLMaterial::bind_const3_names_	.\glslmaterial.h	/^  VarNames bind_const3_names_;$/;"	m	class:ax::GLSLMaterial	access:private
ax::GLSLMaterial::bind_const3_vals_	.\glslmaterial.h	/^  std::vector<ax::Vector3> bind_const3_vals_;$/;"	m	class:ax::GLSLMaterial	access:private
ax::GLSLMaterial::bind_const4_names_	.\glslmaterial.h	/^  VarNames bind_const4_names_;$/;"	m	class:ax::GLSLMaterial	access:private
ax::GLSLMaterial::bind_const4_vals_	.\glslmaterial.h	/^  std::vector<ax::Vector4> bind_const4_vals_;$/;"	m	class:ax::GLSLMaterial	access:private
ax::GLSLMaterial::bind_float_names_	.\glslmaterial.h	/^  VarNames bind_float_names_;$/;"	m	class:ax::GLSLMaterial	access:private
ax::GLSLMaterial::bind_float_vals_	.\glslmaterial.h	/^  std::vector<float> bind_float_vals_;$/;"	m	class:ax::GLSLMaterial	access:private
ax::GLSLMaterial::bind_tex_names_	.\glslmaterial.h	/^  VarNames bind_tex_names_;  $/;"	m	class:ax::GLSLMaterial	access:private
ax::GLSLMaterial::bind_texs_	.\glslmaterial.h	/^  std::vector<Texture2DPtr> bind_texs_;$/;"	m	class:ax::GLSLMaterial	access:private
ax::GLSLMaterial::frag_subroutine_	.\glslmaterial.h	/^  std::string frag_subroutine_;$/;"	m	class:ax::GLSLMaterial	access:private
ax::GLSLMaterial::vert_subroutine_	.\glslmaterial.h	/^  std::string vert_subroutine_;$/;"	m	class:ax::GLSLMaterial	access:private
ax::GLSLMaterialPtr	.\cg_fwd.h	/^typedef std::tr1::shared_ptr<GLSLMaterial> GLSLMaterialPtr;$/;"	t	namespace:ax
ax::GPUTimer	.\utils.h	/^class GPUTimer : public ax::GLObject {$/;"	c	namespace:ax	inherits:ax::GLObject
ax::GPUTimer::Begin	.\utils.h	/^  void Begin() {$/;"	f	class:ax::GPUTimer	access:public	signature:()
ax::GPUTimer::Create	.\utils.h	/^  static ax::GPUTimerPtr Create(const std::string &name) {$/;"	f	class:ax::GPUTimer	access:public	signature:(const std::string &name)
ax::GPUTimer::End	.\utils.h	/^  double End() {$/;"	f	class:ax::GPUTimer	access:public	signature:()
ax::GPUTimer::End	.\utils.h	/^  double End(const std::string &info) {$/;"	f	class:ax::GPUTimer	access:public	signature:(const std::string &info)
ax::GPUTimer::GPUTimer	.\utils.h	/^  GPUTimer(const std::string &name) : GLObject(name) {$/;"	f	class:ax::GPUTimer	access:protected	signature:(const std::string &name)
ax::GPUTimer::target_	.\utils.h	/^  GLuint target_;  $/;"	m	class:ax::GPUTimer	access:protected
ax::GPUTimer::~GPUTimer	.\utils.h	/^  ~GPUTimer() { glDeleteQueries(1, &this->id_); }$/;"	f	class:ax::GPUTimer	access:public	signature:()
ax::GPUTimerPtr	.\utils.h	/^typedef std::tr1::shared_ptr<GPUTimer> GPUTimerPtr;$/;"	t	namespace:ax
ax::GetGPUPtr	.\gl_buffer.cc	/^GLuint64 GetGPUPtr(uint32 id, uint32 access, uint32 target) {$/;"	f	namespace:ax	signature:(uint32 id, uint32 access, uint32 target)
ax::GetGPUPtr	.\gl_buffer.h	/^GLuint64 GetGPUPtr(uint32 id, uint32 access, uint32 target=GL_ARRAY_BUFFER);$/;"	p	namespace:ax	signature:(uint32 id, uint32 access, uint32 target=GL_ARRAY_BUFFER)
ax::GetNormalIdx	.\glmesh-loader.cc	/^inline size_t GetNormalIdx(const GLMmodel *model, size_t tri, size_t vidx) {$/;"	f	namespace:ax	signature:(const GLMmodel *model, size_t tri, size_t vidx)
ax::GetTexcoordIdx	.\glmesh-loader.cc	/^inline size_t GetTexcoordIdx(const GLMmodel *model, size_t tri, size_t vidx) {$/;"	f	namespace:ax	signature:(const GLMmodel *model, size_t tri, size_t vidx)
ax::GetVertexIdx	.\glmesh-loader.cc	/^inline size_t GetVertexIdx(const GLMmodel *model, size_t tri, size_t vidx) {$/;"	f	namespace:ax	signature:(const GLMmodel *model, size_t tri, size_t vidx)
ax::Group	.\group.h	/^class Group : public Object {$/;"	c	namespace:ax	inherits:Object
ax::Group::Add	.\group.h	/^  void Add(ObjectPtr obj) { if (obj != NULL) objs_.push_back(obj); }$/;"	f	class:ax::Group	access:public	signature:(ObjectPtr obj)
ax::Group::ApplyTransform	.\group.cc	/^void Group::ApplyTransform(const ax::Matrix4x4 &m) {  $/;"	f	class:ax::Group	signature:(const ax::Matrix4x4 &m)
ax::Group::ApplyTransform	.\group.h	/^  virtual void ApplyTransform(const ax::Matrix4x4 &m);$/;"	p	class:ax::Group	access:protected	signature:(const ax::Matrix4x4 &m)
ax::Group::ComputeBound	.\group.cc	/^ax::AABB Group::ComputeBound(const ax::Matrix4x4 &m) const {$/;"	f	class:ax::Group	signature:(const ax::Matrix4x4 &m) const
ax::Group::ComputeBound	.\group.h	/^  virtual ax::AABB ComputeBound(const ax::Matrix4x4 &m) const;$/;"	p	class:ax::Group	access:public	signature:(const ax::Matrix4x4 &m) const
ax::Group::Draw	.\group.cc	/^void Group::Draw(ProgramGLSLPtr prog, Options opts) const {$/;"	f	class:ax::Group	signature:(ProgramGLSLPtr prog, Options opts) const
ax::Group::Draw	.\group.cc	/^void Group::Draw(const Scene *s, Options opts) const {$/;"	f	class:ax::Group	signature:(const Scene *s, Options opts) const
ax::Group::Draw	.\group.h	/^  void Draw(ProgramGLSLPtr prog, Options opts) const;$/;"	p	class:ax::Group	access:public	signature:(ProgramGLSLPtr prog, Options opts) const
ax::Group::Draw	.\group.h	/^  void Draw(const Scene *s, Options opts) const;$/;"	p	class:ax::Group	access:public	signature:(const Scene *s, Options opts) const
ax::Group::Group	.\group.h	/^  Group() { }$/;"	f	class:ax::Group	access:protected	signature:()
ax::Group::ObjectList	.\group.h	/^  typedef std::vector<ObjectPtr> ObjectList;$/;"	t	class:ax::Group	access:private
ax::Group::PreProcess	.\group.cc	/^void Group::PreProcess(Options opts) {$/;"	f	class:ax::Group	signature:(Options opts)
ax::Group::PreProcess	.\group.h	/^  virtual void PreProcess(Options opts);$/;"	p	class:ax::Group	access:public	signature:(Options opts)
ax::Group::object	.\group.h	/^  ObjectPtr object(int i) const { return this->objs_[i]; }$/;"	f	class:ax::Group	access:public	signature:(int i) const
ax::Group::objs_	.\group.h	/^  ObjectList objs_;$/;"	m	class:ax::Group	access:private
ax::Group::~Group	.\group.h	/^  ~Group() { }$/;"	f	class:ax::Group	access:public	signature:()
ax::GroupPtr	.\cg_fwd.h	/^typedef std::tr1::shared_ptr<Group> GroupPtr;$/;"	t	namespace:ax
ax::Idxs	.\glmesh-loader.cc	/^typedef List<size_t> Idxs;$/;"	t	namespace:ax	file:
ax::Image	.\image.h	/^class Image {$/;"	c	namespace:ax
ax::Image::Create	.\image.h	/^  static ImagePtr Create(int w, int h, int format, int type, char *data) {$/;"	f	class:ax::Image	access:public	signature:(int w, int h, int format, int type, char *data)
ax::Image::DISABLE_COPY_AND_ASSIGN	.\image.h	/^  DISABLE_COPY_AND_ASSIGN(Image);$/;"	p	class:ax::Image	access:private	signature:(Image)
ax::Image::Image	.\image.h	/^  Image() : width_(0), height_(0), format_(0), type_(0), data_(0) { }$/;"	f	class:ax::Image	access:public	signature:()
ax::Image::Image	.\image.h	/^  Image(int w, int h, int format, int type, char *data) $/;"	f	class:ax::Image	access:private	signature:(int w, int h, int format, int type, char *data)
ax::Image::Load	.\image.cc	/^bool Image::Load(const char *filename) {  $/;"	f	class:ax::Image	signature:(const char *filename)
ax::Image::Load	.\image.h	/^  bool Load(const char *filename);$/;"	p	class:ax::Image	access:public	signature:(const char *filename)
ax::Image::Release	.\image.h	/^  void Release() {$/;"	f	class:ax::Image	access:private	signature:()
ax::Image::data	.\image.h	/^  const char *data() const { return data_; }$/;"	f	class:ax::Image	access:public	signature:() const
ax::Image::data_	.\image.h	/^  char *data_;$/;"	m	class:ax::Image	access:private
ax::Image::format	.\image.h	/^  int format() const { return format_; }$/;"	f	class:ax::Image	access:public	signature:() const
ax::Image::format_	.\image.h	/^  int format_;$/;"	m	class:ax::Image	access:private
ax::Image::height	.\image.h	/^  int height() const { return height_; }$/;"	f	class:ax::Image	access:public	signature:() const
ax::Image::height_	.\image.h	/^  int width_,height_;$/;"	m	class:ax::Image	access:private
ax::Image::type	.\image.h	/^  int type() const { return type_; }$/;"	f	class:ax::Image	access:public	signature:() const
ax::Image::type_	.\image.h	/^  int type_;$/;"	m	class:ax::Image	access:private
ax::Image::width	.\image.h	/^  int width() const { return width_; }$/;"	f	class:ax::Image	access:public	signature:() const
ax::Image::width_	.\image.h	/^  int width_,height_;$/;"	m	class:ax::Image	access:private
ax::Image::~Image	.\image.h	/^  ~Image() { this->Release(); }$/;"	f	class:ax::Image	access:public	signature:()
ax::ImagePtr	.\cg_fwd.h	/^typedef std::tr1::shared_ptr<Image> ImagePtr;$/;"	t	namespace:ax
ax::ImageTextureGL	.\image_texture_gl.h	/^class ImageTextureGL {$/;"	c	namespace:ax
ax::ImageTextureGL::BeginInitialize	.\image_texture_gl.h	/^  bool BeginInitialize();$/;"	p	class:ax::ImageTextureGL	access:private	signature:()
ax::ImageTextureGL::Bind	.\image_texture_gl.h	/^  void Bind() const;$/;"	p	class:ax::ImageTextureGL	access:public	signature:() const
ax::ImageTextureGL::Disable	.\image_texture_gl.h	/^  void Disable() const;$/;"	p	class:ax::ImageTextureGL	access:public	signature:() const
ax::ImageTextureGL::Enable	.\image_texture_gl.h	/^  void Enable() const;$/;"	p	class:ax::ImageTextureGL	access:public	signature:() const
ax::ImageTextureGL::GenerateMipmap	.\image_texture_gl.h	/^  void GenerateMipmap();$/;"	p	class:ax::ImageTextureGL	access:public	signature:()
ax::ImageTextureGL::ImageTextureGL	.\image_texture_gl.h	/^  ImageTextureGL();$/;"	p	class:ax::ImageTextureGL	access:public	signature:()
ax::ImageTextureGL::ImageTextureGL	.\image_texture_gl.h	/^  ImageTextureGL(uint32 target);$/;"	p	class:ax::ImageTextureGL	access:public	signature:(uint32 target)
ax::ImageTextureGL::Initialize	.\image_texture_gl.h	/^  bool Initialize(const Image &image, uint32 internal_format,$/;"	p	class:ax::ImageTextureGL	access:public	signature:(const Image &image, uint32 internal_format, int opts = kUseDefaultParameters)
ax::ImageTextureGL::Initialize	.\image_texture_gl.h	/^  bool Initialize(int width, int height, uint32 internal_format, $/;"	p	class:ax::ImageTextureGL	access:public	signature:(int width, int height, uint32 internal_format, int opts = kUseDefaultParameters, void *data = NULL)
ax::ImageTextureGL::Release	.\image_texture_gl.h	/^  void Release();$/;"	p	class:ax::ImageTextureGL	access:private	signature:()
ax::ImageTextureGL::Save	.\image_texture_gl.h	/^  void Save(const char* filename, const int level = 0) const;$/;"	p	class:ax::ImageTextureGL	access:public	signature:(const char* filename, const int level = 0) const
ax::ImageTextureGL::SetDefaultParameters	.\image_texture_gl.h	/^  void SetDefaultParameters();$/;"	p	class:ax::ImageTextureGL	access:public	signature:()
ax::ImageTextureGL::SetParameter	.\image_texture_gl.h	/^  void SetParameter(uint32 name, float *val);$/;"	p	class:ax::ImageTextureGL	access:public	signature:(uint32 name, float *val)
ax::ImageTextureGL::SetParameter	.\image_texture_gl.h	/^  void SetParameter(uint32 name, float val);$/;"	p	class:ax::ImageTextureGL	access:public	signature:(uint32 name, float val)
ax::ImageTextureGL::SetParameter	.\image_texture_gl.h	/^  void SetParameter(uint32 name, int32 *val);$/;"	p	class:ax::ImageTextureGL	access:public	signature:(uint32 name, int32 *val)
ax::ImageTextureGL::SetParameter	.\image_texture_gl.h	/^  void SetParameter(uint32 name, int32 val);$/;"	p	class:ax::ImageTextureGL	access:public	signature:(uint32 name, int32 val)
ax::ImageTextureGL::Unbind	.\image_texture_gl.h	/^  void Unbind() const;$/;"	p	class:ax::ImageTextureGL	access:public	signature:() const
ax::ImageTextureGL::height	.\image_texture_gl.h	/^  int height() const { return height_; }$/;"	f	class:ax::ImageTextureGL	access:public	signature:() const
ax::ImageTextureGL::height_	.\image_texture_gl.h	/^  int width_, height_;$/;"	m	class:ax::ImageTextureGL	access:private
ax::ImageTextureGL::is_valid	.\image_texture_gl.h	/^  bool is_valid() const { return 0 != tex_id_; }$/;"	f	class:ax::ImageTextureGL	access:public	signature:() const
ax::ImageTextureGL::target	.\image_texture_gl.h	/^  uint32 target() const { return target_; }$/;"	f	class:ax::ImageTextureGL	access:public	signature:() const
ax::ImageTextureGL::target_	.\image_texture_gl.h	/^  uint32 target_;$/;"	m	class:ax::ImageTextureGL	access:private
ax::ImageTextureGL::tex_id	.\image_texture_gl.h	/^  uint32 tex_id() const { return tex_id_; }$/;"	f	class:ax::ImageTextureGL	access:public	signature:() const
ax::ImageTextureGL::tex_id_	.\image_texture_gl.h	/^  uint32 tex_id_;$/;"	m	class:ax::ImageTextureGL	access:private
ax::ImageTextureGL::width	.\image_texture_gl.h	/^  int width() const { return width_; }$/;"	f	class:ax::ImageTextureGL	access:public	signature:() const
ax::ImageTextureGL::width_	.\image_texture_gl.h	/^  int width_, height_;$/;"	m	class:ax::ImageTextureGL	access:private
ax::ImageTextureGL::~ImageTextureGL	.\image_texture_gl.h	/^  ~ImageTextureGL();$/;"	p	class:ax::ImageTextureGL	access:public	signature:()
ax::ImageTextureGLOptions	.\image_texture_gl.h	/^enum ImageTextureGLOptions {$/;"	g	namespace:ax
ax::IntVarMap	.\scene.h	/^typedef std::map<std::string, int> IntVarMap;$/;"	t	namespace:ax
ax::InvalidVar	.\program_glsl.h	/^inline bool InvalidVar(const int var) { return var < 0; }$/;"	f	namespace:ax	signature:(const int var)
ax::IsBlankOrComment	.\parser.h	/^inline bool IsBlankOrComment(const char *str) { $/;"	f	namespace:ax	signature:(const char *str)
ax::LineToken	.\parser.h	/^class LineToken {$/;"	c	namespace:ax
ax::LineToken::Equals	.\parser.h	/^  bool Equals(const char *str) const {$/;"	f	class:ax::LineToken	access:public	signature:(const char *str) const
ax::LineToken::Equals	.\parser.h	/^  bool Equals(const std::string &str) const {$/;"	f	class:ax::LineToken	access:public	signature:(const std::string &str) const
ax::LineToken::Extract	.\parser.h	/^  const char *Extract(const char *ptr) {$/;"	f	class:ax::LineToken	access:public	signature:(const char *ptr)
ax::LineToken::LineToken	.\parser.h	/^  LineToken() { token_[0] = '\\0'; }$/;"	f	class:ax::LineToken	access:public	signature:()
ax::LineToken::ptr	.\parser.h	/^  const char *ptr() const { return token_; }$/;"	f	class:ax::LineToken	access:public	signature:() const
ax::LineToken::token_	.\parser.h	/^  char token_[256];$/;"	m	class:ax::LineToken	access:private
ax::LoadGLMesh	.\glmesh-loader.cc	/^ObjectPtr LoadGLMesh(Scene *s, const std::string &filename, Options opts) {$/;"	f	namespace:ax	signature:(Scene *s, const std::string &filename, Options opts)
ax::LoadGLMesh	.\glmesh.h	/^ObjectPtr LoadGLMesh(Scene *s, const std::string &filename, Options opts);$/;"	p	namespace:ax	signature:(Scene *s, const std::string &filename, Options opts)
ax::MacroList	.\shader_object.h	/^typedef std::hash_map<std::string, std::string> MacroList;$/;"	t	namespace:ax
ax::MakeFullScreenQuad	.\model_gl.cc	/^GLuint MakeFullScreenQuad() {$/;"	f	namespace:ax	signature:()
ax::MakeFullScreenQuad	.\utils.h	/^GLuint MakeFullScreenQuad();$/;"	p	namespace:ax	signature:()
ax::Material	.\material.h	/^class Material {$/;"	c	namespace:ax
ax::Material::DISABLE_COPY_AND_ASSIGN	.\material.h	/^  DISABLE_COPY_AND_ASSIGN(Material);$/;"	p	class:ax::Material	access:private	signature:(Material)
ax::Material::Disable	.\material.h	/^  virtual void Disable() const { }$/;"	f	class:ax::Material	access:public	signature:() const
ax::Material::Enable	.\material.h	/^  virtual void Enable(ProgramGLSLPtr prog) const { }$/;"	f	class:ax::Material	access:public	signature:(ProgramGLSLPtr prog) const
ax::Material::Enable	.\material.h	/^  virtual void Enable(const Scene *s) const { }$/;"	f	class:ax::Material	access:public	signature:(const Scene *s) const
ax::Material::HasTexture	.\material.h	/^  virtual bool HasTexture() const { return false; }$/;"	f	class:ax::Material	access:public	signature:() const
ax::Material::Material	.\material.h	/^  Material() : name_(s_unnamed) { }$/;"	f	class:ax::Material	access:protected	signature:()
ax::Material::Material	.\material.h	/^  Material(const char *name) : name_(name) { }$/;"	f	class:ax::Material	access:protected	signature:(const char *name)
ax::Material::kNullMatl	.\material.cc	/^const MaterialPtr Material::kNullMatl = $/;"	m	class:ax::Material	file:
ax::Material::kNullMatl	.\material.h	/^  static const MaterialPtr kNullMatl;$/;"	m	class:ax::Material	access:public
ax::Material::name	.\material.h	/^  const std::string &name() const { return name_; }$/;"	f	class:ax::Material	access:public	signature:() const
ax::Material::name_	.\material.h	/^  std::string name_;$/;"	m	class:ax::Material	access:private
ax::Material::s_unnamed	.\material.cc	/^const char *Material::s_unnamed = "<Unnamed Material>";$/;"	m	class:ax::Material	file:
ax::Material::s_unnamed	.\material.h	/^  static const char *s_unnamed;$/;"	m	class:ax::Material	access:protected
ax::Material::texture	.\material.h	/^  virtual Texture2DPtr texture() const { $/;"	f	class:ax::Material	access:public	signature:() const
ax::Material::~Material	.\material.h	/^  virtual ~Material() { }$/;"	f	class:ax::Material	access:public	signature:()
ax::MaterialFactory	.\material-factory.h	/^class MaterialFactory {$/;"	c	namespace:ax
ax::MaterialFactory::CreateGLMaterial	.\material-factory.cc	/^GLMaterialPtr MaterialFactory::CreateGLMaterial() {$/;"	f	class:ax::MaterialFactory	signature:()
ax::MaterialFactory::CreateGLMaterial	.\material-factory.cc	/^MaterialPtr MaterialFactory::CreateGLMaterial($/;"	f	class:ax::MaterialFactory	signature:( const char *name, FILE *fp)
ax::MaterialFactory::CreateGLMaterial	.\material-factory.h	/^  static GLMaterialPtr CreateGLMaterial();$/;"	p	class:ax::MaterialFactory	access:public	signature:()
ax::MaterialFactory::CreateGLMaterial	.\material-factory.h	/^  static MaterialPtr CreateGLMaterial(const char *name, FILE *fp);$/;"	p	class:ax::MaterialFactory	access:public	signature:(const char *name, FILE *fp)
ax::MaterialFactory::CreateGLSLMaterial	.\material-factory.cc	/^GLSLMaterialPtr MaterialFactory::CreateGLSLMaterial() {$/;"	f	class:ax::MaterialFactory	signature:()
ax::MaterialFactory::CreateGLSLMaterial	.\material-factory.cc	/^MaterialPtr MaterialFactory::CreateGLSLMaterial(const char *name, FILE *fp, $/;"	f	class:ax::MaterialFactory	signature:(const char *name, FILE *fp, Scene *s)
ax::MaterialFactory::CreateGLSLMaterial	.\material-factory.h	/^  static GLSLMaterialPtr CreateGLSLMaterial();$/;"	p	class:ax::MaterialFactory	access:public	signature:()
ax::MaterialFactory::CreateGLSLMaterial	.\material-factory.h	/^  static MaterialPtr CreateGLSLMaterial(const char *name, FILE *fp, Scene *s);$/;"	p	class:ax::MaterialFactory	access:public	signature:(const char *name, FILE *fp, Scene *s)
ax::MaterialMap	.\scene.h	/^typedef std::map<std::string, ax::MaterialPtr> MaterialMap;$/;"	t	namespace:ax
ax::MaterialPtr	.\cg_fwd.h	/^typedef std::tr1::shared_ptr<Material> MaterialPtr;$/;"	t	namespace:ax
ax::Motion	.\camera.h	/^class Motion {$/;"	c	namespace:ax
ax::Motion::Fly	.\camera.h	/^  virtual void Fly(float units) = 0; \/\/ move up\/down$/;"	p	class:ax::Motion	access:public	signature:(float units)
ax::Motion::Motion	.\camera.h	/^  Motion(const glm::vec3 &pos, const glm::vec3 &target, const glm::vec3 &up)$/;"	f	class:ax::Motion	access:public	signature:(const glm::vec3 &pos, const glm::vec3 &target, const glm::vec3 &up)
ax::Motion::Pitch	.\camera.h	/^  virtual void Pitch(float angle) = 0; \/\/ rotate on right vector$/;"	p	class:ax::Motion	access:public	signature:(float angle)
ax::Motion::Roll	.\camera.h	/^  virtual void Roll(float angle) = 0; \/\/ rotate on look vector$/;"	p	class:ax::Motion	access:public	signature:(float angle)
ax::Motion::SetPosition	.\camera.h	/^  void SetPosition(const glm::vec3 &p) { set_position(p); update_(); }$/;"	f	class:ax::Motion	access:public	signature:(const glm::vec3 &p)
ax::Motion::SetPosition	.\camera.h	/^  void SetPosition(float x, float y, float z) {  SetPosition(glm::vec3(x, y, z)); }$/;"	f	class:ax::Motion	access:public	signature:(float x, float y, float z)
ax::Motion::SetTarget	.\camera.h	/^  void SetTarget(const glm::vec3 &p) {  set_target(p); update_(); }$/;"	f	class:ax::Motion	access:public	signature:(const glm::vec3 &p)
ax::Motion::SetTarget	.\camera.h	/^  void SetTarget(float x, float y, float z) { SetTarget(glm::vec3(x, y, z)); }$/;"	f	class:ax::Motion	access:public	signature:(float x, float y, float z)
ax::Motion::SetUp	.\camera.h	/^  void SetUp(const glm::vec3 &v) { $/;"	f	class:ax::Motion	access:public	signature:(const glm::vec3 &v)
ax::Motion::SetUp	.\camera.h	/^  void SetUp(float x, float y, float z) { SetUp(glm::vec3(x, y, z)); }$/;"	f	class:ax::Motion	access:public	signature:(float x, float y, float z)
ax::Motion::Strafe	.\camera.h	/^  virtual void Strafe(float units) = 0; \/\/ move left\/right$/;"	p	class:ax::Motion	access:public	signature:(float units)
ax::Motion::Walk	.\camera.h	/^  virtual void Walk(float units) = 0; \/\/ move forward\/backward$/;"	p	class:ax::Motion	access:public	signature:(float units)
ax::Motion::Yaw	.\camera.h	/^  virtual void Yaw(float angle) = 0; \/\/ rotate on up vector$/;"	p	class:ax::Motion	access:public	signature:(float angle)
ax::Motion::fly_	.\camera.cc	/^void Motion::fly_(float units) {$/;"	f	class:ax::Motion	signature:(float units)
ax::Motion::fly_	.\camera.h	/^  void fly_(float units);$/;"	p	class:ax::Motion	access:protected	signature:(float units)
ax::Motion::inc_rotation_speed	.\camera.h	/^  void inc_rotation_speed(float f) { rotation_speed_ += f; }$/;"	f	class:ax::Motion	access:public	signature:(float f)
ax::Motion::inc_velocity	.\camera.h	/^  void inc_velocity(float x, float y, float z) {$/;"	f	class:ax::Motion	access:public	signature:(float x, float y, float z)
ax::Motion::look	.\camera.h	/^  const glm::vec3 &look() const { return look_; }$/;"	f	class:ax::Motion	access:public	signature:() const
ax::Motion::look_	.\camera.h	/^  glm::vec3 right_, up_, look_;$/;"	m	class:ax::Motion	access:private
ax::Motion::pitch_	.\camera.cc	/^void Motion::pitch_(float angle) {$/;"	f	class:ax::Motion	signature:(float angle)
ax::Motion::pitch_	.\camera.h	/^  void pitch_(float angle);$/;"	p	class:ax::Motion	access:protected	signature:(float angle)
ax::Motion::position	.\camera.h	/^  const glm::vec3 &position() const { return position_; }$/;"	f	class:ax::Motion	access:public	signature:() const
ax::Motion::position_	.\camera.h	/^  glm::vec3 position_, target_;$/;"	m	class:ax::Motion	access:private
ax::Motion::right	.\camera.h	/^  const glm::vec3 &right() const { return right_; }  $/;"	f	class:ax::Motion	access:protected	signature:() const
ax::Motion::right_	.\camera.h	/^  glm::vec3 right_, up_, look_;$/;"	m	class:ax::Motion	access:private
ax::Motion::roll_	.\camera.cc	/^void Motion::roll_(float angle) {$/;"	f	class:ax::Motion	signature:(float angle)
ax::Motion::roll_	.\camera.h	/^  void roll_(float angle);$/;"	p	class:ax::Motion	access:protected	signature:(float angle)
ax::Motion::rotation_speed_	.\camera.h	/^  float rotation_speed_;$/;"	m	class:ax::Motion	access:private
ax::Motion::set_look	.\camera.h	/^  void set_look(const glm::vec3 &v) { look_ = v; }$/;"	f	class:ax::Motion	access:protected	signature:(const glm::vec3 &v)
ax::Motion::set_position	.\camera.h	/^  void set_position(const glm::vec3 &p) { position_ = p; }$/;"	f	class:ax::Motion	access:protected	signature:(const glm::vec3 &p)
ax::Motion::set_right	.\camera.h	/^  void set_right(const glm::vec3 &v) { right_ = v; }$/;"	f	class:ax::Motion	access:protected	signature:(const glm::vec3 &v)
ax::Motion::set_rotation_speed	.\camera.h	/^  void set_rotation_speed(float f) { rotation_speed_ = f; }$/;"	f	class:ax::Motion	access:public	signature:(float f)
ax::Motion::set_target	.\camera.h	/^  void set_target(const glm::vec3 &p) { target_ = p; }$/;"	f	class:ax::Motion	access:protected	signature:(const glm::vec3 &p)
ax::Motion::set_up	.\camera.h	/^  void set_up(const glm::vec3 &v) { up_ = v; }$/;"	f	class:ax::Motion	access:protected	signature:(const glm::vec3 &v)
ax::Motion::set_velocity	.\camera.h	/^  void set_velocity(const glm::vec3 &v) { velocity_ = v; }$/;"	f	class:ax::Motion	access:public	signature:(const glm::vec3 &v)
ax::Motion::set_velocity	.\camera.h	/^  void set_velocity(float x, float y, float z) { $/;"	f	class:ax::Motion	access:public	signature:(float x, float y, float z)
ax::Motion::strafe_	.\camera.cc	/^void Motion::strafe_(float units) {$/;"	f	class:ax::Motion	signature:(float units)
ax::Motion::strafe_	.\camera.h	/^  void strafe_(float units);$/;"	p	class:ax::Motion	access:protected	signature:(float units)
ax::Motion::target	.\camera.h	/^  const glm::vec3 &target() const { return target_; }$/;"	f	class:ax::Motion	access:public	signature:() const
ax::Motion::target_	.\camera.h	/^  glm::vec3 position_, target_;$/;"	m	class:ax::Motion	access:private
ax::Motion::up	.\camera.h	/^  const glm::vec3 &up() const { return up_; }$/;"	f	class:ax::Motion	access:public	signature:() const
ax::Motion::up_	.\camera.h	/^  glm::vec3 right_, up_, look_;$/;"	m	class:ax::Motion	access:private
ax::Motion::update_	.\camera.h	/^  void update_() {$/;"	f	class:ax::Motion	access:private	signature:()
ax::Motion::velocity	.\camera.h	/^  const glm::vec3 &velocity() const { return velocity_; }$/;"	f	class:ax::Motion	access:public	signature:() const
ax::Motion::velocity_	.\camera.h	/^  glm::vec3 velocity_;$/;"	m	class:ax::Motion	access:private
ax::Motion::walk_	.\camera.cc	/^void Motion::walk_(float units) {$/;"	f	class:ax::Motion	signature:(float units)
ax::Motion::walk_	.\camera.h	/^  void walk_(float units);$/;"	p	class:ax::Motion	access:protected	signature:(float units)
ax::Motion::yaw_	.\camera.cc	/^void Motion::yaw_(float angle) {$/;"	f	class:ax::Motion	signature:(float angle)
ax::Motion::yaw_	.\camera.h	/^  void yaw_(float angle);$/;"	p	class:ax::Motion	access:protected	signature:(float angle)
ax::Motion::~Motion	.\camera.cc	/^Motion::~Motion() { }$/;"	f	class:ax::Motion	signature:()
ax::Motion::~Motion	.\camera.h	/^  virtual ~Motion() = 0;$/;"	p	class:ax::Motion	access:public	signature:()
ax::MultiResolutionBuffer	.\gl_buffer.h	/^class MultiResolutionBuffer : public FrameBuffer {$/;"	c	namespace:ax	inherits:FrameBuffer
ax::MultiResolutionBuffer::AdjustViewport	.\gl_buffer.cc	/^void MultiResolutionBuffer::AdjustViewport(int mipmap_level) {$/;"	f	class:ax::MultiResolutionBuffer	signature:(int mipmap_level)
ax::MultiResolutionBuffer::AdjustViewport	.\gl_buffer.h	/^  void AdjustViewport(int mipmap_level);$/;"	p	class:ax::MultiResolutionBuffer	access:private	signature:(int mipmap_level)
ax::MultiResolutionBuffer::ClearColorBuffer	.\gl_buffer.cc	/^void MultiResolutionBuffer::ClearColorBuffer(ax::ProgramGLSLPtr shader) {$/;"	f	class:ax::MultiResolutionBuffer	signature:(ax::ProgramGLSLPtr shader)
ax::MultiResolutionBuffer::ClearColorBuffer	.\gl_buffer.h	/^  void ClearColorBuffer(ax::ProgramGLSLPtr shader); $/;"	p	class:ax::MultiResolutionBuffer	access:public	signature:(ax::ProgramGLSLPtr shader)
ax::MultiResolutionBuffer::ComputeMipmapViewports	.\gl_buffer.cc	/^void MultiResolutionBuffer::ComputeMipmapViewports() {$/;"	f	class:ax::MultiResolutionBuffer	signature:()
ax::MultiResolutionBuffer::ComputeMipmapViewports	.\gl_buffer.h	/^  void ComputeMipmapViewports();$/;"	p	class:ax::MultiResolutionBuffer	access:private	signature:()
ax::MultiResolutionBuffer::Initialize	.\gl_buffer.cc	/^bool MultiResolutionBuffer::Initialize(const ax::ParamSet &params) {$/;"	f	class:ax::MultiResolutionBuffer	signature:(const ax::ParamSet &params)
ax::MultiResolutionBuffer::Initialize	.\gl_buffer.h	/^  bool Initialize(const ax::ParamSet &params);$/;"	p	class:ax::MultiResolutionBuffer	access:public	signature:(const ax::ParamSet &params)
ax::MultiResolutionBuffer::MipmapLevel	.\gl_buffer.h	/^  int MipmapLevel(int resolution) const {$/;"	f	class:ax::MultiResolutionBuffer	access:public	signature:(int resolution) const
ax::MultiResolutionBuffer::MipmapWidth	.\gl_buffer.h	/^  int MipmapWidth(int level) const { return this->widths_[level]; }$/;"	f	class:ax::MultiResolutionBuffer	access:public	signature:(int level) const
ax::MultiResolutionBuffer::MipmapXOffset	.\gl_buffer.h	/^  int MipmapXOffset(int level) const { return this->offsets_[level]; }$/;"	f	class:ax::MultiResolutionBuffer	access:public	signature:(int level) const
ax::MultiResolutionBuffer::RenderFullScreen	.\gl_buffer.cc	/^void MultiResolutionBuffer::RenderFullScreen($/;"	f	class:ax::MultiResolutionBuffer	signature:( ax::ProgramGLSLPtr shader, int mipmap_level)
ax::MultiResolutionBuffer::RenderFullScreen	.\gl_buffer.cc	/^void MultiResolutionBuffer::RenderFullScreen(ax::ProgramGLSLPtr shader) {$/;"	f	class:ax::MultiResolutionBuffer	signature:(ax::ProgramGLSLPtr shader)
ax::MultiResolutionBuffer::RenderFullScreen	.\gl_buffer.h	/^  void RenderFullScreen(ax::ProgramGLSLPtr shader);$/;"	p	class:ax::MultiResolutionBuffer	access:public	signature:(ax::ProgramGLSLPtr shader)
ax::MultiResolutionBuffer::RenderFullScreen	.\gl_buffer.h	/^  void RenderFullScreen(ax::ProgramGLSLPtr shader, int mipmap_level);$/;"	p	class:ax::MultiResolutionBuffer	access:public	signature:(ax::ProgramGLSLPtr shader, int mipmap_level)
ax::MultiResolutionBuffer::Resize	.\gl_buffer.cc	/^bool MultiResolutionBuffer::Resize(int w, int h) {$/;"	f	class:ax::MultiResolutionBuffer	signature:(int w, int h)
ax::MultiResolutionBuffer::Resize	.\gl_buffer.h	/^  bool Resize(int w, int h);$/;"	p	class:ax::MultiResolutionBuffer	access:public	signature:(int w, int h)
ax::MultiResolutionBuffer::offsets_	.\gl_buffer.h	/^  std::vector<int> offsets_;$/;"	m	class:ax::MultiResolutionBuffer	access:private
ax::MultiResolutionBuffer::screen_quad_	.\gl_buffer.h	/^  ax::ScreenQuadPtr screen_quad_;$/;"	m	class:ax::MultiResolutionBuffer	access:private
ax::MultiResolutionBuffer::widths_	.\gl_buffer.h	/^  std::vector<int> widths_;$/;"	m	class:ax::MultiResolutionBuffer	access:private
ax::MyScreenQuad::Draw	.\model_gl.cc	/^void MyScreenQuad::Draw() {$/;"	f	class:ax::MyScreenQuad	signature:()
ax::MyScreenQuad::Initialize	.\model_gl.cc	/^bool MyScreenQuad::Initialize() {$/;"	f	class:ax::MyScreenQuad	signature:()
ax::MyScreenQuad::quadVArray	.\model_gl.cc	/^const GLfloat MyScreenQuad::quadVArray[] = {$/;"	m	class:ax::MyScreenQuad	file:
ax::NamedVariables	.\scene.h	/^class NamedVariables {$/;"	c	namespace:ax
ax::NamedVariables::Load	.\scene.h	/^  bool Load(const std::string &filename);$/;"	p	class:ax::NamedVariables	access:public	signature:(const std::string &filename)
ax::NamedVariables::floats_	.\scene.h	/^  FloatVarMap floats_;$/;"	m	class:ax::NamedVariables	access:private
ax::NamedVariables::get_float	.\scene.h	/^  float get_float(const std::string &name) { return floats_[name]; }$/;"	f	class:ax::NamedVariables	access:public	signature:(const std::string &name)
ax::NamedVariables::get_int	.\scene.h	/^  int get_int(const std::string &name) { return ints_[name]; }$/;"	f	class:ax::NamedVariables	access:public	signature:(const std::string &name)
ax::NamedVariables::ints_	.\scene.h	/^  IntVarMap ints_;$/;"	m	class:ax::NamedVariables	access:private
ax::Object	.\globject.h	/^class Object {$/;"	c	namespace:ax
ax::Object::ApplyTransform	.\globject.h	/^  virtual void ApplyTransform(const ax::Matrix4x4 &m) = 0;$/;"	p	class:ax::Object	access:protected	signature:(const ax::Matrix4x4 &m)
ax::Object::ComputeBound	.\globject.h	/^  virtual ax::AABB ComputeBound(const ax::Matrix4x4 &m) const = 0;  $/;"	p	class:ax::Object	access:public	signature:(const ax::Matrix4x4 &m) const
ax::Object::DISABLE_COPY_AND_ASSIGN	.\globject.h	/^  DISABLE_COPY_AND_ASSIGN(Object);$/;"	p	class:ax::Object	access:protected	signature:(Object)
ax::Object::Draw	.\globject.h	/^  virtual void Draw(ProgramGLSLPtr prog, Options opts) const = 0;$/;"	p	class:ax::Object	access:public	signature:(ProgramGLSLPtr prog, Options opts) const
ax::Object::Draw	.\globject.h	/^  virtual void Draw(const Scene *s, Options opts) const = 0;$/;"	p	class:ax::Object	access:public	signature:(const Scene *s, Options opts) const
ax::Object::Object	.\globject.h	/^  Object() : transform_applied_(false), matl_(Material::kNullMatl) { }$/;"	f	class:ax::Object	access:protected	signature:()
ax::Object::PreProcess	.\globject.h	/^  virtual void PreProcess(Options opts) = 0;$/;"	p	class:ax::Object	access:public	signature:(Options opts)
ax::Object::Transform	.\globject.h	/^  void Transform(const ax::Matrix4x4 &m = ax::Matrix4x4(1.f)) {$/;"	f	class:ax::Object	access:public	signature:(const ax::Matrix4x4 &m = ax::Matrix4x4(1.f))
ax::Object::bound	.\globject.h	/^  const ax::AABB &bound() const { return bound_; }$/;"	f	class:ax::Object	access:public	signature:() const
ax::Object::bound_	.\globject.h	/^  ax::AABB bound_;$/;"	m	class:ax::Object	access:protected
ax::Object::material	.\globject.h	/^  const ax::MaterialPtr &material() const {$/;"	f	class:ax::Object	access:public	signature:() const
ax::Object::matl_	.\globject.h	/^  MaterialPtr matl_;$/;"	m	class:ax::Object	access:protected
ax::Object::parent_group_	.\globject.h	/^  ObjectPtr parent_group_;$/;"	m	class:ax::Object	access:protected
ax::Object::set_material	.\globject.h	/^  void set_material(const MaterialPtr &matl) {$/;"	f	class:ax::Object	access:public	signature:(const MaterialPtr &matl)
ax::Object::set_parent_group	.\globject.h	/^  void set_parent_group(const ObjectPtr &obj) { parent_group_ = obj; }$/;"	f	class:ax::Object	access:public	signature:(const ObjectPtr &obj)
ax::Object::set_transform	.\globject.h	/^  void set_transform(const ax::Matrix4x4 &m) { transform_ = m; }$/;"	f	class:ax::Object	access:public	signature:(const ax::Matrix4x4 &m)
ax::Object::transform	.\globject.h	/^  const ax::Matrix4x4 &transform() const { return transform_; }$/;"	f	class:ax::Object	access:public	signature:() const
ax::Object::transform_	.\globject.h	/^  ax::Matrix4x4 transform_;$/;"	m	class:ax::Object	access:protected
ax::Object::transform_applied	.\globject.h	/^  bool transform_applied() const { return transform_applied_; }  $/;"	f	class:ax::Object	access:public	signature:() const
ax::Object::transform_applied_	.\globject.h	/^  bool transform_applied_;    $/;"	m	class:ax::Object	access:protected
ax::Object::~Object	.\globject.h	/^  virtual ~Object() { }$/;"	f	class:ax::Object	access:public	signature:()
ax::ObjectFactory	.\object-factory.h	/^class ObjectFactory {$/;"	c	namespace:ax
ax::ObjectFactory::CreateGroup	.\object-factory.cc	/^GroupPtr ObjectFactory::CreateGroup() { return GroupPtr(new Group()); }$/;"	f	class:ax::ObjectFactory	signature:()
ax::ObjectFactory::CreateGroup	.\object-factory.cc	/^ObjectPtr ObjectFactory::CreateGroup(FILE *fp, Scene *s) {  $/;"	f	class:ax::ObjectFactory	signature:(FILE *fp, Scene *s)
ax::ObjectFactory::CreateGroup	.\object-factory.h	/^  static GroupPtr CreateGroup();$/;"	p	class:ax::ObjectFactory	access:public	signature:()
ax::ObjectFactory::CreateGroup	.\object-factory.h	/^  static ObjectPtr CreateGroup(FILE *fp, Scene *s);$/;"	p	class:ax::ObjectFactory	access:public	signature:(FILE *fp, Scene *s)
ax::ObjectFactory::LoadMaterial	.\object-factory.cc	/^MaterialPtr ObjectFactory::LoadMaterial(const char *ptr, Scene *s, FILE *fp) {$/;"	f	class:ax::ObjectFactory	signature:(const char *ptr, Scene *s, FILE *fp)
ax::ObjectFactory::LoadMaterial	.\object-factory.h	/^  static MaterialPtr LoadMaterial(const char *ptr, Scene *s, FILE *fp);$/;"	p	class:ax::ObjectFactory	access:private	signature:(const char *ptr, Scene *s, FILE *fp)
ax::ObjectFactory::LoadWavefront	.\object-factory.cc	/^ObjectPtr ObjectFactory::LoadWavefront(FILE *fp, Scene *s, Options opts) {$/;"	f	class:ax::ObjectFactory	signature:(FILE *fp, Scene *s, Options opts)
ax::ObjectFactory::LoadWavefront	.\object-factory.h	/^  static ObjectPtr LoadWavefront(FILE *fp, Scene *s, Options opts);$/;"	p	class:ax::ObjectFactory	access:public	signature:(FILE *fp, Scene *s, Options opts)
ax::ObjectMap	.\scene.h	/^typedef std::map<std::string, ax::ObjectPtr> ObjectMap;$/;"	t	namespace:ax
ax::ObjectPtr	.\cg_fwd.h	/^typedef std::tr1::shared_ptr<Object> ObjectPtr;$/;"	t	namespace:ax
ax::Options	.\cg_fwd.h	/^class Options {$/;"	c	namespace:ax
ax::Options::Add	.\cg_fwd.h	/^  void Add(int opt) { this->opts_ |= opt; }$/;"	f	class:ax::Options	access:public	signature:(int opt)
ax::Options::Clear	.\cg_fwd.h	/^  void Clear(int opt) { opts_ &= ~opt; }$/;"	f	class:ax::Options	access:public	signature:(int opt)
ax::Options::Contain	.\cg_fwd.h	/^  bool Contain(int opt) const { return (opts_ &opt) != 0; }$/;"	f	class:ax::Options	access:public	signature:(int opt) const
ax::Options::IsEmpty	.\cg_fwd.h	/^  bool IsEmpty() const { return opts_ == kNone; }  $/;"	f	class:ax::Options	access:public	signature:() const
ax::Options::Options	.\cg_fwd.h	/^  Options() : opts_(0) { }$/;"	f	class:ax::Options	access:public	signature:()
ax::Options::Options	.\cg_fwd.h	/^  Options(int opts) : opts_(opts) { }$/;"	f	class:ax::Options	access:public	signature:(int opts)
ax::Options::opts_	.\cg_fwd.h	/^  int opts_;$/;"	m	class:ax::Options	access:private
ax::OrbitMotion	.\camera.h	/^class OrbitMotion : public Motion {$/;"	c	namespace:ax	inherits:Motion
ax::OrbitMotion::Fly	.\camera.h	/^  virtual void Fly(float units) { }$/;"	f	class:ax::OrbitMotion	access:public	signature:(float units)
ax::OrbitMotion::OrbitMotion	.\camera.h	/^  OrbitMotion(const glm::vec3 &pos, $/;"	f	class:ax::OrbitMotion	access:public	signature:(const glm::vec3 &pos, const glm::vec3 &target = glm::vec3(0, 0, 0), const glm::vec3 &up = glm::vec3(0, 1, 0))
ax::OrbitMotion::Pitch	.\camera.cc	/^void OrbitMotion::Pitch(float angle) {$/;"	f	class:ax::OrbitMotion	signature:(float angle)
ax::OrbitMotion::Pitch	.\camera.h	/^  virtual void Pitch(float angle);$/;"	p	class:ax::OrbitMotion	access:public	signature:(float angle)
ax::OrbitMotion::Roll	.\camera.cc	/^void OrbitMotion::Roll(float angle) {$/;"	f	class:ax::OrbitMotion	signature:(float angle)
ax::OrbitMotion::Roll	.\camera.h	/^  virtual void Roll(float angle);$/;"	p	class:ax::OrbitMotion	access:public	signature:(float angle)
ax::OrbitMotion::Strafe	.\camera.h	/^  virtual void Strafe(float units) { }$/;"	f	class:ax::OrbitMotion	access:public	signature:(float units)
ax::OrbitMotion::UpdataPosition	.\camera.cc	/^void OrbitMotion::UpdataPosition() {$/;"	f	class:ax::OrbitMotion	signature:()
ax::OrbitMotion::UpdataPosition	.\camera.h	/^  void UpdataPosition();$/;"	p	class:ax::OrbitMotion	access:private	signature:()
ax::OrbitMotion::Walk	.\camera.cc	/^void OrbitMotion::Walk( float units ) {$/;"	f	class:ax::OrbitMotion	signature:( float units )
ax::OrbitMotion::Walk	.\camera.h	/^  virtual void Walk(float units);$/;"	p	class:ax::OrbitMotion	access:public	signature:(float units)
ax::OrbitMotion::Yaw	.\camera.cc	/^void OrbitMotion::Yaw(float angle) {$/;"	f	class:ax::OrbitMotion	signature:(float angle)
ax::OrbitMotion::Yaw	.\camera.h	/^  virtual void Yaw(float angle);$/;"	p	class:ax::OrbitMotion	access:public	signature:(float angle)
ax::OrbitMotion::max_dist	.\camera.h	/^  float max_dist() const { return max_dist_; }$/;"	f	class:ax::OrbitMotion	access:public	signature:() const
ax::OrbitMotion::max_dist_	.\camera.h	/^  float min_dist_, max_dist_;$/;"	m	class:ax::OrbitMotion	access:private
ax::OrbitMotion::min_dist	.\camera.h	/^  float min_dist() const { return min_dist_; }$/;"	f	class:ax::OrbitMotion	access:public	signature:() const
ax::OrbitMotion::min_dist_	.\camera.h	/^  float min_dist_, max_dist_;$/;"	m	class:ax::OrbitMotion	access:private
ax::OrbitMotion::set_max_dist	.\camera.h	/^  void set_max_dist(float f) { max_dist_ = f; }$/;"	f	class:ax::OrbitMotion	access:public	signature:(float f)
ax::OrbitMotion::set_min_dist	.\camera.h	/^  void set_min_dist(float f) { min_dist_ = f; }$/;"	f	class:ax::OrbitMotion	access:public	signature:(float f)
ax::OrbitPerspectiveCameraGL	.\camera.h	/^typedef PerspectiveCameraGL<OrbitMotion> OrbitPerspectiveCameraGL;$/;"	t	namespace:ax
ax::OrbitPerspectiveCameraGL	.\cg_fwd.h	/^typedef PerspectiveCameraGL<OrbitMotion> OrbitPerspectiveCameraGL;$/;"	t	namespace:ax
ax::OrbitPerspectiveCameraGLPtr	.\cg_fwd.h	/^OrbitPerspectiveCameraGLPtr;$/;"	t	namespace:ax
ax::OrthoCameraGL	.\camera.h	/^class OrthoCameraGL : public MotionType {$/;"	c	namespace:ax	inherits:MotionType
ax::OrthoCameraGL::OrthoCameraGL	.\camera.h	/^  OrthoCameraGL(float left, float right, float bottom, float up, float near, float far);$/;"	p	class:ax::OrthoCameraGL	access:public	signature:(float left, float right, float bottom, float up, float near, float far)
ax::ParamSet	.\params.h	/^typedef __ParamSet<CGParamKeyType> ParamSet;$/;"	t	namespace:ax
ax::ParamSet2	.\params.h	/^typedef __ParamSet2<CGParamKeyType> ParamSet2;$/;"	t	namespace:ax
ax::ParseNumber	.\parser.h	/^inline float ParseNumber(const char *str, float def=1.0f) {$/;"	f	namespace:ax	signature:(const char *str, float def=1.0f)
ax::PerspectiveCameraGL	.\camera.h	/^class PerspectiveCameraGL : public MotionType {$/;"	c	namespace:ax	inherits:MotionType
ax::PerspectiveCameraGL::PerspectiveCameraGL	.\camera.h	/^  PerspectiveCameraGL(const glm::vec3 &pos = glm::vec3(0, 0, 1),$/;"	f	class:ax::PerspectiveCameraGL	access:public	signature:(const glm::vec3 &pos = glm::vec3(0, 0, 1), const glm::vec3 &target = glm::vec3(0, 0, 0), const glm::vec3 &up = glm::vec3(0, 1, 0))
ax::PerspectiveCameraGL::ProjMatrix	.\camera.h	/^  glm::mat4 ProjMatrix() const {$/;"	f	class:ax::PerspectiveCameraGL	access:public	signature:() const
ax::PerspectiveCameraGL::ViewMatrix	.\camera.h	/^  glm::mat4 ViewMatrix() const {    $/;"	f	class:ax::PerspectiveCameraGL	access:public	signature:() const
ax::PerspectiveCameraGL::ViewProjMatrix	.\camera.h	/^  glm::mat4 ViewProjMatrix() const {   $/;"	f	class:ax::PerspectiveCameraGL	access:public	signature:() const
ax::PerspectiveCameraGL::aspect_ratio	.\camera.h	/^  float aspect_ratio() const { return aspect_ratio_; }$/;"	f	class:ax::PerspectiveCameraGL	access:public	signature:() const
ax::PerspectiveCameraGL::aspect_ratio_	.\camera.h	/^  float fovy_, aspect_ratio_, z_near_, z_far_;$/;"	m	class:ax::PerspectiveCameraGL	access:private
ax::PerspectiveCameraGL::fovy	.\camera.h	/^  float fovy() const { return fovy_; }$/;"	f	class:ax::PerspectiveCameraGL	access:public	signature:() const
ax::PerspectiveCameraGL::fovy_	.\camera.h	/^  float fovy_, aspect_ratio_, z_near_, z_far_;$/;"	m	class:ax::PerspectiveCameraGL	access:private
ax::PerspectiveCameraGL::inc_fovy	.\camera.h	/^  void inc_fovy(float val) { fovy_ += val; }$/;"	f	class:ax::PerspectiveCameraGL	access:public	signature:(float val)
ax::PerspectiveCameraGL::inc_z_far	.\camera.h	/^  void inc_z_far(float val) { z_far_ += val; }$/;"	f	class:ax::PerspectiveCameraGL	access:public	signature:(float val)
ax::PerspectiveCameraGL::inc_z_near	.\camera.h	/^  void inc_z_near(float val) { z_near_ += val; }$/;"	f	class:ax::PerspectiveCameraGL	access:public	signature:(float val)
ax::PerspectiveCameraGL::set_aspect_ratio	.\camera.h	/^  void set_aspect_ratio(float val) { aspect_ratio_ = val; }$/;"	f	class:ax::PerspectiveCameraGL	access:public	signature:(float val)
ax::PerspectiveCameraGL::set_fovy	.\camera.h	/^  void set_fovy(float val) { fovy_ = val; }$/;"	f	class:ax::PerspectiveCameraGL	access:public	signature:(float val)
ax::PerspectiveCameraGL::set_z_far	.\camera.h	/^  void set_z_far(float val) { z_far_ = val; }$/;"	f	class:ax::PerspectiveCameraGL	access:public	signature:(float val)
ax::PerspectiveCameraGL::set_z_near	.\camera.h	/^  void set_z_near(float val) {z_near_ = val; }$/;"	f	class:ax::PerspectiveCameraGL	access:public	signature:(float val)
ax::PerspectiveCameraGL::z_far	.\camera.h	/^  float z_far() const { return z_far_; }$/;"	f	class:ax::PerspectiveCameraGL	access:public	signature:() const
ax::PerspectiveCameraGL::z_far_	.\camera.h	/^  float fovy_, aspect_ratio_, z_near_, z_far_;$/;"	m	class:ax::PerspectiveCameraGL	access:private
ax::PerspectiveCameraGL::z_near	.\camera.h	/^  float z_near() const { return z_near_; }$/;"	f	class:ax::PerspectiveCameraGL	access:public	signature:() const
ax::PerspectiveCameraGL::z_near_	.\camera.h	/^  float fovy_, aspect_ratio_, z_near_, z_far_;$/;"	m	class:ax::PerspectiveCameraGL	access:private
ax::ProgramGLSL	.\program_glsl.h	/^class ProgramGLSL : public GLObject {$/;"	c	namespace:ax	inherits:GLObject
ax::ProgramGLSL::AttachFragShader	.\program_glsl.h	/^  bool AttachFragShader(const char *file) { $/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *file)
ax::ProgramGLSL::AttachGeomShader	.\program_glsl.h	/^  bool AttachGeomShader(const char *file) {$/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *file)
ax::ProgramGLSL::AttachShader	.\program_glsl.cc	/^bool ProgramGLSL::AttachShader(const ShaderPtr shader) const {$/;"	f	class:ax::ProgramGLSL	signature:(const ShaderPtr shader) const
ax::ProgramGLSL::AttachShader	.\program_glsl.cc	/^bool ProgramGLSL::AttachShader(int type, const char *file, const MacroList &macros) {$/;"	f	class:ax::ProgramGLSL	signature:(int type, const char *file, const MacroList &macros)
ax::ProgramGLSL::AttachShader	.\program_glsl.h	/^  bool AttachShader(const ShaderPtr shader) const;$/;"	p	class:ax::ProgramGLSL	access:public	signature:(const ShaderPtr shader) const
ax::ProgramGLSL::AttachShader	.\program_glsl.h	/^  bool AttachShader(int type, const char *file, const MacroList &macros = MacroList());$/;"	p	class:ax::ProgramGLSL	access:public	signature:(int type, const char *file, const MacroList &macros = MacroList())
ax::ProgramGLSL::AttachVertShader	.\program_glsl.h	/^  bool AttachVertShader(const char *file) {$/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *file)
ax::ProgramGLSL::Begin	.\program_glsl.h	/^  void Begin() { glUseProgram(id_); }$/;"	f	class:ax::ProgramGLSL	access:public	signature:()
ax::ProgramGLSL::CheckLinkResult	.\program_glsl.cc	/^bool ProgramGLSL::CheckLinkResult() {$/;"	f	class:ax::ProgramGLSL	signature:()
ax::ProgramGLSL::CheckLinkResult	.\program_glsl.h	/^  bool CheckLinkResult();$/;"	p	class:ax::ProgramGLSL	access:private	signature:()
ax::ProgramGLSL::Create	.\program_glsl.cc	/^ProgramGLSLPtr ProgramGLSL::Create(const char *vertex_shader, $/;"	f	class:ax::ProgramGLSL	signature:(const char *vertex_shader, const char *fragment_shader, const std::string &name, const MacroList &macros)
ax::ProgramGLSL::Create	.\program_glsl.h	/^  static ProgramGLSLPtr Create(const char *vertex_shader, $/;"	p	class:ax::ProgramGLSL	access:public	signature:(const char *vertex_shader, const char *fragment_shader, const std::string &name = Ó, const MacroList &macros = MacroList())
ax::ProgramGLSL::CreateFromCode	.\program_glsl.cc	/^ProgramGLSLPtr ProgramGLSL::CreateFromCode(const char *vert_src, const char *frag_src, const char *name) {$/;"	f	class:ax::ProgramGLSL	signature:(const char *vert_src, const char *frag_src, const char *name)
ax::ProgramGLSL::CreateFromCode	.\program_glsl.h	/^  static ProgramGLSLPtr CreateFromCode(const char *vert_src, const char *frag_src, const char *name = "");$/;"	p	class:ax::ProgramGLSL	access:public	signature:(const char *vert_src, const char *frag_src, const char *name = Ó)
ax::ProgramGLSL::DeleteProgram	.\program_glsl.h	/^  void DeleteProgram() {$/;"	f	class:ax::ProgramGLSL	access:private	signature:()
ax::ProgramGLSL::End	.\program_glsl.h	/^  void End() {$/;"	f	class:ax::ProgramGLSL	access:public	signature:()
ax::ProgramGLSL::GeometryShaderSettings	.\program_glsl.cc	/^void ProgramGLSL::GeometryShaderSettings(GLenum input_type, $/;"	f	class:ax::ProgramGLSL	signature:(GLenum input_type, int max_emitted_verts, GLenum output_type)
ax::ProgramGLSL::GeometryShaderSettings	.\program_glsl.h	/^  void GeometryShaderSettings(GLenum input_type, int max_emitted_verts, $/;"	p	class:ax::ProgramGLSL	access:public	signature:(GLenum input_type, int max_emitted_verts, GLenum output_type)
ax::ProgramGLSL::GetUniformVar	.\program_glsl.h	/^  int GetUniformVar(const char *name) const {$/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *name) const
ax::ProgramGLSL::IsValid	.\program_glsl.h	/^  bool IsValid() const { return 0 != id_ && is_linked_; }$/;"	f	class:ax::ProgramGLSL	access:public	signature:() const
ax::ProgramGLSL::IsVarValid	.\program_glsl.h	/^  bool IsVarValid(GLint var, const char *name = "") const {$/;"	f	class:ax::ProgramGLSL	access:private	signature:(GLint var, const char *name = Ó) const
ax::ProgramGLSL::Link	.\program_glsl.h	/^  bool Link() {$/;"	f	class:ax::ProgramGLSL	access:public	signature:()
ax::ProgramGLSL::Load	.\program_glsl.cc	/^bool ProgramGLSL::Load(const char *vertex_shader, const char *fragment_shader, const MacroList &macros) {$/;"	f	class:ax::ProgramGLSL	signature:(const char *vertex_shader, const char *fragment_shader, const MacroList &macros)
ax::ProgramGLSL::Load	.\program_glsl.h	/^  bool Load(const char *vertex_shader, const char *fragment_shader, const MacroList &macros = MacroList());$/;"	p	class:ax::ProgramGLSL	access:public	signature:(const char *vertex_shader, const char *fragment_shader, const MacroList &macros = MacroList())
ax::ProgramGLSL::NextTextureSlot	.\program_glsl.h	/^  int NextTextureSlot() {$/;"	f	class:ax::ProgramGLSL	access:private	signature:()
ax::ProgramGLSL::PrintLinkLog	.\program_glsl.cc	/^void ProgramGLSL::PrintLinkLog() const {$/;"	f	class:ax::ProgramGLSL	signature:() const
ax::ProgramGLSL::PrintLinkLog	.\program_glsl.h	/^  void PrintLinkLog() const;$/;"	p	class:ax::ProgramGLSL	access:private	signature:() const
ax::ProgramGLSL::ProgramGLSL	.\program_glsl.h	/^  ProgramGLSL(const std::string &name) : $/;"	f	class:ax::ProgramGLSL	access:private	signature:(const std::string &name)
ax::ProgramGLSL::ResetTextureSlot	.\program_glsl.h	/^  void ResetTextureSlot() {$/;"	f	class:ax::ProgramGLSL	access:private	signature:()
ax::ProgramGLSL::Set1DVar	.\program_glsl.h	/^  void Set1DVar(const char *name, const GLuint64EXT *vals, int n = 1) const {$/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *name, const GLuint64EXT *vals, int n = 1) const
ax::ProgramGLSL::Set1DVar	.\program_glsl.h	/^  void Set1DVar(const char *name, const float *vals, int n = 1) const {$/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *name, const float *vals, int n = 1) const
ax::ProgramGLSL::Set1DVar	.\program_glsl.h	/^  void Set1DVar(const char *name, const int *vals, int n = 1) const {$/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *name, const int *vals, int n = 1) const
ax::ProgramGLSL::Set2DVar	.\program_glsl.h	/^  void Set2DVar(const char *name, const float *vals, int n = 1) const {$/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *name, const float *vals, int n = 1) const
ax::ProgramGLSL::Set2DVar	.\program_glsl.h	/^  void Set2DVar(const char *name, const int *vals, int n = 1) const {$/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *name, const int *vals, int n = 1) const
ax::ProgramGLSL::Set3DMatVar	.\program_glsl.h	/^  void Set3DMatVar(const char *name, const MAT3D &m,$/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *name, const MAT3D &m, int transpose = GL_FALSE) const
ax::ProgramGLSL::Set3DMatVar	.\program_glsl.h	/^  void Set3DMatVar(const char *name, const float *vals, int n = 1,$/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *name, const float *vals, int n = 1, int transpose = GL_FALSE) const
ax::ProgramGLSL::Set3DVar	.\program_glsl.h	/^  void Set3DVar(const char *name, const VEC3D &vec) {$/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *name, const VEC3D &vec)
ax::ProgramGLSL::Set3DVar	.\program_glsl.h	/^  void Set3DVar(const char *name, const float *vals, int n = 1) const {$/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *name, const float *vals, int n = 1) const
ax::ProgramGLSL::Set3DVar	.\program_glsl.h	/^  void Set3DVar(const char *name, const int *vals, int n = 1) const {$/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *name, const int *vals, int n = 1) const
ax::ProgramGLSL::Set4DMatVar	.\program_glsl.h	/^  void Set4DMatVar(const char *name, const MAT4D &m,$/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *name, const MAT4D &m, int transpose = GL_FALSE) const
ax::ProgramGLSL::Set4DMatVar	.\program_glsl.h	/^  void Set4DMatVar(const char *name, const float *vals, int n = 1, $/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *name, const float *vals, int n = 1, int transpose = GL_FALSE) const
ax::ProgramGLSL::Set4DVar	.\program_glsl.h	/^  void Set4DVar(const char *name, const float *vals, int n = 1) const {$/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *name, const float *vals, int n = 1) const
ax::ProgramGLSL::Set4DVar	.\program_glsl.h	/^  void Set4DVar(const char *name, const int *vals, int n = 1) const {$/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *name, const int *vals, int n = 1) const
ax::ProgramGLSL::SetArrayVar	.\program_glsl.h	/^  void SetArrayVar(const char *name, int n, const T *vals, F f) const {$/;"	f	class:ax::ProgramGLSL	access:private	signature:(const char *name, int n, const T *vals, F f) const
ax::ProgramGLSL::SetMatArrayVar	.\program_glsl.h	/^  void SetMatArrayVar(const char *name, int n, int transpose, $/;"	f	class:ax::ProgramGLSL	access:private	signature:(const char *name, int n, int transpose, const T *vals, F f) const
ax::ProgramGLSL::SetParameteri	.\program_glsl.h	/^  void SetParameteri(uint32 name, int param) {$/;"	f	class:ax::ProgramGLSL	access:public	signature:(uint32 name, int param)
ax::ProgramGLSL::SetScalarVar	.\program_glsl.h	/^  void SetScalarVar(const char *name, T val, F f) const {$/;"	f	class:ax::ProgramGLSL	access:private	signature:(const char *name, T val, F f) const
ax::ProgramGLSL::SetSubroutineVar	.\program_glsl.cc	/^void ProgramGLSL::SetSubroutineVar(const std::string &var_name, $/;"	f	class:ax::ProgramGLSL	signature:(const std::string &var_name, const std::string &routine_name, int shader_type)
ax::ProgramGLSL::SetSubroutineVar	.\program_glsl.h	/^  void SetSubroutineVar(const std::string &var_name, $/;"	p	class:ax::ProgramGLSL	access:public	signature:(const std::string &var_name, const std::string &routine_name, int shader_type)
ax::ProgramGLSL::SetTextureVar	.\program_glsl.cc	/^void ProgramGLSL::SetTextureVar(const char *name, $/;"	f	class:ax::ProgramGLSL	signature:(const char *name, const Texture2DPtr &tex)
ax::ProgramGLSL::SetTextureVar	.\program_glsl.cc	/^void ProgramGLSL::SetTextureVar(const char *name, const Texture2DPtr *texs,$/;"	f	class:ax::ProgramGLSL	signature:(const char *name, const Texture2DPtr *texs, size_t n)
ax::ProgramGLSL::SetTextureVar	.\program_glsl.h	/^  void SetTextureVar(const char *name) {$/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *name)
ax::ProgramGLSL::SetTextureVar	.\program_glsl.h	/^  void SetTextureVar(const char *name, const Texture2DPtr &tex);$/;"	p	class:ax::ProgramGLSL	access:public	signature:(const char *name, const Texture2DPtr &tex)
ax::ProgramGLSL::SetTextureVar	.\program_glsl.h	/^  void SetTextureVar(const char *name, const Texture2DPtr *texs, size_t n);$/;"	p	class:ax::ProgramGLSL	access:public	signature:(const char *name, const Texture2DPtr *texs, size_t n)
ax::ProgramGLSL::SetTextureVar	.\program_glsl.h	/^  void SetTextureVar(const char *name, const std::vector<Texture2DPtr> &texs) {$/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *name, const std::vector<Texture2DPtr> &texs)
ax::ProgramGLSL::SetTextureVars	.\program_glsl.h	/^  void SetTextureVars(const char *names[], $/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *names[], const std::vector<Texture2DPtr> &texs)
ax::ProgramGLSL::SetTextureVars	.\program_glsl.h	/^  void SetTextureVars(const char *names[], const Texture2DPtr *texs, $/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *names[], const Texture2DPtr *texs, size_t n)
ax::ProgramGLSL::SetVar	.\program_glsl.h	/^  void SetVar(const char *name, GLuint64EXT val) const {$/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *name, GLuint64EXT val) const
ax::ProgramGLSL::SetVar	.\program_glsl.h	/^  void SetVar(const char *name, T val) const {$/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *name, T val) const
ax::ProgramGLSL::SetVar	.\program_glsl.h	/^  void SetVar(const char *name, float val) const {$/;"	f	class:ax::ProgramGLSL	access:public	signature:(const char *name, float val) const
ax::ProgramGLSL::is_linked_	.\program_glsl.h	/^  bool is_linked_;$/;"	m	class:ax::ProgramGLSL	access:private
ax::ProgramGLSL::texture_slot_	.\program_glsl.h	/^  int texture_slot_;$/;"	m	class:ax::ProgramGLSL	access:private
ax::ProgramGLSL::~ProgramGLSL	.\program_glsl.h	/^  virtual ~ProgramGLSL() { this->DeleteProgram(); }$/;"	f	class:ax::ProgramGLSL	access:public	signature:()
ax::ProgramGLSLPtr	.\cg_fwd.h	/^typedef std::tr1::shared_ptr<ProgramGLSL> ProgramGLSLPtr;$/;"	t	namespace:ax
ax::Quad2DGL	.\model_gl.h	/^class Quad2DGL {$/;"	c	namespace:ax
ax::Quad2DGL::CreateQuad2D	.\model_gl.h	/^  void CreateQuad2D(const float x1, const float y1, $/;"	f	class:ax::Quad2DGL	access:private	signature:(const float x1, const float y1, const float x2, const float y2)
ax::Quad2DGL::CreateVBO	.\model_gl.cc	/^void Quad2DGL::CreateVBO() {$/;"	f	class:ax::Quad2DGL	signature:()
ax::Quad2DGL::CreateVBO	.\model_gl.h	/^  void CreateVBO();$/;"	p	class:ax::Quad2DGL	access:private	signature:()
ax::Quad2DGL::Draw	.\model_gl.cc	/^void Quad2DGL::Draw() {$/;"	f	class:ax::Quad2DGL	signature:()
ax::Quad2DGL::Draw	.\model_gl.h	/^  void Draw();$/;"	p	class:ax::Quad2DGL	access:public	signature:()
ax::Quad2DGL::Quad2DGL	.\model_gl.h	/^  Quad2DGL(const Point &p1, const Point &p2) {$/;"	f	class:ax::Quad2DGL	access:public	signature:(const Point &p1, const Point &p2)
ax::Quad2DGL::Quad2DGL	.\model_gl.h	/^  Quad2DGL(const float x1, const float y1, const float x2, const float y2) {$/;"	f	class:ax::Quad2DGL	access:public	signature:(const float x1, const float y1, const float x2, const float y2)
ax::Quad2DGL::__anon3::i_tcoords_	.\model_gl.h	/^    int i_tcoords_[8];$/;"	m	union:ax::Quad2DGL::__anon3	access:public
ax::Quad2DGL::__anon3::tcoords_	.\model_gl.h	/^    float tcoords_[8];$/;"	m	union:ax::Quad2DGL::__anon3	access:public
ax::Quad2DGL::idx_vbo_	.\model_gl.h	/^  uint32 idx_vbo_;$/;"	m	class:ax::Quad2DGL	access:private
ax::Quad2DGL::indices_	.\model_gl.cc	/^const uint32 Quad2DGL::indices_[6] = { 0, 1, 2, 0, 2, 3 };$/;"	m	class:ax::Quad2DGL	file:
ax::Quad2DGL::indices_	.\model_gl.h	/^  static const uint32 indices_[6];$/;"	m	class:ax::Quad2DGL	access:private
ax::Quad2DGL::set_tcoord_slot	.\model_gl.h	/^  void set_tcoord_slot(const int slot) { tcoord_slot_ = slot; }$/;"	f	class:ax::Quad2DGL	access:public	signature:(const int slot)
ax::Quad2DGL::set_tcoords	.\model_gl.h	/^  void set_tcoords(const float *tcoords) {$/;"	f	class:ax::Quad2DGL	access:public	signature:(const float *tcoords)
ax::Quad2DGL::set_tcoords	.\model_gl.h	/^  void set_tcoords(const int *tcoords) {$/;"	f	class:ax::Quad2DGL	access:public	signature:(const int *tcoords)
ax::Quad2DGL::set_vertex_slot	.\model_gl.h	/^  void set_vertex_slot(const int slot) { vertex_slot_ = slot; }$/;"	f	class:ax::Quad2DGL	access:public	signature:(const int slot)
ax::Quad2DGL::tcoord_slot_	.\model_gl.h	/^  int vertex_slot_, tcoord_slot_;$/;"	m	class:ax::Quad2DGL	access:private
ax::Quad2DGL::vert_vbo_	.\model_gl.h	/^  uint32 vert_vbo_;$/;"	m	class:ax::Quad2DGL	access:private
ax::Quad2DGL::vertex_slot_	.\model_gl.h	/^  int vertex_slot_, tcoord_slot_;$/;"	m	class:ax::Quad2DGL	access:private
ax::Quad2DGL::vertices_	.\model_gl.h	/^  float vertices_[8];$/;"	m	class:ax::Quad2DGL	access:private
ax::Quad2DGL::~Quad2DGL	.\model_gl.h	/^  virtual ~Quad2DGL() { }$/;"	f	class:ax::Quad2DGL	access:public	signature:()
ax::Quad3DGL	.\model_gl.h	/^class Quad3DGL {$/;"	c	namespace:ax
ax::Quad3DGL::Quad3DGL	.\model_gl.h	/^  Quad3DGL(const Point &p1, const Point &p2, const Normal &n);$/;"	p	class:ax::Quad3DGL	access:public	signature:(const Point &p1, const Point &p2, const Normal &n)
ax::Quad3DGL::Quad3DGL	.\model_gl.h	/^  Quad3DGL(const float x1, const float y1, const float z1,$/;"	p	class:ax::Quad3DGL	access:public	signature:(const float x1, const float y1, const float z1, const float x2, const float y2, const float z2, const float nx, const float ny, const float nz)
ax::Quad3DGL::indices	.\model_gl.h	/^  static const float indices[6];$/;"	m	class:ax::Quad3DGL	access:private
ax::Quad3DGL::tcoords_	.\model_gl.h	/^  float tcoords_[8];$/;"	m	class:ax::Quad3DGL	access:private
ax::Quad3DGL::vertices_	.\model_gl.h	/^  float vertices_[12];$/;"	m	class:ax::Quad3DGL	access:private
ax::ReadSahderFile	.\shader_object.cc	/^std::string ReadSahderFile(const char *file) {$/;"	f	namespace:ax	signature:(const char *file)
ax::RenderAppI	.\utils.h	/^class RenderAppI {$/;"	c	namespace:ax
ax::RenderAppI::Create	.\utils.h	/^  static ax::RenderAppPtr Create($/;"	f	class:ax::RenderAppI	access:public	signature:( RenderAppI *app, const ax::ParamSet2 &params = ax::ParamSet2())
ax::RenderAppI::DISABLE_COPY_AND_ASSIGN	.\utils.h	/^  DISABLE_COPY_AND_ASSIGN(RenderAppI);$/;"	p	class:ax::RenderAppI	access:private	signature:(RenderAppI)
ax::RenderAppI::Initialize	.\utils.h	/^  virtual bool Initialize(const ax::ParamSet2 &params) = 0;$/;"	p	class:ax::RenderAppI	access:private	signature:(const ax::ParamSet2 &params)
ax::RenderAppI::Render	.\utils.h	/^  virtual void Render(const ax::ScenePtr scene, const ax::ParamSet2 &params) = 0;  $/;"	p	class:ax::RenderAppI	access:public	signature:(const ax::ScenePtr scene, const ax::ParamSet2 &params)
ax::RenderAppI::RenderAppI	.\utils.h	/^  RenderAppI(const std::string &name) : name_(name), width_(0), height_(0) { }$/;"	f	class:ax::RenderAppI	access:public	signature:(const std::string &name)
ax::RenderAppI::Resize	.\utils.h	/^  virtual void Resize(int w, int h) { this->width_ = w, this->height_ = h; }$/;"	f	class:ax::RenderAppI	access:public	signature:(int w, int h)
ax::RenderAppI::height	.\utils.h	/^  int height() const { return this->height_; }  $/;"	f	class:ax::RenderAppI	access:public	signature:() const
ax::RenderAppI::height_	.\utils.h	/^  int width_, height_;$/;"	m	class:ax::RenderAppI	access:private
ax::RenderAppI::name	.\utils.h	/^  const std::string &name() const { return name_; }$/;"	f	class:ax::RenderAppI	access:public	signature:() const
ax::RenderAppI::name_	.\utils.h	/^  std::string name_;$/;"	m	class:ax::RenderAppI	access:private
ax::RenderAppI::width	.\utils.h	/^  int width() const { return this->width_; }$/;"	f	class:ax::RenderAppI	access:public	signature:() const
ax::RenderAppI::width_	.\utils.h	/^  int width_, height_;$/;"	m	class:ax::RenderAppI	access:private
ax::RenderAppI::~RenderAppI	.\utils.h	/^  virtual ~RenderAppI() { }  $/;"	f	class:ax::RenderAppI	access:public	signature:()
ax::RenderAppPtr	.\utils.h	/^typedef std::tr1::shared_ptr<RenderAppI> RenderAppPtr;$/;"	t	namespace:ax
ax::RenderBuffer	.\render_buffer.h	/^class RenderBuffer {$/;"	c	namespace:ax
ax::RenderBuffer::RenderBuffer	.\render_buffer.cc	/^RenderBuffer::RenderBuffer(int width, int height, GLint internal_format) $/;"	f	class:ax::RenderBuffer	signature:(int width, int height, GLint internal_format)
ax::RenderBuffer::RenderBuffer	.\render_buffer.h	/^  RenderBuffer(int width, int height, GLint internal_format);$/;"	p	class:ax::RenderBuffer	access:public	signature:(int width, int height, GLint internal_format)
ax::RenderBuffer::buffer_id	.\render_buffer.h	/^  GLuint buffer_id() const { return buffer_id_; }$/;"	f	class:ax::RenderBuffer	access:public	signature:() const
ax::RenderBuffer::buffer_id_	.\render_buffer.h	/^  GLuint buffer_id_;$/;"	m	class:ax::RenderBuffer	access:private
ax::RenderBuffer::height	.\render_buffer.h	/^  int height() const { return height_; }$/;"	f	class:ax::RenderBuffer	access:public	signature:() const
ax::RenderBuffer::height_	.\render_buffer.h	/^  int width_, height_;$/;"	m	class:ax::RenderBuffer	access:private
ax::RenderBuffer::is_valid	.\render_buffer.h	/^  bool is_valid() const { return 0 != buffer_id_; }$/;"	f	class:ax::RenderBuffer	access:public	signature:() const
ax::RenderBuffer::width	.\render_buffer.h	/^  int width() const { return width_; }$/;"	f	class:ax::RenderBuffer	access:public	signature:() const
ax::RenderBuffer::width_	.\render_buffer.h	/^  int width_, height_;$/;"	m	class:ax::RenderBuffer	access:private
ax::RenderBuffer::~RenderBuffer	.\render_buffer.cc	/^RenderBuffer::~RenderBuffer() {$/;"	f	class:ax::RenderBuffer	signature:()
ax::RenderBuffer::~RenderBuffer	.\render_buffer.h	/^  ~RenderBuffer();$/;"	p	class:ax::RenderBuffer	access:public	signature:()
ax::RenderDeviceFBO	.\render_device_fbo.h	/^class RenderDeviceFBO {$/;"	c	namespace:ax
ax::RenderDeviceFBO::Activate	.\render_device_fbo.h	/^  void Activate() { fbo_.Bind(); }$/;"	f	class:ax::RenderDeviceFBO	access:public	signature:()
ax::RenderDeviceFBO::AdjustViewport	.\render_device_fbo.h	/^  void AdjustViewport(const T &target) {$/;"	f	class:ax::RenderDeviceFBO	access:public	signature:(const T &target)
ax::RenderDeviceFBO::AdjustViewport	.\render_device_fbo.h	/^  void AdjustViewport(int w, int h) { glViewport(0, 0, w, h); }$/;"	f	class:ax::RenderDeviceFBO	access:public	signature:(int w, int h)
ax::RenderDeviceFBO::Check	.\render_device_fbo.h	/^  void Check() { fbo_.IsValid(); }$/;"	f	class:ax::RenderDeviceFBO	access:public	signature:()
ax::RenderDeviceFBO::Create	.\render_device_fbo.h	/^  static FBODevicePtr Create() {$/;"	f	class:ax::RenderDeviceFBO	access:public	signature:()
ax::RenderDeviceFBO::Deactivate	.\render_device_fbo.h	/^  void Deactivate() { FramebufferObject::Disable(); }$/;"	f	class:ax::RenderDeviceFBO	access:public	signature:()
ax::RenderDeviceFBO::DisableColorBuffer	.\render_device_fbo.cc	/^void RenderDeviceFBO::DisableColorBuffer() {$/;"	f	class:ax::RenderDeviceFBO	signature:()
ax::RenderDeviceFBO::DisableColorBuffer	.\render_device_fbo.h	/^  void DisableColorBuffer();$/;"	p	class:ax::RenderDeviceFBO	access:public	signature:()
ax::RenderDeviceFBO::DisableDepthBuffer	.\render_device_fbo.cc	/^void RenderDeviceFBO::DisableDepthBuffer() {$/;"	f	class:ax::RenderDeviceFBO	signature:()
ax::RenderDeviceFBO::DisableDepthBuffer	.\render_device_fbo.h	/^  void DisableDepthBuffer();$/;"	p	class:ax::RenderDeviceFBO	access:public	signature:()
ax::RenderDeviceFBO::DisableStencilBuffer	.\render_device_fbo.cc	/^void RenderDeviceFBO::DisableStencilBuffer() {$/;"	f	class:ax::RenderDeviceFBO	signature:()
ax::RenderDeviceFBO::DisableStencilBuffer	.\render_device_fbo.h	/^  void DisableStencilBuffer();$/;"	p	class:ax::RenderDeviceFBO	access:public	signature:()
ax::RenderDeviceFBO::RenderDeviceFBO	.\render_device_fbo.h	/^  RenderDeviceFBO() { }$/;"	f	class:ax::RenderDeviceFBO	access:private	signature:()
ax::RenderDeviceFBO::RestoreMVP	.\render_device_fbo.cc	/^void RenderDeviceFBO::RestoreMVP() {$/;"	f	class:ax::RenderDeviceFBO	signature:()
ax::RenderDeviceFBO::RestoreMVP	.\render_device_fbo.h	/^  void RestoreMVP();$/;"	p	class:ax::RenderDeviceFBO	access:public	signature:()
ax::RenderDeviceFBO::SaveMVP	.\render_device_fbo.cc	/^void RenderDeviceFBO::SaveMVP() {$/;"	f	class:ax::RenderDeviceFBO	signature:()
ax::RenderDeviceFBO::SaveMVP	.\render_device_fbo.h	/^  void SaveMVP();$/;"	p	class:ax::RenderDeviceFBO	access:public	signature:()
ax::RenderDeviceFBO::SetDepthBuffer	.\render_device_fbo.cc	/^void RenderDeviceFBO::SetDepthBuffer(const RenderBuffer *render_buffer) {$/;"	f	class:ax::RenderDeviceFBO	signature:(const RenderBuffer *render_buffer)
ax::RenderDeviceFBO::SetDepthBuffer	.\render_device_fbo.cc	/^void RenderDeviceFBO::SetDepthBuffer(const Texture2DPtr texture) {$/;"	f	class:ax::RenderDeviceFBO	signature:(const Texture2DPtr texture)
ax::RenderDeviceFBO::SetDepthBuffer	.\render_device_fbo.h	/^  void SetDepthBuffer(const RenderBuffer *render_buffer);$/;"	p	class:ax::RenderDeviceFBO	access:public	signature:(const RenderBuffer *render_buffer)
ax::RenderDeviceFBO::SetDepthBuffer	.\render_device_fbo.h	/^  void SetDepthBuffer(const Texture2DPtr texture);$/;"	p	class:ax::RenderDeviceFBO	access:public	signature:(const Texture2DPtr texture)
ax::RenderDeviceFBO::SetRenderTarget	.\render_device_fbo.cc	/^void RenderDeviceFBO::SetRenderTarget(const RenderBuffer *render_buffer) {$/;"	f	class:ax::RenderDeviceFBO	signature:(const RenderBuffer *render_buffer)
ax::RenderDeviceFBO::SetRenderTarget	.\render_device_fbo.cc	/^void RenderDeviceFBO::SetRenderTarget(const Texture2DPtr texture, int level) {$/;"	f	class:ax::RenderDeviceFBO	signature:(const Texture2DPtr texture, int level)
ax::RenderDeviceFBO::SetRenderTarget	.\render_device_fbo.h	/^  void SetRenderTarget(const RenderBuffer *render_buffer);$/;"	p	class:ax::RenderDeviceFBO	access:public	signature:(const RenderBuffer *render_buffer)
ax::RenderDeviceFBO::SetRenderTarget	.\render_device_fbo.h	/^  void SetRenderTarget(const Texture2DPtr texture, int level = 0);$/;"	p	class:ax::RenderDeviceFBO	access:public	signature:(const Texture2DPtr texture, int level = 0)
ax::RenderDeviceFBO::SetRenderTargets	.\render_device_fbo.cc	/^void RenderDeviceFBO::SetRenderTargets($/;"	f	class:ax::RenderDeviceFBO	signature:( int target_count, const RenderBuffer *const render_buffers[])
ax::RenderDeviceFBO::SetRenderTargets	.\render_device_fbo.cc	/^void RenderDeviceFBO::SetRenderTargets(const std::vector<Texture2DPtr> &textures, int level) {$/;"	f	class:ax::RenderDeviceFBO	signature:(const std::vector<Texture2DPtr> &textures, int level)
ax::RenderDeviceFBO::SetRenderTargets	.\render_device_fbo.h	/^  void SetRenderTargets(const std::vector<Texture2DPtr> &textures, int level = 0);$/;"	p	class:ax::RenderDeviceFBO	access:public	signature:(const std::vector<Texture2DPtr> &textures, int level = 0)
ax::RenderDeviceFBO::SetRenderTargets	.\render_device_fbo.h	/^  void SetRenderTargets(int target_counts, $/;"	p	class:ax::RenderDeviceFBO	access:public	signature:(int target_counts, const RenderBuffer *const render_buffers[])
ax::RenderDeviceFBO::SetStencilBuffer	.\render_device_fbo.cc	/^void RenderDeviceFBO::SetStencilBuffer(const Texture2DPtr texture) {$/;"	f	class:ax::RenderDeviceFBO	signature:(const Texture2DPtr texture)
ax::RenderDeviceFBO::SetStencilBuffer	.\render_device_fbo.h	/^  void SetStencilBuffer(const Texture2DPtr texture);$/;"	p	class:ax::RenderDeviceFBO	access:public	signature:(const Texture2DPtr texture)
ax::RenderDeviceFBO::fbo_	.\render_device_fbo.h	/^  FramebufferObject fbo_;$/;"	m	class:ax::RenderDeviceFBO	access:private
ax::RenderDeviceFBO::s_mrt	.\render_device_fbo.cc	/^GLenum RenderDeviceFBO::s_mrt[8] = {$/;"	m	class:ax::RenderDeviceFBO	file:
ax::RenderDeviceFBO::s_mrt	.\render_device_fbo.h	/^  static GLenum s_mrt[8];$/;"	m	class:ax::RenderDeviceFBO	access:private
ax::RenderDeviceFBO::s_viewport	.\render_device_fbo.h	/^  GLint s_viewport[4];$/;"	m	class:ax::RenderDeviceFBO	access:private
ax::SaveFrameBuffer	.\gl_utils.cc	/^void SaveFrameBuffer(const char *filename) {$/;"	f	namespace:ax	signature:(const char *filename)
ax::SaveFrameBuffer	.\utils.h	/^void SaveFrameBuffer(const char *filename);$/;"	p	namespace:ax	signature:(const char *filename)
ax::SaveImage	.\image.cc	/^void SaveImage(const char *filename, const int w, const int h,$/;"	f	namespace:ax	signature:(const char *filename, const int w, const int h, uint32 depth, uint8 n_channels, uint32 format, uint32 type, const void *data)
ax::SaveImage	.\image.h	/^void SaveImage(const char *filename, const int w, const int h,$/;"	p	namespace:ax	signature:(const char *filename, const int w, const int h, uint32 depth, uint8 n_channels, uint32 format, uint32 type, const void *data)
ax::Scene	.\scene.h	/^class Scene {$/;"	c	namespace:ax
ax::Scene::Add	.\scene.h	/^  void Add(const std::string &name, MaterialPtr matl) {$/;"	f	class:ax::Scene	access:private	signature:(const std::string &name, MaterialPtr matl)
ax::Scene::Add	.\scene.h	/^  void Add(const std::string &name, ObjectPtr obj) {$/;"	f	class:ax::Scene	access:private	signature:(const std::string &name, ObjectPtr obj)
ax::Scene::Add	.\scene.h	/^  void Add(const std::string &name, Texture2DPtr tex) {$/;"	f	class:ax::Scene	access:private	signature:(const std::string &name, Texture2DPtr tex)
ax::Scene::Create	.\scene.cc	/^ScenePtr Scene::Create(const std::string &file, Options opts) {$/;"	f	class:ax::Scene	signature:(const std::string &file, Options opts)
ax::Scene::Create	.\scene.h	/^  static ScenePtr Create(const std::string &file, Options opts);$/;"	p	class:ax::Scene	access:public	signature:(const std::string &file, Options opts)
ax::Scene::DISABLE_COPY_AND_ASSIGN	.\scene.h	/^  DISABLE_COPY_AND_ASSIGN(Scene);$/;"	p	class:ax::Scene	access:private	signature:(Scene)
ax::Scene::DepthRange	.\scene.cc	/^void Scene::DepthRange(const Matrix4x4 &mat, $/;"	f	class:ax::Scene	signature:(const Matrix4x4 &mat, float *min_depth, float *max_depth) const
ax::Scene::DepthRange	.\scene.h	/^  void DepthRange(const Matrix4x4 &mat, $/;"	p	class:ax::Scene	access:public	signature:(const Matrix4x4 &mat, float *min_depth, float *max_depth) const
ax::Scene::Draw	.\scene.cc	/^void Scene::Draw(Options opts) const {  $/;"	f	class:ax::Scene	signature:(Options opts) const
ax::Scene::Draw	.\scene.cc	/^void Scene::Draw(ProgramGLSLPtr prog, Options opts) const {$/;"	f	class:ax::Scene	signature:(ProgramGLSLPtr prog, Options opts) const
ax::Scene::Draw	.\scene.h	/^  void Draw(Options opts) const;$/;"	p	class:ax::Scene	access:public	signature:(Options opts) const
ax::Scene::Draw	.\scene.h	/^  void Draw(ProgramGLSLPtr prog, Options opts) const;$/;"	p	class:ax::Scene	access:public	signature:(ProgramGLSLPtr prog, Options opts) const
ax::Scene::Load	.\scene.cc	/^bool Scene::Load(const std::string &filename) {$/;"	f	class:ax::Scene	signature:(const std::string &filename)
ax::Scene::Load	.\scene.h	/^  bool Load(const std::string &filename);$/;"	p	class:ax::Scene	access:private	signature:(const std::string &filename)
ax::Scene::LoadMaterial	.\scene.cc	/^MaterialPtr Scene::LoadMaterial(const char *buff, FILE *fp) {$/;"	f	class:ax::Scene	signature:(const char *buff, FILE *fp)
ax::Scene::LoadMaterial	.\scene.h	/^  MaterialPtr LoadMaterial(const char *type, FILE *fp);$/;"	p	class:ax::Scene	access:private	signature:(const char *type, FILE *fp)
ax::Scene::LoadObject	.\scene.cc	/^ObjectPtr Scene::LoadObject(const char *buff, FILE *fp) {$/;"	f	class:ax::Scene	signature:(const char *buff, FILE *fp)
ax::Scene::LoadObject	.\scene.h	/^  ObjectPtr LoadObject(const char *type, FILE *fp);$/;"	p	class:ax::Scene	access:private	signature:(const char *type, FILE *fp)
ax::Scene::LoadTexture	.\scene.cc	/^Texture2DPtr Scene::LoadTexture(const char *buff) {$/;"	f	class:ax::Scene	signature:(const char *buff)
ax::Scene::LoadTexture	.\scene.h	/^  Texture2DPtr LoadTexture(const char *ptr);$/;"	p	class:ax::Scene	access:private	signature:(const char *ptr)
ax::Scene::PreProcess	.\scene.cc	/^void Scene::PreProcess() {$/;"	f	class:ax::Scene	signature:()
ax::Scene::PreProcess	.\scene.h	/^  void PreProcess();$/;"	p	class:ax::Scene	access:private	signature:()
ax::Scene::Scene	.\scene.h	/^  Scene(ax::Options opts) : opts_(opts) { }$/;"	f	class:ax::Scene	access:private	signature:(ax::Options opts)
ax::Scene::bound	.\scene.h	/^  const AABB &bound() const { return bound_; }$/;"	f	class:ax::Scene	access:public	signature:() const
ax::Scene::bound_	.\scene.h	/^  AABB bound_;$/;"	m	class:ax::Scene	access:private
ax::Scene::geometry_	.\scene.h	/^  ax::GroupPtr geometry_;$/;"	m	class:ax::Scene	access:private
ax::Scene::material	.\scene.h	/^  MaterialPtr material(const std::string &name) { $/;"	f	class:ax::Scene	access:public	signature:(const std::string &name)
ax::Scene::named_matls_	.\scene.h	/^  MaterialMap named_matls_;$/;"	m	class:ax::Scene	access:private
ax::Scene::named_object	.\scene.h	/^  ObjectPtr named_object(const std::string &name) { $/;"	f	class:ax::Scene	access:public	signature:(const std::string &name)
ax::Scene::named_objs_	.\scene.h	/^  ObjectMap named_objs_;$/;"	m	class:ax::Scene	access:private
ax::Scene::named_texs_	.\scene.h	/^  TextureMap named_texs_;$/;"	m	class:ax::Scene	access:private
ax::Scene::object	.\scene.h	/^ ObjectPtr object(int i) const { return this->geometry_->object(i); }$/;"	f	class:ax::Scene	access:public	signature:(int i) const
ax::Scene::opts_	.\scene.h	/^  ax::Options opts_;$/;"	m	class:ax::Scene	access:private
ax::Scene::texture	.\scene.h	/^  Texture2DPtr texture(const std::string &name) { $/;"	f	class:ax::Scene	access:public	signature:(const std::string &name)
ax::Scene::~Scene	.\scene.cc	/^Scene::~Scene() { }$/;"	f	class:ax::Scene	signature:()
ax::Scene::~Scene	.\scene.h	/^  ~Scene();  $/;"	p	class:ax::Scene	access:public	signature:()
ax::ScenePtr	.\cg_fwd.h	/^typedef std::tr1::shared_ptr<Scene> ScenePtr;$/;"	t	namespace:ax
ax::ScopeGPUTimer	.\utils.h	/^class ScopeGPUTimer : private GPUTimer {$/;"	c	namespace:ax	inherits:GPUTimer
ax::ScopeGPUTimer::ScopeGPUTimer	.\utils.h	/^  ScopeGPUTimer(const std::string &name) : GPUTimer(name) { $/;"	f	class:ax::ScopeGPUTimer	access:public	signature:(const std::string &name)
ax::ScopeGPUTimer::~ScopeGPUTimer	.\utils.h	/^  ~ScopeGPUTimer() {$/;"	f	class:ax::ScopeGPUTimer	access:public	signature:()
ax::ScopeStatistics	.\utils.h	/^class ScopeStatistics {$/;"	c	namespace:ax
ax::ScopeStatistics::ScopeStatistics	.\utils.h	/^  ScopeStatistics(const std::string &name, ax::Options opts) : name_(name), opts_(opts) {$/;"	f	class:ax::ScopeStatistics	access:public	signature:(const std::string &name, ax::Options opts)
ax::ScopeStatistics::name_	.\utils.h	/^  const std::string name_;$/;"	m	class:ax::ScopeStatistics	access:public
ax::ScopeStatistics::opts_	.\utils.h	/^  ax::Options opts_;$/;"	m	class:ax::ScopeStatistics	access:public
ax::ScopeStatistics::timer_	.\utils.h	/^  GPUTimerPtr timer_;$/;"	m	class:ax::ScopeStatistics	access:public
ax::ScopeStatistics::~ScopeStatistics	.\utils.h	/^  ~ScopeStatistics() {$/;"	f	class:ax::ScopeStatistics	access:public	signature:()
ax::ScreenQuad	.\model_gl.h	/^class ScreenQuad : public Quad2DGL {$/;"	c	namespace:ax	inherits:Quad2DGL
ax::ScreenQuad::Create	.\model_gl.h	/^  static ScreenQuadPtr Create() {$/;"	f	class:ax::ScreenQuad	access:public	signature:()
ax::ScreenQuad::Draw	.\model_gl.cc	/^void ScreenQuad::Draw(ax::ProgramGLSLPtr prog) {$/;"	f	class:ax::ScreenQuad	signature:(ax::ProgramGLSLPtr prog)
ax::ScreenQuad::Draw	.\model_gl.h	/^  void Draw(ax::ProgramGLSLPtr prog);$/;"	p	class:ax::ScreenQuad	access:public	signature:(ax::ProgramGLSLPtr prog)
ax::ScreenQuad::ScreenQuad	.\model_gl.cc	/^ScreenQuad::ScreenQuad() : Quad2DGL(0, 0, 1, 1) {$/;"	f	class:ax::ScreenQuad	signature:()
ax::ScreenQuad::ScreenQuad	.\model_gl.h	/^  ScreenQuad();$/;"	p	class:ax::ScreenQuad	access:private	signature:()
ax::ScreenQuad::mvp	.\model_gl.h	/^  const Matrix4x4 &mvp() const { return mvp_; }$/;"	f	class:ax::ScreenQuad	access:public	signature:() const
ax::ScreenQuad::mvp_	.\model_gl.h	/^  Matrix4x4 mvp_;$/;"	m	class:ax::ScreenQuad	access:private
ax::ScreenQuad::mvp_ptr	.\model_gl.h	/^  const float *mvp_ptr() const { return &mvp_[0][0]; }$/;"	f	class:ax::ScreenQuad	access:public	signature:() const
ax::ScreenQuadPtr	.\cg_fwd.h	/^typedef std::tr1::shared_ptr<ScreenQuad> ScreenQuadPtr;$/;"	t	namespace:ax
ax::ScreenQuadPtr	.\model_gl.h	/^typedef std::tr1::shared_ptr<ScreenQuad> ScreenQuadPtr;$/;"	t	namespace:ax
ax::ShaderObject	.\shader_object.h	/^class ShaderObject : public GLObject {$/;"	c	namespace:ax	inherits:GLObject
ax::ShaderObject::CheckCompileLog	.\shader_object.cc	/^bool ShaderObject::CheckCompileLog() {$/;"	f	class:ax::ShaderObject	signature:()
ax::ShaderObject::CheckCompileLog	.\shader_object.h	/^  bool CheckCompileLog();$/;"	p	class:ax::ShaderObject	access:private	signature:()
ax::ShaderObject::Create	.\shader_object.h	/^  static ShaderPtr Create(int type, const char *file, const MacroList &macros = MacroList()) {$/;"	f	class:ax::ShaderObject	access:public	signature:(int type, const char *file, const MacroList &macros = MacroList())
ax::ShaderObject::CreateFromCode	.\shader_object.h	/^  static ShaderPtr CreateFromCode(int type, const char *code, const char *name = "") {$/;"	f	class:ax::ShaderObject	access:public	signature:(int type, const char *code, const char *name = Ó)
ax::ShaderObject::DeleteShader	.\shader_object.cc	/^void ShaderObject::DeleteShader() {$/;"	f	class:ax::ShaderObject	signature:()
ax::ShaderObject::DeleteShader	.\shader_object.h	/^  void DeleteShader();$/;"	p	class:ax::ShaderObject	access:private	signature:()
ax::ShaderObject::Load	.\shader_object.cc	/^bool ShaderObject::Load(int type, const char *file, const MacroList &macros) {$/;"	f	class:ax::ShaderObject	signature:(int type, const char *file, const MacroList &macros)
ax::ShaderObject::Load	.\shader_object.h	/^  bool Load(int type, const char *file, const MacroList &macros = MacroList());$/;"	p	class:ax::ShaderObject	access:private	signature:(int type, const char *file, const MacroList &macros = MacroList())
ax::ShaderObject::LoadCode	.\shader_object.cc	/^bool ShaderObject::LoadCode(int type, const char *code) {$/;"	f	class:ax::ShaderObject	signature:(int type, const char *code)
ax::ShaderObject::LoadCode	.\shader_object.h	/^  bool LoadCode(int type, const char *code);$/;"	p	class:ax::ShaderObject	access:private	signature:(int type, const char *code)
ax::ShaderObject::PrintCompileLog	.\shader_object.cc	/^void ShaderObject::PrintCompileLog() {$/;"	f	class:ax::ShaderObject	signature:()
ax::ShaderObject::PrintCompileLog	.\shader_object.h	/^  void PrintCompileLog(); $/;"	p	class:ax::ShaderObject	access:private	signature:()
ax::ShaderObject::ShaderObject	.\shader_object.h	/^  ShaderObject(const std::string name = "") : GLObject(name) { };$/;"	f	class:ax::ShaderObject	access:private	signature:(const std::string name = Ó)
ax::ShaderObject::~ShaderObject	.\shader_object.h	/^  ~ShaderObject() { this->DeleteShader(); }$/;"	f	class:ax::ShaderObject	access:public	signature:()
ax::ShaderPtr	.\cg_fwd.h	/^typedef std::tr1::shared_ptr<ShaderObject> ShaderPtr;$/;"	t	namespace:ax
ax::SpectatorMotion	.\camera.h	/^class SpectatorMotion : public Motion {$/;"	c	namespace:ax	inherits:Motion
ax::SpectatorMotion::Fly	.\camera.h	/^  virtual void Fly(float units);$/;"	p	class:ax::SpectatorMotion	access:public	signature:(float units)
ax::SpectatorMotion::Strafe	.\camera.h	/^  virtual void Strafe(float units);$/;"	p	class:ax::SpectatorMotion	access:public	signature:(float units)
ax::SpectatorMotion::Walk	.\camera.cc	/^void SpectatorMotion::Walk(float units) {$/;"	f	class:ax::SpectatorMotion	signature:(float units)
ax::SpectatorMotion::Walk	.\camera.h	/^  virtual void Walk(float units);$/;"	p	class:ax::SpectatorMotion	access:public	signature:(float units)
ax::StatisticsOption	.\utils.h	/^enum StatisticsOption {$/;"	g	namespace:ax
ax::StripLeading	.\parser.cc	/^const char *StripLeading(const char *str) {  $/;"	f	namespace:ax	signature:(const char *str)
ax::StripLeading	.\parser.h	/^const char *StripLeading(const char *str);$/;"	p	namespace:ax	signature:(const char *str)
ax::StripToken	.\parser.cc	/^const char *StripToken(const char *ptr, char *token) {$/;"	f	namespace:ax	signature:(const char *ptr, char *token)
ax::StripToken	.\parser.h	/^const char *StripToken(const char *ptr, char *token);$/;"	p	namespace:ax	signature:(const char *ptr, char *token)
ax::Texture2D	.\texture_gl.h	/^class Texture2D : public TextureGL {$/;"	c	namespace:ax	inherits:TextureGL
ax::Texture2D::Create	.\texture_gl.h	/^  static Texture2DPtr Create(int target, const std::string &name = "") {$/;"	f	class:ax::Texture2D	access:public	signature:(int target, const std::string &name = Ó)
ax::Texture2D::Create2D	.\texture_gl.h	/^  static Texture2DPtr Create2D(const std::string &name = "") {$/;"	f	class:ax::Texture2D	access:public	signature:(const std::string &name = Ó)
ax::Texture2D::CreateRect	.\texture_gl.h	/^  static Texture2DPtr CreateRect(const std::string &name = "") {$/;"	f	class:ax::Texture2D	access:public	signature:(const std::string &name = Ó)
ax::Texture2D::GenerateMipmap	.\texture_gl.h	/^  void GenerateMipmap() { $/;"	f	class:ax::Texture2D	access:public	signature:()
ax::Texture2D::GetTextureImage	.\texture_gl.cc	/^ImagePtr Texture2D::GetTextureImage(int level, int format,  int type, $/;"	f	class:ax::Texture2D	signature:(int level, int format, int type, int n_channels, int depth) const
ax::Texture2D::GetTextureImage	.\texture_gl.h	/^  ImagePtr GetTextureImage(int level, int format=GL_RGBA, $/;"	p	class:ax::Texture2D	access:public	signature:(int level, int format=GL_RGBA, int type=GL_UNSIGNED_BYTE, int n_channels=4, int depth=1) const
ax::Texture2D::Initialize	.\texture_gl.cc	/^bool Texture2D::Initialize(const Image &image, int i_format) {$/;"	f	class:ax::Texture2D	signature:(const Image &image, int i_format)
ax::Texture2D::Initialize	.\texture_gl.cc	/^bool Texture2D::Initialize(int w, int h, int i_format) {$/;"	f	class:ax::Texture2D	signature:(int w, int h, int i_format)
ax::Texture2D::Initialize	.\texture_gl.h	/^  bool Initialize(const Image &image, int i_format);$/;"	p	class:ax::Texture2D	access:public	signature:(const Image &image, int i_format)
ax::Texture2D::Initialize	.\texture_gl.h	/^  bool Initialize(int w, int h, int i_format);$/;"	p	class:ax::Texture2D	access:public	signature:(int w, int h, int i_format)
ax::Texture2D::InitializeDepth	.\texture_gl.cc	/^bool Texture2D::InitializeDepth(int w, int h, int i_format) {$/;"	f	class:ax::Texture2D	signature:(int w, int h, int i_format)
ax::Texture2D::InitializeDepth	.\texture_gl.h	/^  bool InitializeDepth(int w, int h, int i_format);$/;"	p	class:ax::Texture2D	access:public	signature:(int w, int h, int i_format)
ax::Texture2D::Save	.\texture_gl.cc	/^void Texture2D::Save(const char *filename, int level) const {$/;"	f	class:ax::Texture2D	signature:(const char *filename, int level) const
ax::Texture2D::Save	.\texture_gl.h	/^  void Save(const char *filename, int level = 0) const;$/;"	p	class:ax::Texture2D	access:public	signature:(const char *filename, int level = 0) const
ax::Texture2D::Save	.\texture_gl.h	/^  void Save(const char *filename, int level, int format, int type,$/;"	p	class:ax::Texture2D	access:public	signature:(const char *filename, int level, int format, int type, void *data) const
ax::Texture2D::Texture2D	.\texture_gl.h	/^  Texture2D(uint32 target, const std::string &name) : $/;"	f	class:ax::Texture2D	access:private	signature:(uint32 target, const std::string &name)
ax::Texture2DPtr	.\cg_fwd.h	/^typedef std::tr1::shared_ptr<Texture2D> Texture2DPtr;$/;"	t	namespace:ax
ax::Texture3D	.\texture_gl.h	/^class Texture3D : public TextureGL {$/;"	c	namespace:ax	inherits:TextureGL
ax::Texture3D::Create	.\texture_gl.h	/^  static Texture3DPtr Create(int target, const std::string &name = "") {$/;"	f	class:ax::Texture3D	access:public	signature:(int target, const std::string &name = Ó)
ax::Texture3D::Initialize	.\texture_gl.cc	/^bool Texture3D::Initialize(int w, int h, int z, int i_format) {$/;"	f	class:ax::Texture3D	signature:(int w, int h, int z, int i_format)
ax::Texture3D::Initialize	.\texture_gl.h	/^  bool Initialize(int w, int h, int z, int i_format);$/;"	p	class:ax::Texture3D	access:public	signature:(int w, int h, int z, int i_format)
ax::Texture3D::Save	.\texture_gl.cc	/^void Texture3D::Save(const char *filename, int z, int level) const {$/;"	f	class:ax::Texture3D	signature:(const char *filename, int z, int level) const
ax::Texture3D::Save	.\texture_gl.h	/^  void Save(const char *filename, int z, int level = 0) const;   $/;"	p	class:ax::Texture3D	access:public	signature:(const char *filename, int z, int level = 0) const
ax::Texture3D::Texture3D	.\texture_gl.h	/^  Texture3D(int target, const std::string &name) $/;"	f	class:ax::Texture3D	access:private	signature:(int target, const std::string &name)
ax::Texture3D::depth	.\texture_gl.h	/^  int depth() const { return depth_; }$/;"	f	class:ax::Texture3D	access:public	signature:() const
ax::Texture3D::depth_	.\texture_gl.h	/^  int depth_;  $/;"	m	class:ax::Texture3D	access:private
ax::Texture3DPtr	.\cg_fwd.h	/^typedef std::tr1::shared_ptr<Texture3D> Texture3DPtr;$/;"	t	namespace:ax
ax::TextureCopier	.\utils.h	/^class TextureCopier {$/;"	c	namespace:ax
ax::TextureCopier::Copy	.\gl_utils.cc	/^void TextureCopier::Copy(ax::Texture2DPtr texture) {$/;"	f	class:ax::TextureCopier	signature:(ax::Texture2DPtr texture)
ax::TextureCopier::Copy	.\gl_utils.cc	/^void TextureCopier::Copy(ax::Texture2DPtr texture, int width, int height) {$/;"	f	class:ax::TextureCopier	signature:(ax::Texture2DPtr texture, int width, int height)
ax::TextureCopier::Copy	.\utils.h	/^  static void Copy(ax::Texture2DPtr texture);$/;"	p	class:ax::TextureCopier	access:public	signature:(ax::Texture2DPtr texture)
ax::TextureCopier::Copy	.\utils.h	/^  static void Copy(ax::Texture2DPtr, int width, int height);$/;"	p	class:ax::TextureCopier	access:public	signature:(ax::Texture2DPtr, int width, int height)
ax::TextureCopier::CopyTexture2D	.\gl_utils.cc	/^void TextureCopier::CopyTexture2D(ax::Texture2DPtr texture) {$/;"	f	class:ax::TextureCopier	signature:(ax::Texture2DPtr texture)
ax::TextureCopier::CopyTexture2D	.\utils.h	/^  static void CopyTexture2D(ax::Texture2DPtr texture);$/;"	p	class:ax::TextureCopier	access:private	signature:(ax::Texture2DPtr texture)
ax::TextureCopier::CopyTextureRect	.\gl_utils.cc	/^void TextureCopier::CopyTextureRect(ax::Texture2DPtr texture) {$/;"	f	class:ax::TextureCopier	signature:(ax::Texture2DPtr texture)
ax::TextureCopier::CopyTextureRect	.\utils.h	/^  static void CopyTextureRect(ax::Texture2DPtr texture);$/;"	p	class:ax::TextureCopier	access:private	signature:(ax::Texture2DPtr texture)
ax::TextureCopier::DrawFullScreenQuad	.\gl_utils.cc	/^void TextureCopier::DrawFullScreenQuad(ax::ProgramGLSLPtr prog) {$/;"	f	class:ax::TextureCopier	signature:(ax::ProgramGLSLPtr prog)
ax::TextureCopier::DrawFullScreenQuad	.\utils.h	/^  static void DrawFullScreenQuad(ax::ProgramGLSLPtr prog);$/;"	p	class:ax::TextureCopier	access:private	signature:(ax::ProgramGLSLPtr prog)
ax::TextureGL	.\texture_gl.h	/^class TextureGL : public GLObject {$/;"	c	namespace:ax	inherits:GLObject
ax::TextureGL::Bind	.\texture_gl.h	/^  void Bind() const { glBindTexture(this->target(), this->id()); }$/;"	f	class:ax::TextureGL	access:public	signature:() const
ax::TextureGL::BindImageTexture	.\texture_gl.h	/^  void BindImageTexture(int32 level, bool layered, int32 layer, uint32 access, uint32 format) {$/;"	f	class:ax::TextureGL	access:public	signature:(int32 level, bool layered, int32 layer, uint32 access, uint32 format)
ax::TextureGL::BindImageTexture	.\texture_gl.h	/^  void BindImageTexture(uint32 unit, int32 level, $/;"	f	class:ax::TextureGL	access:public	signature:(uint32 unit, int32 level, bool layered, int32 layer, uint32 access, uint32 format)
ax::TextureGL::DISABLE_COPY_AND_ASSIGN	.\texture_gl.h	/^  DISABLE_COPY_AND_ASSIGN(TextureGL);$/;"	p	class:ax::TextureGL	access:private	signature:(TextureGL)
ax::TextureGL::Disable	.\texture_gl.h	/^  void Disable() const { glDisable(this->target()); }$/;"	f	class:ax::TextureGL	access:public	signature:() const
ax::TextureGL::Enable	.\texture_gl.h	/^  void Enable() const { glEnable(this->target()); }$/;"	f	class:ax::TextureGL	access:public	signature:() const
ax::TextureGL::ImageUnit	.\texture_gl.h	/^  int ImageUnit() const { $/;"	f	class:ax::TextureGL	access:public	signature:() const
ax::TextureGL::Set	.\texture_gl.h	/^  void Set(int w, int h, int iformat) {$/;"	f	class:ax::TextureGL	access:protected	signature:(int w, int h, int iformat)
ax::TextureGL::SetDefaultParameters	.\texture_gl.cc	/^void TextureGL::SetDefaultParameters() {$/;"	f	class:ax::TextureGL	signature:()
ax::TextureGL::SetDefaultParameters	.\texture_gl.h	/^  void SetDefaultParameters();$/;"	p	class:ax::TextureGL	access:public	signature:()
ax::TextureGL::SetParameter	.\texture_gl.h	/^  void SetParameter(uint32 name, float *val) {$/;"	f	class:ax::TextureGL	access:public	signature:(uint32 name, float *val)
ax::TextureGL::SetParameter	.\texture_gl.h	/^  void SetParameter(uint32 name, float val) {$/;"	f	class:ax::TextureGL	access:public	signature:(uint32 name, float val)
ax::TextureGL::SetParameter	.\texture_gl.h	/^  void SetParameter(uint32 name, int32 *val) {$/;"	f	class:ax::TextureGL	access:public	signature:(uint32 name, int32 *val)
ax::TextureGL::SetParameter	.\texture_gl.h	/^  void SetParameter(uint32 name, int32 val) {$/;"	f	class:ax::TextureGL	access:public	signature:(uint32 name, int32 val)
ax::TextureGL::TextureGL	.\texture_gl.h	/^  TextureGL(uint32 target, const std::string &name) $/;"	f	class:ax::TextureGL	access:public	signature:(uint32 target, const std::string &name)
ax::TextureGL::Unbind	.\texture_gl.h	/^  void Unbind() const { glBindTexture(this->target(), 0); }$/;"	f	class:ax::TextureGL	access:public	signature:() const
ax::TextureGL::height	.\texture_gl.h	/^  int height() const { return height_; }$/;"	f	class:ax::TextureGL	access:public	signature:() const
ax::TextureGL::height_	.\texture_gl.h	/^  int height_;$/;"	m	class:ax::TextureGL	access:private
ax::TextureGL::iformat	.\texture_gl.h	/^  int iformat() const { return iformat_; }$/;"	f	class:ax::TextureGL	access:public	signature:() const
ax::TextureGL::iformat_	.\texture_gl.h	/^  int iformat_;$/;"	m	class:ax::TextureGL	access:private
ax::TextureGL::is_valid	.\texture_gl.h	/^  bool is_valid() const { return 0 != this->id(); }$/;"	f	class:ax::TextureGL	access:public	signature:() const
ax::TextureGL::target	.\texture_gl.h	/^  uint32 target() const { return target_; }$/;"	f	class:ax::TextureGL	access:public	signature:() const
ax::TextureGL::target_	.\texture_gl.h	/^  uint32 target_;$/;"	m	class:ax::TextureGL	access:private
ax::TextureGL::unit_id_	.\texture_gl.h	/^  int unit_id_;$/;"	m	class:ax::TextureGL	access:private
ax::TextureGL::unit_mgr_	.\texture_gl.cc	/^UnitIdManager TextureGL::unit_mgr_;$/;"	m	class:ax::TextureGL	file:
ax::TextureGL::unit_mgr_	.\texture_gl.h	/^  static ax::UnitIdManager unit_mgr_;$/;"	m	class:ax::TextureGL	access:private
ax::TextureGL::width	.\texture_gl.h	/^  int width() const { return width_; }$/;"	f	class:ax::TextureGL	access:public	signature:() const
ax::TextureGL::width_	.\texture_gl.h	/^  int width_;$/;"	m	class:ax::TextureGL	access:private
ax::TextureGL::~TextureGL	.\texture_gl.h	/^  virtual ~TextureGL() {$/;"	f	class:ax::TextureGL	access:public	signature:()
ax::TextureMap	.\scene.h	/^typedef std::map<std::string, ax::Texture2DPtr> TextureMap;$/;"	t	namespace:ax
ax::TextureUtil	.\utils.h	/^class TextureUtil {$/;"	c	namespace:ax
ax::TextureUtil::CreateCustomMipmap	.\gl_utils.cc	/^int TextureUtil::CreateCustomMipmap(ax::ProgramGLSLPtr shader, ax::Texture2DPtr texture, int min_res) {$/;"	f	class:ax::TextureUtil	signature:(ax::ProgramGLSLPtr shader, ax::Texture2DPtr texture, int min_res)
ax::TextureUtil::CreateCustomMipmap	.\utils.h	/^  static int CreateCustomMipmap(ax::ProgramGLSLPtr shader, ax::Texture2DPtr texture, int min_res = 2);$/;"	p	class:ax::TextureUtil	access:public	signature:(ax::ProgramGLSLPtr shader, ax::Texture2DPtr texture, int min_res = 2)
ax::TextureUtil::CreateMaxDepthDerivativeTexture	.\gl_utils.cc	/^void TextureUtil::CreateMaxDepthDerivativeTexture($/;"	f	class:ax::TextureUtil	signature:( ax::Texture2DPtr position_tex, ax::Texture2DPtr texture)
ax::TextureUtil::CreateMaxDepthDerivativeTexture	.\utils.h	/^  void CreateMaxDepthDerivativeTexture(ax::Texture2DPtr position_tex,$/;"	p	class:ax::TextureUtil	access:public	signature:(ax::Texture2DPtr position_tex, ax::Texture2DPtr texture)
ax::TextureUtil::CreateMinMaxNormalTexture	.\gl_utils.cc	/^void TextureUtil::CreateMinMaxNormalTexture($/;"	f	class:ax::TextureUtil	signature:( ax::Texture2DPtr normal_tex, ax::Texture2DPtr texture)
ax::TextureUtil::CreateMinMaxNormalTexture	.\utils.h	/^  void CreateMinMaxNormalTexture(ax::Texture2DPtr normal_tex,$/;"	p	class:ax::TextureUtil	access:public	signature:(ax::Texture2DPtr normal_tex, ax::Texture2DPtr texture)
ax::TextureUtil::DISABLE_COPY_AND_ASSIGN	.\utils.h	/^  DISABLE_COPY_AND_ASSIGN(TextureUtil);$/;"	p	class:ax::TextureUtil	access:private	signature:(TextureUtil)
ax::TextureUtil::Initiaialze	.\gl_utils.cc	/^bool TextureUtil::Initiaialze() {$/;"	f	class:ax::TextureUtil	signature:()
ax::TextureUtil::Initiaialze	.\utils.h	/^  static bool Initiaialze();$/;"	p	class:ax::TextureUtil	access:private	signature:()
ax::TextureUtil::ReduceMinMax	.\gl_utils.cc	/^void TextureUtil::ReduceMinMax(ax::ImagePtr img, float *ret) {$/;"	f	class:ax::TextureUtil	signature:(ax::ImagePtr img, float *ret)
ax::TextureUtil::ReduceMinMax	.\gl_utils.cc	/^void TextureUtil::ReduceMinMax(ax::Texture2DPtr tex, float *ret) {$/;"	f	class:ax::TextureUtil	signature:(ax::Texture2DPtr tex, float *ret)
ax::TextureUtil::ReduceMinMax	.\utils.h	/^  static void ReduceMinMax(ax::ImagePtr img, float *ret);  $/;"	p	class:ax::TextureUtil	access:public	signature:(ax::ImagePtr img, float *ret)
ax::TextureUtil::ReduceMinMax	.\utils.h	/^  static void ReduceMinMax(ax::Texture2DPtr tex, float *ret);$/;"	p	class:ax::TextureUtil	access:public	signature:(ax::Texture2DPtr tex, float *ret)
ax::TextureUtil::TextureUtil	.\utils.h	/^  TextureUtil() { }$/;"	f	class:ax::TextureUtil	access:public	signature:()
ax::TextureUtil::device_	.\utils.h	/^  static ax::FBODevicePtr device_;$/;"	m	class:ax::TextureUtil	access:private
ax::TextureUtil::max_depth_derivative_prog_	.\utils.h	/^  ax::ProgramGLSLPtr max_depth_derivative_prog_;$/;"	m	class:ax::TextureUtil	access:private
ax::TextureUtil::min_max_normal_prog_	.\utils.h	/^  ax::ProgramGLSLPtr min_max_normal_prog_;  $/;"	m	class:ax::TextureUtil	access:private
ax::TextureUtil::quad_	.\utils.h	/^  static ax::ScreenQuadPtr quad_;  $/;"	m	class:ax::TextureUtil	access:private
ax::ToLower	.\parser.cc	/^void ToLower(char *str) {$/;"	f	namespace:ax	signature:(char *str)
ax::ToLower	.\parser.h	/^void ToLower(char *str);$/;"	p	namespace:ax	signature:(char *str)
ax::TrackableI	.\camera.h	/^class TrackableI {$/;"	c	namespace:ax
ax::TrackableI::Capture	.\camera.h	/^  void Capture(int x, int y) {$/;"	f	class:ax::TrackableI	access:public	signature:(int x, int y)
ax::TrackableI::Release	.\camera.h	/^  void Release() { is_captured_ = false; }$/;"	f	class:ax::TrackableI	access:public	signature:()
ax::TrackableI::ResizeWindow	.\camera.h	/^  void ResizeWindow(int w, int h) { w_ = w; h_ = h; }$/;"	f	class:ax::TrackableI	access:public	signature:(int w, int h)
ax::TrackableI::TrackableI	.\camera.h	/^  TrackableI() : is_captured_(false), w_(1), h_(1), scale_(1.f) { }$/;"	f	class:ax::TrackableI	access:public	signature:()
ax::TrackableI::Update	.\camera.h	/^  bool Update(int x, int y) {$/;"	f	class:ax::TrackableI	access:public	signature:(int x, int y)
ax::TrackableI::UpdateObject	.\camera.h	/^  virtual void UpdateObject(float x, float y) = 0;$/;"	p	class:ax::TrackableI	access:private	signature:(float x, float y)
ax::TrackableI::Zoom	.\camera.h	/^  void Zoom(float f) { scale_ *= f; }$/;"	f	class:ax::TrackableI	access:public	signature:(float f)
ax::TrackableI::h_	.\camera.h	/^  int w_, h_;$/;"	m	class:ax::TrackableI	access:protected
ax::TrackableI::is_captured_	.\camera.h	/^  bool is_captured_;$/;"	m	class:ax::TrackableI	access:protected
ax::TrackableI::old_x_	.\camera.h	/^  int old_x_, old_y_;$/;"	m	class:ax::TrackableI	access:protected
ax::TrackableI::old_y_	.\camera.h	/^  int old_x_, old_y_;$/;"	m	class:ax::TrackableI	access:protected
ax::TrackableI::scale_	.\camera.h	/^  float scale_;$/;"	m	class:ax::TrackableI	access:protected
ax::TrackableI::w_	.\camera.h	/^  int w_, h_;$/;"	m	class:ax::TrackableI	access:protected
ax::TriMeshGLM	.\trimesh_glmmodel.h	/^class TriMeshGLM : public ax::TriangleMesh {$/;"	c	namespace:ax	inherits:ax::TriangleMesh
ax::TriMeshGLM::Create	.\trimesh_glmmodel.h	/^  static TriMeshPtr Create(GLMmodelPtr model, ax::Options opts) {$/;"	f	class:ax::TriMeshGLM	access:public	signature:(GLMmodelPtr model, ax::Options opts)
ax::TriMeshGLM::Expand	.\trimesh_glmmodel.cc	/^void TriMeshGLM::Expand(GLMmodelPtr model) {$/;"	f	class:ax::TriMeshGLM	signature:(GLMmodelPtr model)
ax::TriMeshGLM::Expand	.\trimesh_glmmodel.h	/^  void Expand(GLMmodelPtr model);$/;"	p	class:ax::TriMeshGLM	access:private	signature:(GLMmodelPtr model)
ax::TriMeshGLM::GenAdjacency	.\trimesh_glmmodel.cc	/^void TriMeshGLM::GenAdjacency(GLMmodelPtr model) {  $/;"	f	class:ax::TriMeshGLM	signature:(GLMmodelPtr model)
ax::TriMeshGLM::GenAdjacency	.\trimesh_glmmodel.h	/^  void GenAdjacency(GLMmodelPtr model);$/;"	p	class:ax::TriMeshGLM	access:private	signature:(GLMmodelPtr model)
ax::TriMeshGLM::LoadFromGLMmodel	.\trimesh_glmmodel.cc	/^void TriMeshGLM::LoadFromGLMmodel(GLMmodelPtr model, ax::Options opts) {$/;"	f	class:ax::TriMeshGLM	signature:(GLMmodelPtr model, ax::Options opts)
ax::TriMeshGLM::LoadFromGLMmodel	.\trimesh_glmmodel.h	/^  void LoadFromGLMmodel(GLMmodelPtr model, ax::Options opts);$/;"	p	class:ax::TriMeshGLM	access:private	signature:(GLMmodelPtr model, ax::Options opts)
ax::TriMeshGLM::TriMeshGLM	.\trimesh_glmmodel.h	/^  TriMeshGLM() { }$/;"	f	class:ax::TriMeshGLM	access:private	signature:()
ax::TriVertAttribIdx	.\glmesh-loader.cc	/^typedef size_t TriVertAttribIdx(const GLMmodel *model, size_t tri, size_t vidx);$/;"	t	namespace:ax	file:
ax::UnitIdManager	.\texture_gl.h	/^class UnitIdManager {$/;"	c	namespace:ax
ax::UnitIdManager::kMaxUnit	.\texture_gl.h	/^  static const int kMaxUnit = 16;$/;"	m	class:ax::UnitIdManager	access:private
ax::UnitIdManager::nextId	.\texture_gl.h	/^  int nextId() {$/;"	f	class:ax::UnitIdManager	access:public	signature:()
ax::UnitIdManager::next_id_	.\texture_gl.cc	/^int UnitIdManager::next_id_ = 0;$/;"	m	class:ax::UnitIdManager	file:
ax::UnitIdManager::next_id_	.\texture_gl.h	/^  static int next_id_;$/;"	m	class:ax::UnitIdManager	access:private
ax::Unknown	.\parser.h	/^inline void Unknown(const char *type, const char *type_name, $/;"	f	namespace:ax	signature:(const char *type, const char *type_name, const char *obj_type)
ax::UnknownCommand	.\parser.h	/^inline void UnknownCommand(const char *cmd, const char *obj_type) {$/;"	f	namespace:ax	signature:(const char *cmd, const char *obj_type)
ax::UnknownKeyword	.\parser.h	/^inline void UnknownKeyword(const char *keyword, const char *obj_type) {$/;"	f	namespace:ax	signature:(const char *keyword, const char *obj_type)
ax::Unsupported	.\parser.h	/^inline void Unsupported(const char *obj_type, const char *obj) {$/;"	f	namespace:ax	signature:(const char *obj_type, const char *obj)
ax::VOffset	.\glmesh-loader.cc	/^size_t VOffset(const Idxs &nidxs, size_t nidx) {$/;"	f	namespace:ax	signature:(const Idxs &nidxs, size_t nidx)
ax::VertAttribStastics	.\glmesh-loader.cc	/^void VertAttribStastics(const GLMmodel *model, VertAttribsVec *vert_attribs,$/;"	f	namespace:ax	signature:(const GLMmodel *model, VertAttribsVec *vert_attribs, TriVertAttribIdx attrib)
ax::VertAttribsVec	.\glmesh-loader.cc	/^typedef Array<Idxs> VertAttribsVec;$/;"	t	namespace:ax	file:
ax::VisualizeTexture	.\gl_utils.cc	/^void VisualizeTexture(const Texture2DPtr tex, bool full_screen) {  $/;"	f	namespace:ax	signature:(const Texture2DPtr tex, bool full_screen)
ax::VisualizeTexture	.\utils.h	/^void VisualizeTexture(const Texture2DPtr tex, bool full_screen = false);$/;"	p	namespace:ax	signature:(const Texture2DPtr tex, bool full_screen = false)
ax::VisualizeViewSpace	.\utils.h	/^void VisualizeViewSpace(const C &camera, float alpha = 0.5f) {$/;"	f	namespace:ax	signature:(const C &camera, float alpha = 0.5f)
ax::__ParamSet	.\params.h	/^struct __ParamSet {$/;"	s	namespace:ax
ax::__ParamSet2	.\params.h	/^struct __ParamSet2 : public __ParamSet<T> {$/;"	s	namespace:ax	inherits:__ParamSet
ax::__ParamSet2::GetPtr	.\params.h	/^  PTR GetPtr(const KeyType &key) const { return (PTR)this->GetRawPtr(key); }$/;"	f	struct:ax::__ParamSet2	access:public	signature:(const KeyType &key) const
ax::__ParamSet2::KeyType	.\params.h	/^  typedef typename __ParamSet<T>::KeyType KeyType;$/;"	t	struct:ax::__ParamSet2	access:public
ax::__ParamSet2::SetPtr	.\params.h	/^  void SetPtr(const KeyType &key, PTR ptr) { this->SetRawPtr(key, (const void*)ptr); }$/;"	f	struct:ax::__ParamSet2	access:public	signature:(const KeyType &key, PTR ptr)
ax::__ParamSet::KeyType	.\params.h	/^  typedef T KeyType;$/;"	t	struct:ax::__ParamSet	access:public
ax::ax::FBParams::kBufferName	.\gl_buffer.cc	/^const std::string ax::FBParams::kBufferName = "frame buffer name";$/;"	m	class:ax::ax::FBParams	file:
ax::ax::FBParams::kColorBufferCount	.\gl_buffer.cc	/^const std::string ax::FBParams::kColorBufferCount = "frame buffer color buffer count";$/;"	m	class:ax::ax::FBParams	file:
ax::ax::FBParams::kColorFormat	.\gl_buffer.cc	/^const std::string ax::FBParams::kColorFormat = "frame buffer color format";$/;"	m	class:ax::ax::FBParams	file:
ax::ax::FBParams::kDepthFormat	.\gl_buffer.cc	/^const std::string ax::FBParams::kDepthFormat = "frame buffer depth format";$/;"	m	class:ax::ax::FBParams	file:
ax::ax::FBParams::kHasDepthBuffer	.\gl_buffer.cc	/^const std::string ax::FBParams::kHasDepthBuffer = "frame buffer has depth buffer";$/;"	m	class:ax::ax::FBParams	file:
ax::ax::FBParams::kHasStencilBuffer	.\gl_buffer.cc	/^const std::string ax::FBParams::kHasStencilBuffer = "frame buffer has stencil buffer";$/;"	m	class:ax::ax::FBParams	file:
ax::ax::FBParams::kTextureTarget	.\gl_buffer.cc	/^const std::string ax::FBParams::kTextureTarget = "frame buffer texture target";$/;"	m	class:ax::ax::FBParams	file:
ax::ax::TextureUtil::device_	.\gl_utils.cc	/^ax::FBODevicePtr ax::TextureUtil::device_;$/;"	m	class:ax::ax::TextureUtil	file:
ax::ax::TextureUtil::quad_	.\gl_utils.cc	/^ax::ScreenQuadPtr ax::TextureUtil::quad_;$/;"	m	class:ax::ax::TextureUtil	file:
ax::copy_tex_2d_src	.\gl_utils.cc	/^const char *copy_tex_2d_src = $/;"	m	namespace:ax	file:
ax::copy_tex_rect_src	.\gl_utils.cc	/^const char *copy_tex_rect_src =$/;"	m	namespace:ax	file:
ax::kComputeBound	.\cg_fwd.h	/^  kComputeBound = 1, $/;"	e	enum:ax::__anon2
ax::kCopyTexture2D	.\utils.h	/^  kCopyTexture2D,  $/;"	e	enum:ax::__anon4
ax::kCopyTextureRect	.\utils.h	/^  kCopyTextureRect,$/;"	e	enum:ax::__anon4
ax::kDepthTexture	.\image_texture_gl.h	/^kDepthTexture = 0x00000004$/;"	e	enum:ax::ImageTextureGLOptions
ax::kGenNormal	.\cg_fwd.h	/^  kGenNormal = 4,$/;"	e	enum:ax::__anon2
ax::kGenTexcoord	.\cg_fwd.h	/^  kGenTexcoord = 8,$/;"	e	enum:ax::__anon2
ax::kIgnoreGroup	.\cg_fwd.h	/^  kIgnoreGroup = 16,$/;"	e	enum:ax::__anon2
ax::kLightPositionParam	.\utils.h	/^const std::string kLightPositionParam = "light position";$/;"	m	namespace:ax
ax::kMVPMatrixParam	.\utils.h	/^const std::string kMVPMatrixParam = "mvp matrix";$/;"	m	namespace:ax
ax::kNeedAdjacency	.\cg_fwd.h	/^  kNeedAdjacency = 32$/;"	e	enum:ax::__anon2
ax::kNone	.\cg_fwd.h	/^  kNone = 0,$/;"	e	enum:ax::__anon2
ax::kNone	.\image_texture_gl.h	/^kNone = 0,$/;"	e	enum:ax::ImageTextureGLOptions
ax::kSceneOptionParam	.\utils.h	/^const std::string kSceneOptionParam = "scene option";$/;"	m	namespace:ax
ax::kStatNone	.\utils.h	/^  kStatNone = 0,$/;"	e	enum:ax::StatisticsOption
ax::kStatTime	.\utils.h	/^  kStatTime = 1$/;"	e	enum:ax::StatisticsOption
ax::kUseDefaultParameters	.\image_texture_gl.h	/^kUseDefaultParameters = 0x00000002,$/;"	e	enum:ax::ImageTextureGLOptions
ax::kUseMipmaps	.\image_texture_gl.h	/^kUseMipmaps = 0x00000001,$/;"	e	enum:ax::ImageTextureGLOptions
ax::kUseNormal	.\cg_fwd.h	/^enum { kUseNormal = 1, kUseTexture = 2 };$/;"	e	enum:ax::__anon1
ax::kUseTexture	.\cg_fwd.h	/^enum { kUseNormal = 1, kUseTexture = 2 };$/;"	e	enum:ax::__anon1
ax::kUseVBO	.\cg_fwd.h	/^  kUseVBO = 2,$/;"	e	enum:ax::__anon2
ax::min_max_mipmap_src	.\gl_utils.cc	/^const char *min_max_mipmap_src = $/;"	m	namespace:ax	file:
ax::quad_src	.\gl_utils.cc	/^const char *quad_src = $/;"	m	namespace:ax	file:
ax::vis_rect_tex_fp	.\gl_utils.cc	/^static const char *vis_rect_tex_fp = $/;"	m	namespace:ax	file:
ax::vis_tex_fp	.\gl_utils.cc	/^static const char *vis_tex_fp =$/;"	m	namespace:ax	file:
ax::vis_tex_vp	.\gl_utils.cc	/^static const char *vis_tex_vp =$/;"	m	namespace:ax	file:
b	.\color.h	/^   T r, g, b, a;$/;"	m	class:ax::Color	access:public
bind_const3_names_	.\glslmaterial.h	/^  VarNames bind_const3_names_;$/;"	m	class:ax::GLSLMaterial	access:private
bind_const3_vals_	.\glslmaterial.h	/^  std::vector<ax::Vector3> bind_const3_vals_;$/;"	m	class:ax::GLSLMaterial	access:private
bind_const4_names_	.\glslmaterial.h	/^  VarNames bind_const4_names_;$/;"	m	class:ax::GLSLMaterial	access:private
bind_const4_vals_	.\glslmaterial.h	/^  std::vector<ax::Vector4> bind_const4_vals_;$/;"	m	class:ax::GLSLMaterial	access:private
bind_float_names_	.\glslmaterial.h	/^  VarNames bind_float_names_;$/;"	m	class:ax::GLSLMaterial	access:private
bind_float_vals_	.\glslmaterial.h	/^  std::vector<float> bind_float_vals_;$/;"	m	class:ax::GLSLMaterial	access:private
bind_tex_names_	.\glslmaterial.h	/^  VarNames bind_tex_names_;  $/;"	m	class:ax::GLSLMaterial	access:private
bind_texs_	.\glslmaterial.h	/^  std::vector<Texture2DPtr> bind_texs_;$/;"	m	class:ax::GLSLMaterial	access:private
bound	.\globject.h	/^  const ax::AABB &bound() const { return bound_; }$/;"	f	class:ax::Object	access:public	signature:() const
bound	.\scene.h	/^  const AABB &bound() const { return bound_; }$/;"	f	class:ax::Scene	access:public	signature:() const
bound_	.\globject.h	/^  ax::AABB bound_;$/;"	m	class:ax::Object	access:protected
bound_	.\scene.h	/^  AABB bound_;$/;"	m	class:ax::Scene	access:private
buffer_id	.\render_buffer.h	/^  GLuint buffer_id() const { return buffer_id_; }$/;"	f	class:ax::RenderBuffer	access:public	signature:() const
buffer_id_	.\render_buffer.h	/^  GLuint buffer_id_;$/;"	m	class:ax::RenderBuffer	access:private
camera_	.\camera.h	/^  C *camera_;$/;"	m	class:ax::CameraPan	access:private
camera_	.\camera.h	/^  C *camera_;$/;"	m	class:ax::CameraRot	access:private
capacity_	.\gl_buffer.h	/^  uint32 capacity_;$/;"	m	class:ax::ArrayBufferGL	access:private
color_buffers	.\gl_buffer.h	/^  const std::vector<ax::Texture2DPtr> color_buffers() const { return this->color_buffers_; }$/;"	f	class:ax::FrameBuffer	access:public	signature:() const
color_buffers_	.\gl_buffer.h	/^  std::vector<ax::Texture2DPtr> color_buffers_;$/;"	m	class:ax::FrameBuffer	access:protected
color_format_	.\gl_buffer.h	/^  int color_format_;$/;"	m	class:ax::FrameBuffer	access:private
copy_tex_2d_src	.\gl_utils.cc	/^const char *copy_tex_2d_src = $/;"	m	namespace:ax	file:
copy_tex_rect_src	.\gl_utils.cc	/^const char *copy_tex_rect_src =$/;"	m	namespace:ax	file:
data	.\cube_image.h	/^  const char *data(int i) const { return data_[i]; }$/;"	f	class:ax::CubeImage	access:public	signature:(int i) const
data	.\image.h	/^  const char *data() const { return data_; }$/;"	f	class:ax::Image	access:public	signature:() const
data_	.\cube_image.h	/^  char *data_[6];$/;"	m	class:ax::CubeImage	access:private
data_	.\image.h	/^  char *data_;$/;"	m	class:ax::Image	access:private
depth	.\texture_gl.h	/^  int depth() const { return depth_; }$/;"	f	class:ax::Texture3D	access:public	signature:() const
depth_	.\texture_gl.h	/^  int depth_;  $/;"	m	class:ax::Texture3D	access:private
depth_buffer	.\gl_buffer.h	/^  ax::Texture2DPtr depth_buffer() const { return this->depth_buffer_; }$/;"	f	class:ax::FrameBuffer	access:public	signature:() const
depth_buffer_	.\gl_buffer.h	/^  ax::Texture2DPtr depth_buffer_;$/;"	m	class:ax::FrameBuffer	access:protected
depth_format_	.\gl_buffer.h	/^  int depth_format_;$/;"	m	class:ax::FrameBuffer	access:private
device_	.\gl_buffer.h	/^  ax::FBODevicePtr device_;$/;"	m	class:ax::FrameBuffer	access:protected
device_	.\gl_utils.cc	/^ax::FBODevicePtr ax::TextureUtil::device_;$/;"	m	class:ax::ax::TextureUtil	file:
device_	.\utils.h	/^  static ax::FBODevicePtr device_;$/;"	m	class:ax::TextureUtil	access:private
diffuse	.\glm_avl.h	/^  GLfloat diffuse[4];           \/* diffuse component *\/$/;"	m	struct:_GLMmaterial	access:public
diffuse	.\glmaterial.h	/^  const Colorf &diffuse() const { return diffuse_; }$/;"	f	class:ax::GLMaterial	access:public	signature:() const
diffuse_	.\glmaterial.h	/^  Colorf ambient_, diffuse_, specular_, emission_;$/;"	m	class:ax::GLMaterial	access:private
emission	.\glmaterial.h	/^  const Colorf &emission() const { return emission_; }$/;"	f	class:ax::GLMaterial	access:public	signature:() const
emission_	.\glmaterial.h	/^  Colorf ambient_, diffuse_, specular_, emission_;$/;"	m	class:ax::GLMaterial	access:private
emmissive	.\glm_avl.h	/^  GLfloat emmissive[4];         \/* emmissive component *\/$/;"	m	struct:_GLMmaterial	access:public
facetnorms	.\glm_avl.h	/^  GLfloat* facetnorms;          \/* array of facetnorms *\/$/;"	m	struct:_GLMmodel	access:public
fbo_	.\render_device_fbo.h	/^  FramebufferObject fbo_;$/;"	m	class:ax::RenderDeviceFBO	access:private
fbo_id_	.\framebuffer_object.h	/^  GLuint fbo_id_;$/;"	m	class:ax::FramebufferObject	access:private
findex	.\glm_avl.h	/^  GLuint findex;                \/* index of triangle facet normal *\/$/;"	m	struct:_GLMtriangle	access:public
floats_	.\scene.h	/^  FloatVarMap floats_;$/;"	m	class:ax::NamedVariables	access:private
fly_	.\camera.cc	/^void Motion::fly_(float units) {$/;"	f	class:ax::Motion	signature:(float units)
fly_	.\camera.h	/^  void fly_(float units);$/;"	p	class:ax::Motion	access:protected	signature:(float units)
format	.\cube_image.h	/^  int format() const { return format_; }$/;"	f	class:ax::CubeImage	access:public	signature:() const
format	.\image.h	/^  int format() const { return format_; }$/;"	f	class:ax::Image	access:public	signature:() const
format_	.\cube_image.h	/^  int format_;$/;"	m	class:ax::CubeImage	access:private
format_	.\image.h	/^  int format_;$/;"	m	class:ax::Image	access:private
fovy	.\camera.h	/^  float fovy() const { return fovy_; }$/;"	f	class:ax::PerspectiveCameraGL	access:public	signature:() const
fovy_	.\camera.h	/^  float fovy_, aspect_ratio_, z_near_, z_far_;$/;"	m	class:ax::PerspectiveCameraGL	access:private
fps	.\fps_counter.h	/^  double fps() const { return this->last_fps_; }$/;"	f	class:ax::FpsCounter	access:public	signature:() const
frag_subroutine_	.\glslmaterial.h	/^  std::string frag_subroutine_;$/;"	m	class:ax::GLSLMaterial	access:private
frame_count_	.\fps_counter.h	/^  int frame_count_;$/;"	m	class:ax::FpsCounter	access:private
g	.\color.h	/^   T r, g, b, a;$/;"	m	class:ax::Color	access:public
geometry_	.\scene.h	/^  ax::GroupPtr geometry_;$/;"	m	class:ax::Scene	access:private
get_float	.\scene.h	/^  float get_float(const std::string &name) { return floats_[name]; }$/;"	f	class:ax::NamedVariables	access:public	signature:(const std::string &name)
get_int	.\scene.h	/^  int get_int(const std::string &name) { return ints_[name]; }$/;"	f	class:ax::NamedVariables	access:public	signature:(const std::string &name)
glmAbs	.\glm_avl.cpp	/^glmAbs(GLfloat f)$/;"	f	file:	signature:(GLfloat f)
glmAddGroup	.\glm_avl.cpp	/^glmAddGroup(GLMmodel* model, char* name)$/;"	f	signature:(GLMmodel* model, char* name)
glmCross	.\glm_avl.cpp	/^glmCross(GLfloat* u, GLfloat* v, GLfloat* n)$/;"	f	file:	signature:(GLfloat* u, GLfloat* v, GLfloat* n)
glmDelete	.\glm_avl.cpp	/^glmDelete(GLMmodel* model)$/;"	f	signature:(GLMmodel* model)
glmDelete	.\glm_avl.h	/^glmDelete(GLMmodel* model);$/;"	p	signature:(GLMmodel* model)
glmDimensions	.\glm_avl.cpp	/^glmDimensions(GLMmodel* model, GLfloat* dimensions)$/;"	f	signature:(GLMmodel* model, GLfloat* dimensions)
glmDimensions	.\glm_avl.h	/^glmDimensions(GLMmodel* model, GLfloat* dimensions);$/;"	p	signature:(GLMmodel* model, GLfloat* dimensions)
glmDirName	.\glm_avl.cpp	/^glmDirName(char* path)$/;"	f	file:	signature:(char* path)
glmDot	.\glm_avl.cpp	/^glmDot(GLfloat* u, GLfloat* v)$/;"	f	file:	signature:(GLfloat* u, GLfloat* v)
glmDraw	.\glm_avl.cpp	/^glmDraw(GLMmodel* model, GLuint mode)$/;"	f	signature:(GLMmodel* model, GLuint mode)
glmDraw	.\glm_avl.h	/^glmDraw(GLMmodel* model, GLuint mode);$/;"	p	signature:(GLMmodel* model, GLuint mode)
glmEqual	.\glm_avl.cpp	/^glmEqual(GLfloat* u, GLfloat* v, GLfloat epsilon)$/;"	f	file:	signature:(GLfloat* u, GLfloat* v, GLfloat epsilon)
glmFacetNormals	.\glm_avl.cpp	/^glmFacetNormals(GLMmodel* model)$/;"	f	signature:(GLMmodel* model)
glmFacetNormals	.\glm_avl.h	/^glmFacetNormals(GLMmodel* model);$/;"	p	signature:(GLMmodel* model)
glmFindGroup	.\glm_avl.cpp	/^glmFindGroup(GLMmodel* model, char* name)$/;"	f	signature:(GLMmodel* model, char* name)
glmFindMaterial	.\glm_avl.cpp	/^glmFindMaterial(GLMmodel* model, char* name)$/;"	f	signature:(GLMmodel* model, char* name)
glmFirstPass	.\glm_avl.cpp	/^glmFirstPass(GLMmodel* model, FILE* file) $/;"	f	file:	signature:(GLMmodel* model, FILE* file)
glmFlipModelTextures	.\glm_avl.cpp	/^GLvoid glmFlipModelTextures(GLMmodel* model)$/;"	f	signature:(GLMmodel* model)
glmFlipModelTextures	.\glm_avl.h	/^GLvoid glmFlipModelTextures(GLMmodel* model);$/;"	p	signature:(GLMmodel* model)
glmFlipTexture	.\glm_avl.cpp	/^GLvoid glmFlipTexture(unsigned char* texture, int width, int height)$/;"	f	signature:(unsigned char* texture, int width, int height)
glmFlipTexture	.\glm_avl.h	/^GLvoid glmFlipTexture(unsigned char* texture, int width, int height);$/;"	p	signature:(unsigned char* texture, int width, int height)
glmLinearTexture	.\glm_avl.cpp	/^glmLinearTexture(GLMmodel* model)$/;"	f	signature:(GLMmodel* model)
glmLinearTexture	.\glm_avl.h	/^glmLinearTexture(GLMmodel* model);$/;"	p	signature:(GLMmodel* model)
glmList	.\glm_avl.cpp	/^glmList(GLMmodel* model, GLuint mode)$/;"	f	signature:(GLMmodel* model, GLuint mode)
glmList	.\glm_avl.h	/^glmList(GLMmodel* model, GLuint mode);$/;"	p	signature:(GLMmodel* model, GLuint mode)
glmMax	.\glm_avl.cpp	/^glmMax(GLfloat a, GLfloat b) $/;"	f	file:	signature:(GLfloat a, GLfloat b)
glmNormalize	.\glm_avl.cpp	/^glmNormalize(GLfloat* v)$/;"	f	file:	signature:(GLfloat* v)
glmReadMTL	.\glm_avl.cpp	/^glmReadMTL(GLMmodel* model, char* name)$/;"	f	file:	signature:(GLMmodel* model, char* name)
glmReadOBJ	.\glm_avl.cpp	/^glmReadOBJ( const char* filename)$/;"	f	signature:( const char* filename)
glmReadOBJ	.\glm_avl.h	/^glmReadOBJ( const char* filename);$/;"	p	signature:( const char* filename)
glmReadPPM	.\glm_avl.cpp	/^glmReadPPM(char* filename, int* width, int* height)$/;"	f	signature:(char* filename, int* width, int* height)
glmReadPPM	.\glm_avl.h	/^glmReadPPM(char* filename, int* width, int* height);$/;"	p	signature:(char* filename, int* width, int* height)
glmReverseWinding	.\glm_avl.cpp	/^glmReverseWinding(GLMmodel* model)$/;"	f	signature:(GLMmodel* model)
glmReverseWinding	.\glm_avl.h	/^glmReverseWinding(GLMmodel* model);$/;"	p	signature:(GLMmodel* model)
glmScale	.\glm_avl.cpp	/^glmScale(GLMmodel* model, GLfloat scale)$/;"	f	signature:(GLMmodel* model, GLfloat scale)
glmScale	.\glm_avl.h	/^glmScale(GLMmodel* model, GLfloat scale);$/;"	p	signature:(GLMmodel* model, GLfloat scale)
glmSecondPass	.\glm_avl.cpp	/^glmSecondPass(GLMmodel* model, FILE* file) $/;"	f	file:	signature:(GLMmodel* model, FILE* file)
glmSpheremapTexture	.\glm_avl.cpp	/^glmSpheremapTexture(GLMmodel* model)$/;"	f	signature:(GLMmodel* model)
glmSpheremapTexture	.\glm_avl.h	/^glmSpheremapTexture(GLMmodel* model);$/;"	p	signature:(GLMmodel* model)
glmUnitize	.\glm_avl.cpp	/^glmUnitize(GLMmodel* model)$/;"	f	signature:(GLMmodel* model)
glmUnitize	.\glm_avl.h	/^glmUnitize(GLMmodel* model);$/;"	p	signature:(GLMmodel* model)
glmVertexNormals	.\glm_avl.cpp	/^glmVertexNormals(GLMmodel* model, GLfloat angle)$/;"	f	signature:(GLMmodel* model, GLfloat angle)
glmVertexNormals	.\glm_avl.h	/^glmVertexNormals(GLMmodel* model, GLfloat angle);$/;"	p	signature:(GLMmodel* model, GLfloat angle)
glmWeld	.\glm_avl.cpp	/^glmWeld(GLMmodel* model, GLfloat epsilon)$/;"	f	signature:(GLMmodel* model, GLfloat epsilon)
glmWeld	.\glm_avl.h	/^glmWeld(GLMmodel* model, GLfloat epsilon);$/;"	p	signature:(GLMmodel* model, GLfloat epsilon)
glmWeldVectors	.\glm_avl.cpp	/^glmWeldVectors(GLfloat* vectors, GLuint* numvectors, GLfloat epsilon)$/;"	f	signature:(GLfloat* vectors, GLuint* numvectors, GLfloat epsilon)
glmWriteMTL	.\glm_avl.cpp	/^glmWriteMTL(GLMmodel* model, char* modelpath, char* mtllibname)$/;"	f	file:	signature:(GLMmodel* model, char* modelpath, char* mtllibname)
glmWriteOBJ	.\glm_avl.cpp	/^glmWriteOBJ(GLMmodel* model, char* filename, GLuint mode)$/;"	f	signature:(GLMmodel* model, char* filename, GLuint mode)
glmWriteOBJ	.\glm_avl.h	/^glmWriteOBJ(GLMmodel* model, char* filename, GLuint mode);$/;"	p	signature:(GLMmodel* model, char* filename, GLuint mode)
gpu_ptr	.\gl_buffer.h	/^  GLuint64EXT gpu_ptr() const { return this->gpu_ptr_; }$/;"	f	class:ax::ArrayBufferGL	access:public	signature:() const
gpu_ptr_	.\gl_buffer.h	/^  GLuint64EXT gpu_ptr_;$/;"	m	class:ax::ArrayBufferGL	access:private
groups	.\glm_avl.h	/^  GLMgroup*    groups;          \/* linked list of groups *\/$/;"	m	struct:_GLMmodel	access:public
h_	.\camera.h	/^  int w_, h_;$/;"	m	class:ax::TrackableI	access:protected
has_stencil_buffer_	.\gl_buffer.h	/^  bool has_stencil_buffer_;$/;"	m	class:ax::FrameBuffer	access:private
has_zbuffer_	.\gl_buffer.h	/^  bool has_zbuffer_;$/;"	m	class:ax::FrameBuffer	access:private
height	.\cube_image.h	/^  int height() const { return height_; }$/;"	f	class:ax::CubeImage	access:public	signature:() const
height	.\gl_buffer.h	/^  int height() const {$/;"	f	class:ax::FrameBuffer	access:public	signature:() const
height	.\glm_avl.h	/^  int height,$/;"	m	struct:_GLMmaterial	access:public
height	.\image.h	/^  int height() const { return height_; }$/;"	f	class:ax::Image	access:public	signature:() const
height	.\image_texture_gl.h	/^  int height() const { return height_; }$/;"	f	class:ax::ImageTextureGL	access:public	signature:() const
height	.\render_buffer.h	/^  int height() const { return height_; }$/;"	f	class:ax::RenderBuffer	access:public	signature:() const
height	.\texture_gl.h	/^  int height() const { return height_; }$/;"	f	class:ax::TextureGL	access:public	signature:() const
height	.\utils.h	/^  int height() const { return this->height_; }  $/;"	f	class:ax::RenderAppI	access:public	signature:() const
height_	.\cube_image.h	/^  int width_,height_;$/;"	m	class:ax::CubeImage	access:private
height_	.\image.h	/^  int width_,height_;$/;"	m	class:ax::Image	access:private
height_	.\image_texture_gl.h	/^  int width_, height_;$/;"	m	class:ax::ImageTextureGL	access:private
height_	.\render_buffer.h	/^  int width_, height_;$/;"	m	class:ax::RenderBuffer	access:private
height_	.\texture_gl.h	/^  int height_;$/;"	m	class:ax::TextureGL	access:private
height_	.\utils.h	/^  int width_, height_;$/;"	m	class:ax::RenderAppI	access:private
i_tcoords_	.\model_gl.h	/^    int i_tcoords_[8];$/;"	m	union:ax::Quad2DGL::__anon3	access:public
id	.\gl_buffer.h	/^  GLuint id() const { return this->id_; }$/;"	f	class:ax::ArrayBufferGL	access:public	signature:() const
id	.\gl_object.h	/^  GLuint id() const { return id_; }$/;"	f	class:ax::GLObject	access:public	signature:() const
id_	.\gl_buffer.h	/^  GLuint id_;$/;"	m	class:ax::ArrayBufferGL	access:private
id_	.\gl_object.h	/^  GLuint id_;$/;"	m	class:ax::GLObject	access:protected
idx_buffer_	.\glmesh.h	/^  ax::ArrayBufferGL idx_buffer_;$/;"	m	class:ax::GLMesh	access:private
idx_vbo_	.\model_gl.h	/^  uint32 idx_vbo_;$/;"	m	class:ax::Quad2DGL	access:private
iformat	.\texture_gl.h	/^  int iformat() const { return iformat_; }$/;"	f	class:ax::TextureGL	access:public	signature:() const
iformat_	.\texture_gl.h	/^  int iformat_;$/;"	m	class:ax::TextureGL	access:private
image	.\glm_avl.h	/^  unsigned char* image;$/;"	m	struct:_GLMmaterial	access:public
inc_fovy	.\camera.h	/^  void inc_fovy(float val) { fovy_ += val; }$/;"	f	class:ax::PerspectiveCameraGL	access:public	signature:(float val)
inc_rotation_speed	.\camera.h	/^  void inc_rotation_speed(float f) { rotation_speed_ += f; }$/;"	f	class:ax::Motion	access:public	signature:(float f)
inc_velocity	.\camera.h	/^  void inc_velocity(float x, float y, float z) {$/;"	f	class:ax::Motion	access:public	signature:(float x, float y, float z)
inc_z_far	.\camera.h	/^  void inc_z_far(float val) { z_far_ += val; }$/;"	f	class:ax::PerspectiveCameraGL	access:public	signature:(float val)
inc_z_near	.\camera.h	/^  void inc_z_near(float val) { z_near_ += val; }$/;"	f	class:ax::PerspectiveCameraGL	access:public	signature:(float val)
included_buffers_	.\gl_buffer.h	/^  int included_buffers_;$/;"	m	class:ax::FrameBuffer	access:private
index	.\glm_avl.cpp	/^    GLuint         index;$/;"	m	struct:_GLMnode	file:	access:public
indices	.\model_gl.h	/^  static const float indices[6];$/;"	m	class:ax::Quad3DGL	access:private
indices_	.\model_gl.cc	/^const uint32 Quad2DGL::indices_[6] = { 0, 1, 2, 0, 2, 3 };$/;"	m	class:ax::Quad2DGL	file:
indices_	.\model_gl.h	/^  static const uint32 indices_[6];$/;"	m	class:ax::Quad2DGL	access:private
ints_	.\scene.h	/^  IntVarMap ints_;$/;"	m	class:ax::NamedVariables	access:private
is_captured_	.\camera.h	/^  bool is_captured_;$/;"	m	class:ax::TrackableI	access:protected
is_linked_	.\program_glsl.h	/^  bool is_linked_;$/;"	m	class:ax::ProgramGLSL	access:private
is_valid	.\image_texture_gl.h	/^  bool is_valid() const { return 0 != tex_id_; }$/;"	f	class:ax::ImageTextureGL	access:public	signature:() const
is_valid	.\render_buffer.h	/^  bool is_valid() const { return 0 != buffer_id_; }$/;"	f	class:ax::RenderBuffer	access:public	signature:() const
is_valid	.\texture_gl.h	/^  bool is_valid() const { return 0 != this->id(); }$/;"	f	class:ax::TextureGL	access:public	signature:() const
kBlack	.\color.h	/^   static const Color kBlack;$/;"	m	class:ax::Color	access:public
kBlack	.\color.h	/^const Color<T> Color<T>::kBlack = Color<T>(0, 0, 0, 1);$/;"	m	class:ax::Color
kBufferName	.\gl_buffer.cc	/^const std::string FrameBuffer::ParamNames::kBufferName = ax::FBParams::kBufferName;$/;"	m	class:ax::FrameBuffer::ParamNames	file:
kBufferName	.\gl_buffer.cc	/^const std::string ax::FBParams::kBufferName = "frame buffer name";$/;"	m	class:ax::ax::FBParams	file:
kBufferName	.\gl_buffer.h	/^  static const std::string kBufferName;$/;"	m	struct:ax::FBParams	access:public
kColorBufferCount	.\gl_buffer.cc	/^const std::string FrameBuffer::ParamNames::kColorBufferCount = ax::FBParams::kColorBufferCount;$/;"	m	class:ax::FrameBuffer::ParamNames	file:
kColorBufferCount	.\gl_buffer.cc	/^const std::string ax::FBParams::kColorBufferCount = "frame buffer color buffer count";$/;"	m	class:ax::ax::FBParams	file:
kColorBufferCount	.\gl_buffer.h	/^  static const std::string kColorBufferCount;$/;"	m	struct:ax::FBParams	access:public
kColorFormat	.\gl_buffer.cc	/^const std::string FrameBuffer::ParamNames::kColorFormat = ax::FBParams::kColorFormat;$/;"	m	class:ax::FrameBuffer::ParamNames	file:
kColorFormat	.\gl_buffer.cc	/^const std::string ax::FBParams::kColorFormat = "frame buffer color format";$/;"	m	class:ax::ax::FBParams	file:
kColorFormat	.\gl_buffer.h	/^  static const std::string kColorFormat;$/;"	m	struct:ax::FBParams	access:public
kComputeBound	.\cg_fwd.h	/^  kComputeBound = 1, $/;"	e	enum:ax::__anon2
kCopyTexture2D	.\utils.h	/^  kCopyTexture2D,  $/;"	e	enum:ax::__anon4
kCopyTextureRect	.\utils.h	/^  kCopyTextureRect,$/;"	e	enum:ax::__anon4
kDepthFormat	.\gl_buffer.cc	/^const std::string FrameBuffer::ParamNames::kDepthFormat = ax::FBParams::kDepthFormat;$/;"	m	class:ax::FrameBuffer::ParamNames	file:
kDepthFormat	.\gl_buffer.cc	/^const std::string ax::FBParams::kDepthFormat = "frame buffer depth format";$/;"	m	class:ax::ax::FBParams	file:
kDepthFormat	.\gl_buffer.h	/^  static const std::string kDepthFormat;$/;"	m	struct:ax::FBParams	access:public
kDepthTexture	.\image_texture_gl.h	/^kDepthTexture = 0x00000004$/;"	e	enum:ax::ImageTextureGLOptions
kGenNormal	.\cg_fwd.h	/^  kGenNormal = 4,$/;"	e	enum:ax::__anon2
kGenTexcoord	.\cg_fwd.h	/^  kGenTexcoord = 8,$/;"	e	enum:ax::__anon2
kHasDepthBuffer	.\gl_buffer.cc	/^const std::string FrameBuffer::ParamNames::kHasDepthBuffer = ax::FBParams::kHasDepthBuffer;$/;"	m	class:ax::FrameBuffer::ParamNames	file:
kHasDepthBuffer	.\gl_buffer.cc	/^const std::string ax::FBParams::kHasDepthBuffer = "frame buffer has depth buffer";$/;"	m	class:ax::ax::FBParams	file:
kHasDepthBuffer	.\gl_buffer.h	/^  static const std::string kHasDepthBuffer;$/;"	m	struct:ax::FBParams	access:public
kHasStencilBuffer	.\gl_buffer.cc	/^const std::string FrameBuffer::ParamNames::kHasStencilBuffer = ax::FBParams::kHasStencilBuffer;$/;"	m	class:ax::FrameBuffer::ParamNames	file:
kHasStencilBuffer	.\gl_buffer.cc	/^const std::string ax::FBParams::kHasStencilBuffer = "frame buffer has stencil buffer";$/;"	m	class:ax::ax::FBParams	file:
kHasStencilBuffer	.\gl_buffer.h	/^  static const std::string kHasStencilBuffer;$/;"	m	struct:ax::FBParams	access:public
kIgnoreGroup	.\cg_fwd.h	/^  kIgnoreGroup = 16,$/;"	e	enum:ax::__anon2
kLightPositionParam	.\utils.h	/^const std::string kLightPositionParam = "light position";$/;"	m	namespace:ax
kMVPMatrixParam	.\utils.h	/^const std::string kMVPMatrixParam = "mvp matrix";$/;"	m	namespace:ax
kMaxUnit	.\texture_gl.h	/^  static const int kMaxUnit = 16;$/;"	m	class:ax::UnitIdManager	access:private
kNeedAdjacency	.\cg_fwd.h	/^  kNeedAdjacency = 32$/;"	e	enum:ax::__anon2
kNone	.\cg_fwd.h	/^  kNone = 0,$/;"	e	enum:ax::__anon2
kNone	.\image_texture_gl.h	/^kNone = 0,$/;"	e	enum:ax::ImageTextureGLOptions
kNullMatl	.\material.cc	/^const MaterialPtr Material::kNullMatl = $/;"	m	class:ax::Material	file:
kNullMatl	.\material.h	/^  static const MaterialPtr kNullMatl;$/;"	m	class:ax::Material	access:public
kOverFrames	.\fps_counter.h	/^  enum AverageType { kOverFrames, kOverTime };$/;"	e	enum:ax::FpsCounter::AverageType
kOverTime	.\fps_counter.h	/^  enum AverageType { kOverFrames, kOverTime };$/;"	e	enum:ax::FpsCounter::AverageType
kSceneOptionParam	.\utils.h	/^const std::string kSceneOptionParam = "scene option";$/;"	m	namespace:ax
kStatNone	.\utils.h	/^  kStatNone = 0,$/;"	e	enum:ax::StatisticsOption
kStatTime	.\utils.h	/^  kStatTime = 1$/;"	e	enum:ax::StatisticsOption
kTextureTarget	.\gl_buffer.cc	/^const std::string FrameBuffer::ParamNames::kTextureTarget = ax::FBParams::kTextureTarget;$/;"	m	class:ax::FrameBuffer::ParamNames	file:
kTextureTarget	.\gl_buffer.cc	/^const std::string ax::FBParams::kTextureTarget = "frame buffer texture target";$/;"	m	class:ax::ax::FBParams	file:
kTextureTarget	.\gl_buffer.h	/^  static const std::string kTextureTarget;$/;"	m	struct:ax::FBParams	access:public
kUseDefaultParameters	.\image_texture_gl.h	/^kUseDefaultParameters = 0x00000002,$/;"	e	enum:ax::ImageTextureGLOptions
kUseMipmaps	.\image_texture_gl.h	/^kUseMipmaps = 0x00000001,$/;"	e	enum:ax::ImageTextureGLOptions
kUseNormal	.\cg_fwd.h	/^enum { kUseNormal = 1, kUseTexture = 2 };$/;"	e	enum:ax::__anon1
kUseTexture	.\cg_fwd.h	/^enum { kUseNormal = 1, kUseTexture = 2 };$/;"	e	enum:ax::__anon1
kUseVBO	.\cg_fwd.h	/^  kUseVBO = 2,$/;"	e	enum:ax::__anon2
kWhite	.\color.h	/^   static const Color kWhite;$/;"	m	class:ax::Color	access:public
kWhite	.\color.h	/^const Color<T> Color<T>::kWhite = Color<T>(1, 1, 1, 1);$/;"	m	class:ax::Color
last_fps_	.\fps_counter.h	/^  double last_fps_;$/;"	m	class:ax::FpsCounter	access:private
last_time_	.\fps_counter.h	/^  double last_time_;$/;"	m	class:ax::FpsCounter	access:private
look	.\camera.h	/^  const glm::vec3 &look() const { return look_; }$/;"	f	class:ax::Motion	access:public	signature:() const
look_	.\camera.h	/^  glm::vec3 right_, up_, look_;$/;"	m	class:ax::Motion	access:private
mapped_	.\gl_buffer.h	/^  bool mapped_;$/;"	m	class:ax::CudaArrayBufferGL	access:private
material	.\glm_avl.h	/^  GLuint            material;       \/* index to material for group *\/$/;"	m	struct:_GLMgroup	access:public
material	.\globject.h	/^  const ax::MaterialPtr &material() const {$/;"	f	class:ax::Object	access:public	signature:() const
material	.\scene.h	/^  MaterialPtr material(const std::string &name) { $/;"	f	class:ax::Scene	access:public	signature:(const std::string &name)
materials	.\glm_avl.h	/^  GLMmaterial* materials;       \/* array of materials *\/$/;"	m	struct:_GLMmodel	access:public
matl_	.\globject.h	/^  MaterialPtr matl_;$/;"	m	class:ax::Object	access:protected
max_depth_derivative_prog_	.\utils.h	/^  ax::ProgramGLSLPtr max_depth_derivative_prog_;$/;"	m	class:ax::TextureUtil	access:private
max_dist	.\camera.h	/^  float max_dist() const { return max_dist_; }$/;"	f	class:ax::OrbitMotion	access:public	signature:() const
max_dist_	.\camera.h	/^  float min_dist_, max_dist_;$/;"	m	class:ax::OrbitMotion	access:private
mesh_	.\glmesh.h	/^  ax::TriMeshPtr mesh_;$/;"	m	class:ax::GLMesh	access:private
min_dist	.\camera.h	/^  float min_dist() const { return min_dist_; }$/;"	f	class:ax::OrbitMotion	access:public	signature:() const
min_dist_	.\camera.h	/^  float min_dist_, max_dist_;$/;"	m	class:ax::OrbitMotion	access:private
min_max_mipmap_src	.\gl_utils.cc	/^const char *min_max_mipmap_src = $/;"	m	namespace:ax	file:
min_max_normal_prog_	.\utils.h	/^  ax::ProgramGLSLPtr min_max_normal_prog_;  $/;"	m	class:ax::TextureUtil	access:private
mtllibname	.\glm_avl.h	/^  char*    mtllibname;          \/* name of the material library *\/$/;"	m	struct:_GLMmodel	access:public
mvp	.\model_gl.h	/^  const Matrix4x4 &mvp() const { return mvp_; }$/;"	f	class:ax::ScreenQuad	access:public	signature:() const
mvp_	.\model_gl.h	/^  Matrix4x4 mvp_;$/;"	m	class:ax::ScreenQuad	access:private
mvp_ptr	.\model_gl.h	/^  const float *mvp_ptr() const { return &mvp_[0][0]; }$/;"	f	class:ax::ScreenQuad	access:public	signature:() const
n_color_buffers_	.\gl_buffer.h	/^  int n_color_buffers_;$/;"	m	class:ax::FrameBuffer	access:private
n_tris_	.\glmesh.h	/^  int n_tris_;$/;"	m	class:ax::GLGroup	access:private
name	.\gl_object.h	/^  const std::string &name() const { return name_; }$/;"	f	class:ax::GLObject	access:public	signature:() const
name	.\glm_avl.h	/^  char*             name;           \/* name of this group *\/$/;"	m	struct:_GLMgroup	access:public
name	.\glm_avl.h	/^  char* name;                   \/* name of material *\/$/;"	m	struct:_GLMmaterial	access:public
name	.\material.h	/^  const std::string &name() const { return name_; }$/;"	f	class:ax::Material	access:public	signature:() const
name	.\utils.h	/^  const std::string &name() const { return name_; }$/;"	f	class:ax::RenderAppI	access:public	signature:() const
name_	.\gl_buffer.h	/^  std::string name_;$/;"	m	class:ax::FrameBuffer	access:private
name_	.\gl_object.h	/^  const std::string name_;$/;"	m	class:ax::GLObject	access:protected
name_	.\material.h	/^  std::string name_;$/;"	m	class:ax::Material	access:private
name_	.\utils.h	/^  const std::string name_;$/;"	m	class:ax::ScopeStatistics	access:public
name_	.\utils.h	/^  std::string name_;$/;"	m	class:ax::RenderAppI	access:private
named_matls_	.\scene.h	/^  MaterialMap named_matls_;$/;"	m	class:ax::Scene	access:private
named_object	.\scene.h	/^  ObjectPtr named_object(const std::string &name) { $/;"	f	class:ax::Scene	access:public	signature:(const std::string &name)
named_objs_	.\scene.h	/^  ObjectMap named_objs_;$/;"	m	class:ax::Scene	access:private
named_texs_	.\scene.h	/^  TextureMap named_texs_;$/;"	m	class:ax::Scene	access:private
next	.\glm_avl.cpp	/^    struct _GLMnode* next;$/;"	m	struct:_GLMnode	typeref:struct:_GLMnode::_GLMnode	file:	access:public
next	.\glm_avl.h	/^  struct _GLMgroup* next;           \/* pointer to next group in model *\/$/;"	m	struct:_GLMgroup	typeref:struct:_GLMgroup::_GLMgroup	access:public
nextId	.\texture_gl.h	/^  int nextId() {$/;"	f	class:ax::UnitIdManager	access:public	signature:()
next_id_	.\texture_gl.cc	/^int UnitIdManager::next_id_ = 0;$/;"	m	class:ax::UnitIdManager	file:
next_id_	.\texture_gl.h	/^  static int next_id_;$/;"	m	class:ax::UnitIdManager	access:private
nindices	.\glm_avl.h	/^  GLuint nindices[3];           \/* array of triangle normal indices *\/$/;"	m	struct:_GLMtriangle	access:public
normal_slot_	.\glmesh.h	/^  int normal_slot_;$/;"	m	class:ax::GLMesh	access:private
normals	.\glm_avl.h	/^  GLfloat* normals;             \/* array of normals *\/$/;"	m	struct:_GLMmodel	access:public
numfacetnorms	.\glm_avl.h	/^  GLuint   numfacetnorms;       \/* number of facetnorms in model *\/$/;"	m	struct:_GLMmodel	access:public
numgroups	.\glm_avl.h	/^  GLuint       numgroups;       \/* number of groups in model *\/$/;"	m	struct:_GLMmodel	access:public
nummaterials	.\glm_avl.h	/^  GLuint       nummaterials;    \/* number of materials in model *\/$/;"	m	struct:_GLMmodel	access:public
numnormals	.\glm_avl.h	/^  GLuint   numnormals;          \/* number of normals in model *\/$/;"	m	struct:_GLMmodel	access:public
numtexcoords	.\glm_avl.h	/^  GLuint   numtexcoords;        \/* number of texcoords in model *\/$/;"	m	struct:_GLMmodel	access:public
numtriangles	.\glm_avl.h	/^  GLuint            numtriangles;   \/* number of triangles in this group *\/$/;"	m	struct:_GLMgroup	access:public
numtriangles	.\glm_avl.h	/^  GLuint       numtriangles;    \/* number of triangles in model *\/$/;"	m	struct:_GLMmodel	access:public
numvertices	.\glm_avl.h	/^  GLuint   numvertices;         \/* number of vertices in model *\/$/;"	m	struct:_GLMmodel	access:public
object	.\group.h	/^  ObjectPtr object(int i) const { return this->objs_[i]; }$/;"	f	class:ax::Group	access:public	signature:(int i) const
object	.\scene.h	/^ ObjectPtr object(int i) const { return this->geometry_->object(i); }$/;"	f	class:ax::Scene	access:public	signature:(int i) const
objs_	.\glmesh.h	/^  ObjectList objs_;$/;"	m	class:ax::GLMesh	access:private
objs_	.\group.h	/^  ObjectList objs_;$/;"	m	class:ax::Group	access:private
offsets_	.\gl_buffer.h	/^  std::vector<int> offsets_;$/;"	m	class:ax::MultiResolutionBuffer	access:private
old_x_	.\camera.h	/^  int old_x_, old_y_;$/;"	m	class:ax::TrackableI	access:protected
old_y_	.\camera.h	/^  int old_x_, old_y_;$/;"	m	class:ax::TrackableI	access:protected
opts_	.\cg_fwd.h	/^  int opts_;$/;"	m	class:ax::Options	access:private
opts_	.\scene.h	/^  ax::Options opts_;$/;"	m	class:ax::Scene	access:private
opts_	.\utils.h	/^  ax::Options opts_;$/;"	m	class:ax::ScopeStatistics	access:public
parent_group_	.\globject.h	/^  ObjectPtr parent_group_;$/;"	m	class:ax::Object	access:protected
pathname	.\glm_avl.h	/^  char*    pathname;            \/* path to this model *\/$/;"	m	struct:_GLMmodel	access:public
pitch_	.\camera.cc	/^void Motion::pitch_(float angle) {$/;"	f	class:ax::Motion	signature:(float angle)
pitch_	.\camera.h	/^  void pitch_(float angle);$/;"	p	class:ax::Motion	access:protected	signature:(float angle)
position	.\camera.h	/^  const glm::vec3 &position() const { return position_; }$/;"	f	class:ax::Motion	access:public	signature:() const
position	.\glm_avl.h	/^  GLfloat position[3];          \/* position of the model *\/$/;"	m	struct:_GLMmodel	access:public
position_	.\camera.h	/^  glm::vec3 position_, target_;$/;"	m	class:ax::Motion	access:private
ptr	.\color.h	/^   T *ptr() { return &r; }$/;"	f	class:ax::Color	access:public	signature:()
ptr	.\color.h	/^   const T *ptr() const { return &r; }$/;"	f	class:ax::Color	access:public	signature:() const
ptr	.\parser.h	/^  const char *ptr() const { return token_; }$/;"	f	class:ax::LineToken	access:public	signature:() const
quadVArray	.\model_gl.cc	/^const GLfloat MyScreenQuad::quadVArray[] = {$/;"	m	class:ax::MyScreenQuad	file:
quad_	.\gl_utils.cc	/^ax::ScreenQuadPtr ax::TextureUtil::quad_;$/;"	m	class:ax::ax::TextureUtil	file:
quad_	.\utils.h	/^  static ax::ScreenQuadPtr quad_;  $/;"	m	class:ax::TextureUtil	access:private
quad_src	.\gl_utils.cc	/^const char *quad_src = $/;"	m	namespace:ax	file:
r	.\color.h	/^   T r, g, b, a;$/;"	m	class:ax::Color	access:public
registered_	.\gl_buffer.h	/^  bool registered_;$/;"	m	class:ax::CudaArrayBufferGL	access:private
right	.\camera.h	/^  const glm::vec3 &right() const { return right_; }  $/;"	f	class:ax::Motion	access:protected	signature:() const
right_	.\camera.h	/^  glm::vec3 right_, up_, look_;$/;"	m	class:ax::Motion	access:private
roll_	.\camera.cc	/^void Motion::roll_(float angle) {$/;"	f	class:ax::Motion	signature:(float angle)
roll_	.\camera.h	/^  void roll_(float angle);$/;"	p	class:ax::Motion	access:protected	signature:(float angle)
rotation_speed_	.\camera.h	/^  float rotation_speed_;$/;"	m	class:ax::Motion	access:private
s_mrt	.\render_device_fbo.cc	/^GLenum RenderDeviceFBO::s_mrt[8] = {$/;"	m	class:ax::RenderDeviceFBO	file:
s_mrt	.\render_device_fbo.h	/^  static GLenum s_mrt[8];$/;"	m	class:ax::RenderDeviceFBO	access:private
s_unnamed	.\material.cc	/^const char *Material::s_unnamed = "<Unnamed Material>";$/;"	m	class:ax::Material	file:
s_unnamed	.\material.h	/^  static const char *s_unnamed;$/;"	m	class:ax::Material	access:protected
s_viewport	.\render_device_fbo.h	/^  GLint s_viewport[4];$/;"	m	class:ax::RenderDeviceFBO	access:private
saved_fbo_id_	.\framebuffer_object.h	/^  GLint  saved_fbo_id_;$/;"	m	class:ax::FramebufferObject	access:private
scale_	.\camera.h	/^  float scale_;$/;"	m	class:ax::TrackableI	access:protected
screen_quad_	.\gl_buffer.h	/^  ax::ScreenQuadPtr screen_quad_;$/;"	m	class:ax::MultiResolutionBuffer	access:private
set_ambient	.\glmaterial.h	/^  void set_ambient(const Colorf &c) { ambient_ = c; }$/;"	f	class:ax::GLMaterial	access:public	signature:(const Colorf &c)
set_aspect_ratio	.\camera.h	/^  void set_aspect_ratio(float val) { aspect_ratio_ = val; }$/;"	f	class:ax::PerspectiveCameraGL	access:public	signature:(float val)
set_diffuse	.\glmaterial.h	/^  void set_diffuse(const Colorf &c) { diffuse_ = c; }$/;"	f	class:ax::GLMaterial	access:public	signature:(const Colorf &c)
set_emission	.\glmaterial.h	/^  void set_emission(const Colorf &c) { emission_ = c; }$/;"	f	class:ax::GLMaterial	access:public	signature:(const Colorf &c)
set_fovy	.\camera.h	/^  void set_fovy(float val) { fovy_ = val; }$/;"	f	class:ax::PerspectiveCameraGL	access:public	signature:(float val)
set_look	.\camera.h	/^  void set_look(const glm::vec3 &v) { look_ = v; }$/;"	f	class:ax::Motion	access:protected	signature:(const glm::vec3 &v)
set_material	.\globject.h	/^  void set_material(const MaterialPtr &matl) {$/;"	f	class:ax::Object	access:public	signature:(const MaterialPtr &matl)
set_max_dist	.\camera.h	/^  void set_max_dist(float f) { max_dist_ = f; }$/;"	f	class:ax::OrbitMotion	access:public	signature:(float f)
set_min_dist	.\camera.h	/^  void set_min_dist(float f) { min_dist_ = f; }$/;"	f	class:ax::OrbitMotion	access:public	signature:(float f)
set_parent_group	.\globject.h	/^  void set_parent_group(const ObjectPtr &obj) { parent_group_ = obj; }$/;"	f	class:ax::Object	access:public	signature:(const ObjectPtr &obj)
set_position	.\camera.h	/^  void set_position(const glm::vec3 &p) { position_ = p; }$/;"	f	class:ax::Motion	access:protected	signature:(const glm::vec3 &p)
set_right	.\camera.h	/^  void set_right(const glm::vec3 &v) { right_ = v; }$/;"	f	class:ax::Motion	access:protected	signature:(const glm::vec3 &v)
set_rotation_speed	.\camera.h	/^  void set_rotation_speed(float f) { rotation_speed_ = f; }$/;"	f	class:ax::Motion	access:public	signature:(float f)
set_shininess	.\glmaterial.h	/^  void set_shininess(float s) { shininess_ = s; }$/;"	f	class:ax::GLMaterial	access:public	signature:(float s)
set_specular	.\glmaterial.h	/^  void set_specular(const Colorf &c) { specular_ = c; }$/;"	f	class:ax::GLMaterial	access:public	signature:(const Colorf &c)
set_target	.\camera.h	/^  void set_target(const glm::vec3 &p) { target_ = p; }$/;"	f	class:ax::Motion	access:protected	signature:(const glm::vec3 &p)
set_tcoord_slot	.\model_gl.h	/^  void set_tcoord_slot(const int slot) { tcoord_slot_ = slot; }$/;"	f	class:ax::Quad2DGL	access:public	signature:(const int slot)
set_tcoords	.\model_gl.h	/^  void set_tcoords(const float *tcoords) {$/;"	f	class:ax::Quad2DGL	access:public	signature:(const float *tcoords)
set_tcoords	.\model_gl.h	/^  void set_tcoords(const int *tcoords) {$/;"	f	class:ax::Quad2DGL	access:public	signature:(const int *tcoords)
set_transform	.\globject.h	/^  void set_transform(const ax::Matrix4x4 &m) { transform_ = m; }$/;"	f	class:ax::Object	access:public	signature:(const ax::Matrix4x4 &m)
set_up	.\camera.h	/^  void set_up(const glm::vec3 &v) { up_ = v; }$/;"	f	class:ax::Motion	access:protected	signature:(const glm::vec3 &v)
set_velocity	.\camera.h	/^  void set_velocity(const glm::vec3 &v) { velocity_ = v; }$/;"	f	class:ax::Motion	access:public	signature:(const glm::vec3 &v)
set_velocity	.\camera.h	/^  void set_velocity(float x, float y, float z) { $/;"	f	class:ax::Motion	access:public	signature:(float x, float y, float z)
set_vertex_slot	.\model_gl.h	/^  void set_vertex_slot(const int slot) { vertex_slot_ = slot; }$/;"	f	class:ax::Quad2DGL	access:public	signature:(const int slot)
set_z_far	.\camera.h	/^  void set_z_far(float val) { z_far_ = val; }$/;"	f	class:ax::PerspectiveCameraGL	access:public	signature:(float val)
set_z_near	.\camera.h	/^  void set_z_near(float val) {z_near_ = val; }$/;"	f	class:ax::PerspectiveCameraGL	access:public	signature:(float val)
shininess	.\glm_avl.h	/^  GLfloat shininess;            \/* specular exponent *\/$/;"	m	struct:_GLMmaterial	access:public
shininess	.\glmaterial.h	/^  float shininess() const { return shininess_; }$/;"	f	class:ax::GLMaterial	access:public	signature:() const
shininess_	.\glmaterial.h	/^  float shininess_;$/;"	m	class:ax::GLMaterial	access:private
size	.\gl_buffer.h	/^  uint32 size() const { return this->size_; }$/;"	f	class:ax::ArrayBufferGL	access:public	signature:() const
size_	.\gl_buffer.h	/^  uint32 size_;$/;"	m	class:ax::ArrayBufferGL	access:private
specular	.\glm_avl.h	/^  GLfloat specular[4];          \/* specular component *\/$/;"	m	struct:_GLMmaterial	access:public
specular	.\glmaterial.h	/^  const Colorf &specular() const { return specular_; }$/;"	f	class:ax::GLMaterial	access:public	signature:() const
specular_	.\glmaterial.h	/^  Colorf ambient_, diffuse_, specular_, emission_;$/;"	m	class:ax::GLMaterial	access:private
strafe_	.\camera.cc	/^void Motion::strafe_(float units) {$/;"	f	class:ax::Motion	signature:(float units)
strafe_	.\camera.h	/^  void strafe_(float units);$/;"	p	class:ax::Motion	access:protected	signature:(float units)
t_filename	.\glm_avl.h	/^  char *t_filename;$/;"	m	struct:_GLMmaterial	access:public
t_id	.\glm_avl.h	/^  GLuint t_id[1];$/;"	m	struct:_GLMmaterial	access:public
target	.\camera.h	/^  const glm::vec3 &target() const { return target_; }$/;"	f	class:ax::Motion	access:public	signature:() const
target	.\image_texture_gl.h	/^  uint32 target() const { return target_; }$/;"	f	class:ax::ImageTextureGL	access:public	signature:() const
target	.\texture_gl.h	/^  uint32 target() const { return target_; }$/;"	f	class:ax::TextureGL	access:public	signature:() const
target_	.\camera.h	/^  glm::vec3 position_, target_;$/;"	m	class:ax::Motion	access:private
target_	.\gl_buffer.h	/^  uint32 target_;$/;"	m	class:ax::ArrayBufferGL	access:private
target_	.\image_texture_gl.h	/^  uint32 target_;$/;"	m	class:ax::ImageTextureGL	access:private
target_	.\texture_gl.h	/^  uint32 target_;$/;"	m	class:ax::TextureGL	access:private
target_	.\utils.h	/^  GLuint target_;  $/;"	m	class:ax::GPUTimer	access:protected
tcoord_slot_	.\glmesh.h	/^  int tcoord_slot_;$/;"	m	class:ax::GLMesh	access:private
tcoord_slot_	.\model_gl.h	/^  int vertex_slot_, tcoord_slot_;$/;"	m	class:ax::Quad2DGL	access:private
tcoords_	.\model_gl.h	/^    float tcoords_[8];$/;"	m	union:ax::Quad2DGL::__anon3	access:public
tcoords_	.\model_gl.h	/^  float tcoords_[8];$/;"	m	class:ax::Quad3DGL	access:private
tex_id	.\cube_texture_gl.h	/^  GLuint tex_id() const { return tex_id_; }$/;"	f	class:ax::CubeTextureGL	access:public	signature:() const
tex_id	.\image_texture_gl.h	/^  uint32 tex_id() const { return tex_id_; }$/;"	f	class:ax::ImageTextureGL	access:public	signature:() const
tex_id_	.\cube_texture_gl.h	/^  GLuint tex_id_;$/;"	m	class:ax::CubeTextureGL	access:private
tex_id_	.\image_texture_gl.h	/^  uint32 tex_id_;$/;"	m	class:ax::ImageTextureGL	access:private
texcoords	.\glm_avl.h	/^  GLfloat* texcoords;           \/* array of texture coordinates *\/$/;"	m	struct:_GLMmodel	access:public
texture	.\material.h	/^  virtual Texture2DPtr texture() const { $/;"	f	class:ax::Material	access:public	signature:() const
texture	.\scene.h	/^  Texture2DPtr texture(const std::string &name) { $/;"	f	class:ax::Scene	access:public	signature:(const std::string &name)
texture_slot_	.\program_glsl.h	/^  int texture_slot_;$/;"	m	class:ax::ProgramGLSL	access:private
texture_target_	.\gl_buffer.h	/^  int texture_target_;$/;"	m	class:ax::FrameBuffer	access:private
textured	.\glm_avl.h	/^  int textured;$/;"	m	struct:_GLMmaterial	access:public
timer_	.\utils.h	/^  GPUTimerPtr timer_;$/;"	m	class:ax::ScopeStatistics	access:public
tindices	.\glm_avl.h	/^  GLuint tindices[3];           \/* array of triangle texcoord indices*\/$/;"	m	struct:_GLMtriangle	access:public
token_	.\parser.h	/^  char token_[256];$/;"	m	class:ax::LineToken	access:private
transform	.\globject.h	/^  const ax::Matrix4x4 &transform() const { return transform_; }$/;"	f	class:ax::Object	access:public	signature:() const
transform_	.\globject.h	/^  ax::Matrix4x4 transform_;$/;"	m	class:ax::Object	access:protected
transform_applied	.\globject.h	/^  bool transform_applied() const { return transform_applied_; }  $/;"	f	class:ax::Object	access:public	signature:() const
transform_applied_	.\globject.h	/^  bool transform_applied_;    $/;"	m	class:ax::Object	access:protected
tri_mesh	.\glmesh.h	/^  ax::TriMeshPtr tri_mesh() const { return this->mesh_; }$/;"	f	class:ax::GLMesh	access:public	signature:() const
tri_start_	.\glmesh.h	/^  int tri_start_;$/;"	m	class:ax::GLGroup	access:private
triangles	.\glm_avl.h	/^  GLMtriangle* triangles;       \/* array of triangles *\/$/;"	m	struct:_GLMmodel	access:public
triangles	.\glm_avl.h	/^  GLuint*           triangles;      \/* array of triangle indices *\/$/;"	m	struct:_GLMgroup	access:public
type	.\cube_image.h	/^  int type() const { return type_; }$/;"	f	class:ax::CubeImage	access:public	signature:() const
type	.\image.h	/^  int type() const { return type_; }$/;"	f	class:ax::Image	access:public	signature:() const
type_	.\cube_image.h	/^  int type_;$/;"	m	class:ax::CubeImage	access:private
type_	.\image.h	/^  int type_;$/;"	m	class:ax::Image	access:private
unit_id_	.\texture_gl.h	/^  int unit_id_;$/;"	m	class:ax::TextureGL	access:private
unit_mgr_	.\texture_gl.cc	/^UnitIdManager TextureGL::unit_mgr_;$/;"	m	class:ax::TextureGL	file:
unit_mgr_	.\texture_gl.h	/^  static ax::UnitIdManager unit_mgr_;$/;"	m	class:ax::TextureGL	access:private
up	.\camera.h	/^  const glm::vec3 &up() const { return up_; }$/;"	f	class:ax::Motion	access:public	signature:() const
up_	.\camera.h	/^  glm::vec3 right_, up_, look_;$/;"	m	class:ax::Motion	access:private
update_	.\camera.cc	/^void FlyMotion::update_() {$/;"	f	class:ax::FlyMotion	signature:()
update_	.\camera.h	/^  void update_() {$/;"	f	class:ax::Motion	access:private	signature:()
update_	.\camera.h	/^  void update_(void);$/;"	p	class:ax::FlyMotion	access:private	signature:(void)
velocity	.\camera.h	/^  const glm::vec3 &velocity() const { return velocity_; }$/;"	f	class:ax::Motion	access:public	signature:() const
velocity_	.\camera.h	/^  glm::vec3 velocity_;$/;"	m	class:ax::Motion	access:private
vert_buffer_	.\glmesh.h	/^  ax::ArrayBufferGL vert_buffer_;$/;"	m	class:ax::GLMesh	access:private
vert_subroutine_	.\glslmaterial.h	/^  std::string vert_subroutine_;$/;"	m	class:ax::GLSLMaterial	access:private
vert_vbo	.\glmesh.h	/^  uint32 vert_vbo() const { return this->vert_buffer_.id(); }$/;"	f	class:ax::GLMesh	access:public	signature:() const
vert_vbo_	.\model_gl.h	/^  uint32 vert_vbo_;$/;"	m	class:ax::Quad2DGL	access:private
vertex_slot_	.\glmesh.h	/^  int vertex_slot_;$/;"	m	class:ax::GLMesh	access:private
vertex_slot_	.\model_gl.h	/^  int vertex_slot_, tcoord_slot_;$/;"	m	class:ax::Quad2DGL	access:private
vertices	.\glm_avl.h	/^  GLfloat* vertices;            \/* array of vertices  *\/$/;"	m	struct:_GLMmodel	access:public
vertices_	.\model_gl.h	/^  float vertices_[12];$/;"	m	class:ax::Quad3DGL	access:private
vertices_	.\model_gl.h	/^  float vertices_[8];$/;"	m	class:ax::Quad2DGL	access:private
vindices	.\glm_avl.h	/^  GLuint vindices[3];           \/* array of triangle vertex indices *\/$/;"	m	struct:_GLMtriangle	access:public
vis_rect_tex_fp	.\gl_utils.cc	/^static const char *vis_rect_tex_fp = $/;"	m	namespace:ax	file:
vis_tex_fp	.\gl_utils.cc	/^static const char *vis_tex_fp =$/;"	m	namespace:ax	file:
vis_tex_vp	.\gl_utils.cc	/^static const char *vis_tex_vp =$/;"	m	namespace:ax	file:
w_	.\camera.h	/^  int w_, h_;$/;"	m	class:ax::TrackableI	access:protected
walk_	.\camera.cc	/^void Motion::walk_(float units) {$/;"	f	class:ax::Motion	signature:(float units)
walk_	.\camera.h	/^  void walk_(float units);$/;"	p	class:ax::Motion	access:protected	signature:(float units)
width	.\cube_image.h	/^  int width() const { return width_; }$/;"	f	class:ax::CubeImage	access:public	signature:() const
width	.\gl_buffer.h	/^  int width() const {$/;"	f	class:ax::FrameBuffer	access:public	signature:() const
width	.\glm_avl.h	/^      width;$/;"	m	struct:_GLMmaterial	access:public
width	.\image.h	/^  int width() const { return width_; }$/;"	f	class:ax::Image	access:public	signature:() const
width	.\image_texture_gl.h	/^  int width() const { return width_; }$/;"	f	class:ax::ImageTextureGL	access:public	signature:() const
width	.\render_buffer.h	/^  int width() const { return width_; }$/;"	f	class:ax::RenderBuffer	access:public	signature:() const
width	.\texture_gl.h	/^  int width() const { return width_; }$/;"	f	class:ax::TextureGL	access:public	signature:() const
width	.\utils.h	/^  int width() const { return this->width_; }$/;"	f	class:ax::RenderAppI	access:public	signature:() const
width_	.\cube_image.h	/^  int width_,height_;$/;"	m	class:ax::CubeImage	access:private
width_	.\image.h	/^  int width_,height_;$/;"	m	class:ax::Image	access:private
width_	.\image_texture_gl.h	/^  int width_, height_;$/;"	m	class:ax::ImageTextureGL	access:private
width_	.\render_buffer.h	/^  int width_, height_;$/;"	m	class:ax::RenderBuffer	access:private
width_	.\texture_gl.h	/^  int width_;$/;"	m	class:ax::TextureGL	access:private
width_	.\utils.h	/^  int width_, height_;$/;"	m	class:ax::RenderAppI	access:private
widths_	.\gl_buffer.h	/^  std::vector<int> widths_;$/;"	m	class:ax::MultiResolutionBuffer	access:private
yaw_	.\camera.cc	/^void Motion::yaw_(float angle) {$/;"	f	class:ax::Motion	signature:(float angle)
yaw_	.\camera.h	/^  void yaw_(float angle);$/;"	p	class:ax::Motion	access:protected	signature:(float angle)
z_far	.\camera.h	/^  float z_far() const { return z_far_; }$/;"	f	class:ax::PerspectiveCameraGL	access:public	signature:() const
z_far_	.\camera.h	/^  float fovy_, aspect_ratio_, z_near_, z_far_;$/;"	m	class:ax::PerspectiveCameraGL	access:private
z_near	.\camera.h	/^  float z_near() const { return z_near_; }$/;"	f	class:ax::PerspectiveCameraGL	access:public	signature:() const
z_near_	.\camera.h	/^  float fovy_, aspect_ratio_, z_near_, z_far_;$/;"	m	class:ax::PerspectiveCameraGL	access:private
~ArrayBufferGL	.\gl_buffer.h	/^  virtual ~ArrayBufferGL() { this->Release(); }$/;"	f	class:ax::ArrayBufferGL	access:public	signature:()
~CubeImage	.\cube_image.h	/^  ~CubeImage() {$/;"	f	class:ax::CubeImage	access:public	signature:()
~CubeTextureGL	.\cube_texture_gl.h	/^  ~CubeTextureGL(void);$/;"	p	class:ax::CubeTextureGL	access:public	signature:(void)
~CudaArrayBufferGL	.\gl_buffer.h	/^  ~CudaArrayBufferGL() { this->Unregister(); }$/;"	f	class:ax::CudaArrayBufferGL	access:public	signature:()
~FramebufferObject	.\framebuffer_object.cc	/^FramebufferObject::~FramebufferObject() {$/;"	f	class:ax::FramebufferObject	signature:()
~FramebufferObject	.\framebuffer_object.h	/^  ~FramebufferObject();$/;"	p	class:ax::FramebufferObject	access:public	signature:()
~GLMesh	.\glmesh.cc	/^GLMesh::~GLMesh() { }$/;"	f	class:ax::GLMesh	signature:()
~GLMesh	.\glmesh.h	/^  ~GLMesh();$/;"	p	class:ax::GLMesh	access:public	signature:()
~GLObject	.\gl_object.h	/^  virtual ~GLObject() { id_ = 0; }$/;"	f	class:ax::GLObject	access:public	signature:()
~GPUTimer	.\utils.h	/^  ~GPUTimer() { glDeleteQueries(1, &this->id_); }$/;"	f	class:ax::GPUTimer	access:public	signature:()
~Group	.\group.h	/^  ~Group() { }$/;"	f	class:ax::Group	access:public	signature:()
~Image	.\image.h	/^  ~Image() { this->Release(); }$/;"	f	class:ax::Image	access:public	signature:()
~ImageTextureGL	.\image_texture_gl.h	/^  ~ImageTextureGL();$/;"	p	class:ax::ImageTextureGL	access:public	signature:()
~Material	.\material.h	/^  virtual ~Material() { }$/;"	f	class:ax::Material	access:public	signature:()
~Motion	.\camera.cc	/^Motion::~Motion() { }$/;"	f	class:ax::Motion	signature:()
~Motion	.\camera.h	/^  virtual ~Motion() = 0;$/;"	p	class:ax::Motion	access:public	signature:()
~Object	.\globject.h	/^  virtual ~Object() { }$/;"	f	class:ax::Object	access:public	signature:()
~ProgramGLSL	.\program_glsl.h	/^  virtual ~ProgramGLSL() { this->DeleteProgram(); }$/;"	f	class:ax::ProgramGLSL	access:public	signature:()
~Quad2DGL	.\model_gl.h	/^  virtual ~Quad2DGL() { }$/;"	f	class:ax::Quad2DGL	access:public	signature:()
~RenderAppI	.\utils.h	/^  virtual ~RenderAppI() { }  $/;"	f	class:ax::RenderAppI	access:public	signature:()
~RenderBuffer	.\render_buffer.cc	/^RenderBuffer::~RenderBuffer() {$/;"	f	class:ax::RenderBuffer	signature:()
~RenderBuffer	.\render_buffer.h	/^  ~RenderBuffer();$/;"	p	class:ax::RenderBuffer	access:public	signature:()
~Scene	.\scene.cc	/^Scene::~Scene() { }$/;"	f	class:ax::Scene	signature:()
~Scene	.\scene.h	/^  ~Scene();  $/;"	p	class:ax::Scene	access:public	signature:()
~ScopeGPUTimer	.\utils.h	/^  ~ScopeGPUTimer() {$/;"	f	class:ax::ScopeGPUTimer	access:public	signature:()
~ScopeStatistics	.\utils.h	/^  ~ScopeStatistics() {$/;"	f	class:ax::ScopeStatistics	access:public	signature:()
~ShaderObject	.\shader_object.h	/^  ~ShaderObject() { this->DeleteShader(); }$/;"	f	class:ax::ShaderObject	access:public	signature:()
~TextureGL	.\texture_gl.h	/^  virtual ~TextureGL() {$/;"	f	class:ax::TextureGL	access:public	signature:()
